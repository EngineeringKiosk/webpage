---
layout: ../../../layouts/blog-post.astro
title: "Der komplette Guide rund um SQL Injections"
subtitle: "Alles was du über SQL Injections wissen musst: Herkunft, Relevanz im Jahre 2023, die verschiedenen Angriffsformen, Gegenmaßnahmen sowie historische Hacks."
description: "tl:dr: Seit 1998 bekannt und im Jahr 2023 noch immer die Nummer 1 im Bereich Sicherheitslücken für Web-Applikationen: SQL Injections. Allein im Jahr 2022 wurden 1789 Sicherheitslücken gefunden, die auf SQL-Injections zurückzuführen sind. Die beste Gegenmaßnahme sind weiterhin Prepared Statements. Automatische Erkennung ist noch immer, speziell bei Blind-, Time- und Second-Order-Based Attacken, nicht ausreichend. Fortschritte werden jedoch in der Forschung durch die Kombination von Fuzzing und Machine Learning gemacht."
tags: [
    "Backend",
    "Datenbanken",
    "Sicherheit",
    "Software Engineering"
]
pubDate: 2023-02-19
thumbnail: /images/blog-content/sql-injection/sql-injection-cover.png
headerimage: /images/blog-content/sql-injection/sql-injection-main-image.png
---
import PodcastEpisodeBlogpostAd from '../../../components/PodcastEpisodeBlogpostAd.astro';

## Inhaltsverzeichnis

1. [Was sind SQL Injections?](#was-sind-sql-injections)
1. [Wer hat SQL-Injections entdeckt und seit wann gibt es die Sicherheitslücke?](#wer-hat-sql-injections-entdeckt-und-seit-wann-gibt-es-die-sicherheitslücke)
1. [Sind SQL-Injections überhaupt noch relevant?](#sind-sql-injections-überhaupt-noch-relevant)
1. [Was sind die Gründe, warum diese Sicherheitslücke noch nicht ausgestorben ist?](#was-sind-die-gründe-warum-diese-sicherheitslücke-noch-nicht-ausgestorben-ist)
1. [Welcher Schaden kann durch eine SQL-Injection angerichtet werden?](#welcher-schaden-kann-durch-eine-sql-injection-angerichtet-werden)
1. [Welche Arten von SQL-Injections gibt es?](#welche-arten-von-sql-injections-gibt-es)
1. [Was kann ich gegen SQL-Injections tun?](#was-kann-ich-gegen-sql-injections-tun)
    1. [Prepared Statements](#prepared-statements)
    1. [Aktuelle(re) Versionen](#aktuellere-versionen)
    1. [Limitierte Privilegien für Datenbank-Benutzer (Prinzip der geringsten Berechtigung)](#limitierte-privilegien-für-datenbank-benutzer-prinzip-der-geringsten-berechtigung)
    1. [Web Application Firewalls (WAF)](#web-application-firewalls-waf)
    1. [Schulung der Mitarbeiter](#schulung-der-mitarbeiter)
    1. [Security Testing](#security-testing)
1. [Kann ich meine Applikation automatisch auf SQL-Injections testen?](#kann-ich-meine-applikation-automatisch-auf-sql-injections-testen)
    1. [Statische Analyse](#statische-analyse)
    1. [Dynamische Analyse](#dynamische-analyse)
    1. [Fuzzing](#fuzzing)
1. [Was sind populäre Beispiele für Hacks durch eine SQL-Injection?](#was-sind-populäre-beispiele-für-hacks-durch-eine-sql-injection)

## Was sind SQL Injections?

Eine SQL-Injection ist eine Angriffsart, bei der bösartiger Code über Benutzereingaben in die Datenbank einer Anwendung eingeschleust wird.
Dabei wird eine Schwachstelle im Code der Anwendung ausgenutzt, die es einem Angreifer ermöglicht, beliebige SQL-Befehle auszuführen beziehungsweise existierende Datenbank-Abfragen zu erweitern oder zu ändern.

Abhängig vom Schweregrad der Schwachstelle kann der Angreifer Daten in der Datenbank ändern, löschen oder stehlen, was schwerwiegende Folgen haben kann. Z. B. Datenschutzverletzungen, den Verlust vertraulicher Informationen und sogar die vollständige Kompromittierung des Systems. 

Speziell im Bereich der Web-Programmierung/Web-Applikationen sind SQL-Injection-Angriffe eine häufige und gefährliche Bedrohung. Grund dafür ist, dass Webanwendungen vermehrt SQL-Datenbanken zur Speicherung und Verwaltung von Daten verwenden. Dennoch kann jede Applikation, die mit einer (SQL)-Datenbank interagiert, betroffen sein (unabhängig vom Web-Kontext). 

## Wer hat SQL-Injections entdeckt und seit wann gibt es die Sicherheitslücke?

Der erste bekannte Fall von SQL-Injection wurde 1998 von Jeff Forristal gemeldet.
Im Jahre 1998 hat Jeff Forristal sich mit Sicherheitslücken in einem Windows NT-Server beschäftigt.
Dabei ging es um Bereiche wie den [Internet Information Server v4.0 (IIS)](https://de.wikipedia.org/wiki/Microsoft_Internet_Information_Services), [FrontPage Webbots](https://www.neusob.de/projekt/workshop/webbot.htm), [Cold Fusion Application Server](https://de.wikipedia.org/wiki/ColdFusion#Application_Server) aber auch [ODBC](https://de.wikipedia.org/wiki/Open_Database_Connectivity) und den [MS SQL server v6.5](https://www.microsoft.com/de-de/sql-server/sql-server-2019).

Dabei beschreibt er das erste Mal die heutige bekannte SQL-Injection, als er entdeckte, dass es möglich war, SQL-Befehle durch Benutzereingaben in einer Webanwendung auszuführen. 

Als Sicherheitsforscher hat er seine Resultate auch vor der Veröffentlichung mit Microsoft geteilt.
Die damalige Antwort war etwas überraschend:

> Er tat das einzig Richtige und informierte Microsoft, und deren Antwort war, nun ja, urkomisch.
> Laut ihnen [Microsoft] ist das, was Sie gleich lesen werden, kein Problem, also machen Sie sich keine Sorgen, etwas dagegen zu tun.

Seine Arbeit wurde von Jeff Forristal im Dezember 1998 im Hacker Zone _Phrack_ ([Issue 54](http://www.phrack.org/archives/issues/54/8.txt)) veröffentlicht.
Seitdem hat die SQL-Injektion als Angriffsvektor einen steigender Popularität gewonnen. Primär gefördert durch die schnelle Entwicklung von Webanwendungen in den späten 1990er und frühen 2000er Jahren. Da Webanwendungen immer beliebter und komplexer wurden, bot dies Angreifern die Möglichkeit, die Anwendungen speziell auf die neue Schwachstelle “SQL-Injektion” zu testen und mittels speziellen Benutzereingaben auszunutzen.

<PodcastEpisodeBlogpostAd episode="41" />

## Sind SQL-Injections überhaupt noch relevant?

Die kurze Antwort: **Ja**.

Auch nach 25 Jahren ist die SQL-Injection weiterhin eine der größten Sicherheitslücken im Internet, die für unzählige Datenschutzverletzungen und Angriffe verantwortlich ist:

* **2007**: [OWASP Top 10: Platz #2 (A2 – Injection Flaws)](https://owasp.org/www-pdf-archive//OWASP_Top_10_2007.pdf)
* **2010**: [OWASP Top 10: Platz #1 (A1 – Injection)](https://owasp.org/www-pdf-archive//OWASP_Top_10_-_2010.pdf)
* **2013**: [OWASP Top 10: Platz #1 (A1 – Injection)](https://owasp.org/www-pdf-archive//OWASP_Top_10_-_2013.pdf)
* **2017**: [OWASP Top 10: Platz #1 (A1 - Injection)](https://owasp.org/www-project-top-ten/2017/Top_10)
* **2021**: [OWASP Top 10: Platz #3 (A3 - Injection)](https://owasp.org/www-project-top-ten/)

Weiterhin wurden zum aktuellen Stand (19. Februar 2023), 1789 Sicherheitslücken, die auf SQL-Injections zurückzuführen sind, in der [offiziellen CVE-Datenbank allein für das Jahr 2022 gemeldet](https://www.cvedetails.com/vulnerability-list/year-2022/opsqli-1/sql-injection.html).

## Was sind die Gründe, warum diese Sicherheitslücke noch nicht ausgestorben ist?

1. **Fehlende Wissen**: Vielen Software-Entwicklern fehlt oft das benötigte Know-How und eine gewisse Erfahrung und im Bereich Sicherheit und Sicherheitsbewusstsein

2. **Legacy Code**: Viele Webanwendungen beruhen immer noch auf altem Code, der entwickelt wurde, bevor Best-Practices zur Absicherung eingeführt wurden. Entsprechende Eingabevalidierung oder andere Sicherheitsmaßnahmen, was ihn anfällig für SQL-Injection-Angriffe macht, fehlt dort.

3. **Gesteigerte Komplexität**: Webanwendungen sind im Laufe der Zeit immer komplexer geworden, mit mehr Komponenten und Abstraktionsebenen. Schwachstellen zu erkennen und zu entschärfen, auch solche, die mit SQL-Injection zusammenhängen, ist dadurch deutlich erschwert.

4. **Automatisiertes Testen**: Automatisierte und effiziente Testmethoden zur Erkennung von SQL-Injections (z.B. ohne False Positives) sind kaum vorhanden bzw. nicht verbreitet.

5. **API-Design**: Client-Libraries, die zum Verbindungsaufbau zur Datenbank genutzt werden, können oft immer noch missbraucht oder falsch angewendet werden und geben (unter Umständen) dem Entwickler ein falsches Gefühl von Sicherheit.

6. **Menschliches Versagen**: Entwickler sind auch nur Menschen und Bug-Freie Software zu schreiben ist auch noch nicht 100% möglich. So kann ein Entwickler beispielsweise vergessen, Benutzereingaben zu bereinigen, oder ein Sicherheitsteam räumt der Behebung von Sicherheitslücken nicht rechtzeitig Priorität ein.

7. **Attraktives Angriffsziel und hartnäckige Angreifer**: Fast jede Webanwendung verwendet irgendeine Form von Datenbank im Backend, was es somit zu einem lohnenswerten Angriffsziel macht. Zusätzlich können Angreifer eine Vielzahl von Techniken, einschließlich automatisierter Tools, verwenden, um SQL-Injection-Schwachstellen zu erkennen und auszunutzen.

## Welcher Schaden kann durch eine SQL-Injection angerichtet werden?

Der genaue Schaden bzw. die Möglichkeiten hängen von der entsprechenden Umgebung (z. B. der Datenbank selbst), dem Ausmaß der entsprechenden Lücke, sowie den existierenden Sicherheitsvorkehrungen ab.

Die Schwachstellen können zu folgenden Angriffsszenarien führen:

* Datendiebstahl: Sensible Daten wie Anmeldedaten, Kreditkartennummern und persönliche Informationen
* Änderung von Daten: Datenverlust oder Datenbeschädigung
* Kompromittierung von Anwendungen: Die Kontrolle über eine Webanwendung kann übernommen werden sowie Malware oder Ransomware einschleusen
* Schädigung des Rufs: Negativer Publicity und Verlust von Kundenvertrauen und Geschäftsmöglichkeiten.
* Verstöße gegen gesetzliche Vorschriften: HIPAA, PCI DSS oder GDPR.

Technisch ist dies z.B. folgendermaßen möglich:

* Zugriff auf Daten, die eigentlich geschützt sind:

    ```sql
    SELECT * FROM pages WHERE page_id = 5 OR (1=1 AND protected = 1)
    ```

* Änderungen von Daten, die eigentlich nicht geändert werden sollten: Zum Beispiel via `INSERT`, `UPDATE`, `DELETE`-Statements
    
    Dies kann u.a. für das Einfügen von JavaScript in die Datenbank genutzt werden (Stichwort: [Persistent XSS](https://de.wikipedia.org/wiki/Cross-Site-Scripting#Persistent_oder_best%C3%A4ndig))

* Shell-Befehle können auf dem Server ausgeführt werden

* Schreiben von lokalen Dateien auf den Server selbst (z.B. via [`SELECT INTO OUTFILE ...`](https://dev.mysql.com/doc/refman/8.0/en/select-into.html))
    ```sql
    SELECT INTO OUTFILE ...
    ```
    
    Dies kann unter anderem genutzt werden um eine [Webshell](https://en.wikipedia.org/wiki/Web_shell) zu erzeugen

* Lesen von lokalen Dateien vom Server (z.B. via [`LOAD_FILE()`](https://mariadb.com/kb/en/load_file/) oder [`LOAD DATA INFILE`](https://dev.mysql.com/doc/refman/8.0/en/load-data.html))

* [Denial of Service-Attacken (DoS)](https://de.wikipedia.org/wiki/Denial_of_Service): Z. B. durch zeitbasierte Angriffe
    
    ```sql
    SELECT IF( USER() LIKE 'root@%', BENCHMARK(100000,SHA1('test')), 'false');
    ```

* Ausführen von jeglichen SQL-Funktionen:

    1. Sammlung von zusätzlichen Informationen: [`CURRENT_USER()`](https://dev.mysql.com/doc/refman/8.0/en/information-functions.html)
    2. Unter Umständen können dadurch höhere Rechte für den genutzten Benutzer erlangt werden

* Allgemeine Ausnutzung von [bekannten Sicherheitslücken im Datenbank-Server](https://www.cvedetails.com/vulnerability-list/vendor_id-185/product_id-316/Mysql-Mysql.html) auf Basis von alten Software-Versionen oder Nutzung von unsicheren Software-Komponenten

<PodcastEpisodeBlogpostAd episode="41" />

## Welche Arten von SQL-Injections gibt es?

Es gibt verschiedene Arten von SQL-Injektionsangriffen, von denen jeder seine eigenen Methoden und Ziele hat. Einige der häufigsten Arten sind:

* **Klassische SQL-Injection**: Die einfachste Art der SQL-Injektion, bei der der Angreifer bösartigen SQL-Code in ein Webformular oder ein anderes Eingabefeld einschleust. Der Code wird dann auf dem Server ausgeführt und ermöglicht es dem Angreifer, Daten zu stehlen oder zu verändern.

* **Error Based SQL-Injection**: Bei dieser Art von Angriff verursacht der Angreifer absichtlich einen Fehler im SQL-Code, um Informationen über die Struktur und den Inhalt der Datenbank zu erhalten. Diese Informationen können dann für weitere Angriffe verwendet werden.

* **Blind SQL-Injection**: Bei dieser Art von Angriff erhält der Angreifer keine Informationen zurück, so dass er schwerer zu entdecken ist. Der Angreifer kann verschiedene Techniken anwenden, um Informationen über die Datenbank zu erlangen, z. B. durch Timing-Angriffe, um festzustellen, ob bestimmte Bedingungen wahr oder falsch sind.

* **Out-of-band SQL-Injection**: Hierbei handelt es sich um eine Variante der blinden SQL-Injektion, bei der ein anderer Kanal zur Kommunikation mit dem Angreifer verwendet wird, z. B. DNS- oder HTTP-Anfragen an einen vom Angreifer kontrollierten Server.

* **Second-Order SQL-Injection**: Bei dieser Art von Angriff wird der bösartige SQL-Code in der Datenbank gespeichert und zu einem späteren Zeitpunkt ausgeführt, etwa wenn ein anderer Benutzer auf die Daten zugreift. Dies kann die Erkennung und Entschärfung des Angriffs erschweren.

Das Verständnis der verschiedenen Arten von SQL-Injection-Angriffen ist entscheidend für die Entwicklung wirksamer Gegenmaßnahmen und den Schutz von Webanwendungen vor diesen zunehmend verbreiteten und ausgefeilten Angriffen.

## Was kann ich gegen SQL-Injections tun?

Die beste Absicherung bietet eine Kombination von Best Practices, Tools und Techniken. Einige der wirksamsten Gegenmaßnahmen zur Verhinderung von SQL-Injections in einer Webanwendung sind:

### Prepared Statements

[Prepared Statements](https://de.wikipedia.org/wiki/Prepared_Statement) ist die einzig zuverlässige Art, um sich vor SQL Injections zu schützen.
Vorausgesetzt, diese werden überall im Code angewendet.

Prepared Statements sind SQL-Abfragen, die mit entsprechenden Parametern vorbereitet werden, aber erst zu einem späteren Zeitpunkt den eigentlichen Wert für den Parameter zugewiesen bekommen.
Dabei wird der Wert des Parameters durch einen Placeholder markiert.
Anbei ein Beispiel in Java:

```java
// Statement wird erzeugt
PreparedStatement ps = connection.prepareStatement(
    "SELECT user, password FROM tbl_user WHERE user = ?"
);

// Parameter werden übergeben
ps.setString(1, username);

// Statement wird ausgeführt.
ResultSet rs = ps.executeQuery();

```

Doch was passiert da?

1. Das Statement `SELECT user, password FROM tbl_user WHERE user = ?`an den Datenbank-Server gesendet und intern wird eine ID für das vorbereitete Statement gespeichert.
2. Dem Parameter `?` (als Wert für das Feld `user`) die Zeichenkette aus der Variable `username` zugewiesen.
3. Das Statement wird an den Datenbank-Server versendet und ausgeführt.

Durch die korrekte Verwendung von Datentypen (string, int, float, ...) wird sichergestellt, dass die Werte dementsprechend escaped werden.
Damit ist ein unerwünschter Ausbruch, zum Beispiel aus der Zeichenkette, nicht möglich.

#### Prepared Statements und Performance

Bei mehrfacher Ausführung desselben Statements mit unterschiedlichen Variablen kann es sogar zu einem positiven Geschwindigkeits-Impact kommen.
Der Grund: Der Datenbank-Server kennt die Anfrage bereits und kann daraufhin die Ausführung optimieren.

Bei einer einmaligen Ausführung des Queries ist die Nutzung eines Prepared Statements im Bezug auf die [Performance minimal teurer](https://orangematter.solarwinds.com/2014/11/19/analyzing-prepared-statement-performance/) (im Vergleich zu eiem einfachen SQL Statement).
Der Grund: Die Applikation kommuniziert bei der Query-Vorbereitung bereits mit dem Datenbank-Server.
Dies führt zu zusätzlichen Netzwerk-Roundtrips.

In der Praxis ist dies jedoch selten ein Problem, da:
1. oft andere Stellen mit höherem Optimierungsbedarf in der Applikation existieren
2. die zusätzliche Sicherheit einen größeren Benefit liefert als die Optimierung im µs oder ms-Bereich

### Aktuelle(re) Versionen

Die Nutzung von aktuelle(re)n Versionen von Datenbanken oder Client-Libraries sollte stark forciert werden. Oft enthalten neuere Versionen notwendige Sicherheitsupdates, um bekannten Sicherheitslücken vorzubeugen oder integrieren zusätzliche Features, welche die Sicherheit erhöhen können.

Doch Vorsicht: Auch neuere Versionen können neue Sicherheitslücken beinhalten.
Immer der allerneuesten Version hinterherzujagen ist ggf. auch nicht die beste Empfehlung.
Eine gute Orientierung bieten die Lifecycle-Angaben eurer Software:

* Wie lange wird eine entsprechende Version noch unterstützt und erhält sie Sicherheitsupdates?
* Gibt es eine Long-Term-Support-Version (LTS)?

### Limitierte Privilegien für Datenbank-Benutzer (Prinzip der geringsten Berechtigung)

Welche Privilegien hat der von euch verwendete Datenbank Benutzer? Kann dieser neue Benutzer anlegen? Ist dies eine notwendige Operation von eurer Anwendung?

Schaut euch die benötigten Datenbank-Privilegien eures Datenbank-Benutzers an und überlegt, welche notwendig sind. Befolgt das Prinzip der geringsten Berechtigung, indem du den Benutzerzugriff auf die Ressourcen beschränkt, die er für die Ausführung seiner Aufgaben benötigt. Dies macht möglichen Angreifern das Leben schwerer.

Habt Ihr mehrere Datenbank-Server im Einsatz, um Schreib- und Lese-Zugriffe zu skalieren (Stichwort: Replikation und Schreib-Source und Read-Replica)?
Überlegt, ob Ihr in eurer Applikation auch die Schreib- und Lese-Zugriffe trennt und diese über einzelne Datenbank-Benutzer ausführt. Somit limitiert Ihr die mögliche Angriffsfläche weiter.

Das ganze kann durch Verfahren wie Datenbank-Hardening noch weitergeführt werden:
* Entfernen ungenutzter oder unnötiger Datenbankfunktionen
* Verschlüsseln sensibler Daten 
* Verwendung sicherer Kommunikationskanälen

Weitere Tipps liefert das [OWASP in einem Artikel zur Absicherung eines Datenbank-Servers](https://owasp.org/www-project-proactive-controls/v3/en/c3-secure-database).

### Web Application Firewalls (WAF)

Habt Ihr keine Kontrolle über die Applikation oder Datenbank-Server selbst?
Überlegt eine [Web Application Firewalls (WAF)](https://de.wikipedia.org/wiki/Web_Application_Firewall) vor die Anwendung zu schalten.

Eine Web Application Firewalls (WAF) überprüft die eingehende Anfrage (z.B. die aufgerufene Adresse / URL) und schaut nach bekannten/gefährlichen Patterns.
Klassische Patterns wie

```sql
... WHERE page_id = 5 OR 1 = 1
```

werden problemlos erkannt.

Dies bietet keinen ausreichenden Schutz gegen SQL-Injections, macht es dem Angreifer jedoch schwieriger. Dennoch kann dies als zusätzliche Maßnahme eingebunden werden.

### Schulung der Mitarbeiter

Upskilling ist immer eine gute Sache.
Auch im Fall von SQL-Injections (oder Web-Security im Allgemeinen) können Schulungen und Trainings wahre Wunder wirken.

Inhalt des Trainings könnte u.a. sein:
Sichere Validierungs- und Programmiere- Praktiken
Sicherheitsbewusstsein
Verfahren zur Reaktion auf Vorfälle
Datenbank-Konfiguration

### Security Testing

Scan doch mal die Webanwendung und die zugrunde liegende Datenbank regelmäßig auf Schwachstellen. Die Behebung oder Entschärfung erkannter Schwachstellen sollte entsprechende Priorität in der Entwicklung erhalten.

Aber auch regelmäßig Sicherheitstests durch, z. B. Penetrationstests oder Code-Reviews, um potenzielle Schwachstellen zu ermitteln und die Wirksamkeit der vorhandenen Sicherheitskontrollen zu überprüfen, können hilfreich sein.

## Kann ich meine Applikation automatisch auf SQL-Injections testen?

Komplett ohne manuellen Aufwand ist es nicht möglich. Dennoch gibt es verschiedene Varianten, die dich bei der Absicherung unterstützen können:

### Statische Analyse

Die klassische statische Code-Analyse ist nicht auf SQL-Injections im Speziellen ausgelegt. Dennoch gibt es einige Tools, die entsprechende Unterstützung mitbringen. I.d.R. muss dennoch das Model bzw. entsprechende Tool auf die jeweilige Programmiersprache und sogar auf die verwendete Library angepasst werden. 

Ein positiver Seiteneffekt: Diese Tools können auch andere Code-Qualitätsprobleme aufzeigen, die zu Sicherheitslücken führen könnten.

### Dynamische Analyse

Tools zur dynamischen Code-Analyse simulieren Benutzereingaben und können dadurch Injektionspunkte identifizieren.

Der Platzhirsch in diesem Bereich ist [sqlmap](https://sqlmap.org/) mit support für fast alle SQL basierten Datenbanken, inklusive MySQL, MSSQL, Oracle, PostgreSQL, Amazon Redshift, CockroachDB und Apache Ignite sowie den SQL-Injection-Arten wie Boolean-Based Blind, Time-Based Blind, Error-Based, UNION Query-Based, Stacked Queries und Out-of-Band.

Eine Alternative bietet [OWASP ZAP](https://www.zaproxy.org/). Nicht speziell für SQL Injections ausgelegt, bietet dennoch Unterstützung für diesen Angriffsvektor.

### Fuzzing

Aktuell gibt es Research im Bereich Fuzzing und wie man mit Hilfe von Machine Learning SQL Injections aufspüren kann. Das entsprechende Paper [“SQLi-Fuzzer: A SQL Injection Vulnerability Discovery Framework Based on Machine Learning”](https://ieeexplore.ieee.org/document/9657925) wurde im Jahr 2021 veröffentlicht.
Diverse proprietäre Software-Services werben bereits damit. Im Open Source Bereich ist (unseres Wissens nach) noch nichts Out-of-the-Box einsetzbares veröffentlicht worden.

## Was sind populäre Beispiele für Hacks durch eine SQL-Injection?

* **2007, 7-Eleven**: 130 Millionen Kredit- und Debitkarten-Daten wurden gestohlen. [Eine SQL-Injekction wurde als Haustür genutzt.](https://www.networkworld.com/article/2247145/miami-hacker-exploited-unlimited-database-defects.html).

* **2013, MySpace**: E-Mails, Namen und teilweise Passwörter von fast 360 Millionen Konten wurden entwendet. [Dabei gilt eine SQL-Injection als die eigentlich ausgenutzte Sicherheitslücke.](https://www.ecomsecurity.org/security-news/myspace-victim-major-data-breach-360m-accounts-potentially-affected/)

* **2017, Equifax**: Die privaten Daten von 147,9 Millionen Amerikanern, 15,2 Millionen Briten und etwa 19.000 Kanadiern wurden kompromittiert. Unter anderem enthielten die Daten Namen, Sozialversicherungsnummern, Geburtsdaten und Adressen. [Teil der Strategie der Angreifer war eine SQL-Injection](https://blog.cloudflare.com/thwarting-the-tactics-of-the-equifax-attackers/).

<PodcastEpisodeBlogpostAd episode="41" />