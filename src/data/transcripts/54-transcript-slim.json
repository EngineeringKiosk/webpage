{
  "language_code": "de",
  "audio_url": "https://audio1.redcircle.com/episodes/c55253d1-4bcb-4ccc-8d3c-5042ceef6064/stream.mp3",
  "punctuate": true,
  "format_text": true,
  "dual_channel": false,
  "webhook_url": null,
  "webhook_auth_header_name": null,
  "webhook_auth_header_value": null,
  "audio_start_from": null,
  "audio_end_at": null,
  "word_boost": [],
  "boost_param": null,
  "filter_profanity": false,
  "redact_pii": false,
  "redact_pii_audio": false,
  "redact_pii_policies": null,
  "redact_pii_sub": null,
  "speaker_labels": true,
  "speakers_expected": 2,
  "content_safety": false,
  "content_safety_confidence": null,
  "iab_categories": false,
  "custom_spelling": null,
  "disfluencies": false,
  "sentiment_analysis": false,
  "auto_chapters": false,
  "entity_detection": false,
  "summarization": false,
  "summary_model": null,
  "summary_type": null,
  "auto_highlights": false,
  "language_detection": false,
  "speech_threshold": null,
  "id": "621q6taky2-a72a-4ba0-95e3-27cf85d685ab",
  "status": "completed",
  "error": null,
  "utterances": [
    {
      "text": "A, O, F, R, D, B und L, M, P, S, Q, L, D, E, L und B, G, safe. Entschuldigung, da ging es wohl mit mir durch. Das war nun nicht der Song mit freundlichen Grüßen von der Band die Fantastischen Vier, sondern alles Begriffe von meiner Lieblingsdatenbank. Sofern die Technologie als Datenbank bezeichnet werden kann. Heute geht es um den Datenschruktur-Server Redis. Aber nicht nur, was Redis ist, sondern mit einer Menge Wissen drumherum. Was ist HyperLogLog? Welche Use Cases hat Redis neben Caching? Was sind klassische Fallstricke beim Einsatz von Redis? Und wer ist eigentlich der Kopf hinter dieser Technologie? Das und noch viel mehr in der nächsten Stunde. Los geht's!",
      "start": 5310,
      "end": 43208,
      "confidence": 0.8054561403508773,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "So Andi, nachdem wir in der letzten Episode über die Zukunft gesprochen haben, in der Episode 53, blicken wir heute mal in die Vergangenheit, beziehungsweise du kannst mir jetzt beweisen, ob das wirklich die Vergangenheit ist oder ob das noch ein Thema ist, was aktuell ist, aber es ist eines deiner Lieblingsthemen und zwar geht es um Redis. Du bist ja ein alter Redis-Fanat, du hast Vorträge auf Konferenzen gehalten, du bist durch die ganze Welt gedingelt mit deinem Radies-Vortrag. Also wirst du mir heute mal beweisen müssen, ob Radies wirklich noch zukunftssicher ist oder ob das irgendwas aus der Vergangenheit ist.",
      "start": 50361,
      "end": 81950,
      "confidence": 0.7653235294117648,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ein paar Leute aus meinem Kegel-Club.",
      "start": 82010,
      "end": 84552,
      "confidence": 0.6153333333333334,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ich frage mich immer, wie du das Kegeln reinbringen kannst. Das ist mir ein Rätsel, aber bitte. Ich bin gespannt, wo ihr Radies verwendet im Kegel-Club.",
      "start": 84592,
      "end": 92576,
      "confidence": 0.7588846153846152,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Also ja, mein Name ist ja Andreas. Mein Spitzname ist ja eigentlich Andi. Und dann ist es ja immer so, wie nennt man dich denn eigentlich? Und nur meine Frau und mein Vater nennen mich Andreas, wenn ich irgendeine Scheiße gebaut habe. Das war also so ein Indikator dafür. Der Rest der Welt nennt mich eigentlich Andi. Ein paar Leute aus meinem Kegel-Club nennen mich oft Anti, weil ich oft gegen etwas bin. Und man könnte schon fast sagen, viele Leute in der Technik sind Apple-Fanboys. Der Anti, könnte man sagen, ist eigentlich ein Redis-Fanboy. Und da ist jetzt die Frage, bin ich immer noch ein Redis-Fanboy? Weiß ich nicht ganz, aber warum, werde ich dir sagen. Auf jeden Fall. hatten wir uns bei der Vorbereitung zu dieser Episode darüber unterhalten, was denn wir für ein Thema besprechen. Und da hast du gesagt, ich fände das Thema Redis mal spannend. Und ich habe mich gefragt, Moment mal, ein Doktor der Informatik, der sogar beim Fachschul Datenbanken seinen Doktortitel absolviert hat, findet eine Podcast-Episode über Redis spannend. Das würde mich jetzt mal tierisch interessieren. Was findest du am Thema Redis spannend?",
      "start": 92636,
      "end": 161637,
      "confidence": 0.8157842105263159,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ja, du sagst ja immer, Redis kann alles und Redis ist so toll und das will ich mir jetzt mal anhören. Und da kann ja dann natürlich meine ganzen Datenbankfragen loswerden.",
      "start": 162357,
      "end": 170644,
      "confidence": 0.7760967741935482,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ich glaube, ich habe noch nie bei einer Datenbank gesagt, Redis kann alles. Ich sage immer, jeder denkt, wir bräuchten Redis und merken dann relativ schnell, dass sie oft nicht genau wissen, wie sie ihre Daten speichern wollen oder abfragen wollen. Und dann rennt man auf den Probleme und dann bin ich wieder schuld.",
      "start": 170684,
      "end": 188578,
      "confidence": 0.8587777777777776,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Warum sagen denn Leute, sie brauchen Redis? Was sind in deiner Meinung nach die Anwendungsfelder? Warum sollte jemand auf die Idee kommen, Redis zu verwenden?",
      "start": 190417,
      "end": 198345,
      "confidence": 0.8234799999999999,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ich glaube, der größte Treiber ist, dass sie es oft im Internet gelesen haben. Auf Hacker News, auf Reddit. Nicht zu verwechseln mit Redis.",
      "start": 198966,
      "end": 206554,
      "confidence": 0.7832500000000001,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ja, aber du bist ja schlauer als die ganzen Online-Geschichten. Also warum macht es denn Sinn?",
      "start": 207427,
      "end": 212473,
      "confidence": 0.6981875,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Über die Anwendungsfälle und wo es wirklich Sinn macht, würden wir gleich drauf kommen. Aber erstmal muss man, glaube ich, verstehen, was eigentlich Redis ist und wo darüber diese Episode eigentlich geht.",
      "start": 212493,
      "end": 221983,
      "confidence": 0.8046562500000002,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Also es ist keine Datenbank. Können wir uns da schon drauf einigen?",
      "start": 222023,
      "end": 224366,
      "confidence": 0.6701666666666667,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ah, ich glaub da gehen wir gleich nochmal ein bisschen in den Streit.",
      "start": 224661,
      "end": 228165,
      "confidence": 0.654923076923077,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Okay, dann schieß mal los. Was ist Redis?",
      "start": 228225,
      "end": 230047,
      "confidence": 0.48800000000000004,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Also Redis bezeichnet sich selbst als Open Source In-Memory Data Store. Ist also eine eigene Applikation, die hostet man, betreibt man und da kann man Daten gegenschmeißen und die werden gespeichert. Wenn man im ganzen Spektrum SQL- und NoSQL-Datenbanken unterwegs ist, beziehungsweise die Buzzwords mal gehört hat, würde man sagen, Redis wird in das Spektrum der NoSQL-Datenbanken zählen. Und es ist primär memory-bound. Das bedeutet, Redis selbst konsumiert am meisten die Ressource RAM gegenüber anderen Datenbanken, die sehr viel CPU und Disk oder Network oder sowas konsumieren. Falls man also irgendwie nach Bottlenecks suchen würde, würde man gegebenenfalls oft erstmal auf den RAM gucken, weil Redis würde ich als primär memory-bound bezeichnen. Weil es aber auch ein In-Memory-Datastore ist.",
      "start": 230087,
      "end": 278136,
      "confidence": 0.8148151260504206,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Also ich glaube, die wenigsten Datenbanken sind network-bound und haben irgendwie Probleme mit dem Netzwerktraffic. Aber okay, zur Abgrenzung mal, es ist auf jeden Fall memory-bound, weil alles eben speichert, demnach gespeichert wird. Sehe ich das richtig?",
      "start": 278620,
      "end": 290482,
      "confidence": 0.7174594594594595,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Da siehst du richtig, dass die wenigsten Datenbanken network-bound sind. Da kann man jetzt auch drüber diskutieren, ist Kafka eine Datenbank? Und wenn du mal sehr große Kafka-Cluster-Reshuffeln gesehen hast, dann merkst du relativ schnell, dass auch die network-bound sein können. Oder so ein Hadoop-Cluster oder ähnliches. Also wenn es um ein paar mehr Daten geht, dann ist sowas relativ schnell network-bound, das sag ich dir.",
      "start": 290502,
      "end": 310921,
      "confidence": 0.7300606060606063,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Okay, bind given.",
      "start": 311600,
      "end": 312741,
      "confidence": 0.5053333333333333,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Aber was das super interessante ist, und da bin ich ja wieder ein Fanboy von, Redis bezeichnet sich selbst ja noch nichtmals als Datenbank, sondern als Data Structure Server. Und warum ist das geil? Die meisten NoSQL-Datenbanken supporten irgendwie Dokumente und da kannst du da Strings drin speichern oder wie Memcache nur Key Values, wo Value dann auch entweder nur Raw Bits sind oder so. Redis hat aber Support für native Datentypen. Das bedeutet, du kannst dort Strings, also ganz normale Zeichenketten, speichern, Listen, Hashmaps, Sets oder Sorted Sets. Für die Leute, die nicht ganz versiert in den ganzen Datentypen sind, mal eine sehr high-level Beschreibung. Sets sind eigentlich Listen mit unique values. Also jeder Wert in deinem Set kommt nur einmal vor, wohingegen du denselben Wert mehrfach in eine Liste schreiben möchtest. Sorted Sets ist das gleiche wie ein Set, eine Unique Value, nur mit einem sogenannten Score, also eigentlich einer Zahl versehen und dann kannst du das sortieren. Jetzt könnte man sagen, ja im Moment ein Data Structure Server mit Strings, Listen, Hashmaps und Sets und Sorted Sets ist ein bisschen schwach, oder? Ist richtig. Und jetzt kommt ja die Königsklasse, weswegen Redis auch sehr oft gefeiert wird. Das ganze Ding hat nämlich noch Support für speziellere Datenstrukturen, wie zum Beispiel Geospatial, Bitmaps oder das, was den meisten Leuten nicht sagen wird, HyperLogLog.",
      "start": 312781,
      "end": 398027,
      "confidence": 0.8109777777777779,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Okay, bevor wir in die speziellen Datenstrukturen einsteigen. Also, wenn ich das zusammenfassen kann, ich kann da drinnen einfach mal Zeug abspeichern. Strings, Listen, Hashmaps, Sets oder auch komplexere Datentypen. Das heißt, ich brauche in meiner Applikation keine MySQL-Datenbank, sondern kann das Zeug einfach direkt da drin abspeichern und dann bin ich safe.",
      "start": 398687,
      "end": 417696,
      "confidence": 0.7827924528301888,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Du kannst es einfach dann abspeichern. Safe und Datenbanken ist ja immer so eine Frage.",
      "start": 417716,
      "end": 422118,
      "confidence": 0.6565333333333333,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ja, die Datenbanken sind safe.",
      "start": 422138,
      "end": 423818,
      "confidence": 0.8228,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Die Daten werden erstmal im RAM abgelegt. Das bedeutet, Wenn, ohne spezielle Konfiguration und Persistenz, kommen wir aber gleich noch zu, der Server also neu startet, sind deine Daten weg, weil sie halt im RAM abgelegt wurden.",
      "start": 423838,
      "end": 436467,
      "confidence": 0.842054054054054,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Also es ist ein besserer Cache.",
      "start": 437008,
      "end": 438789,
      "confidence": 0.4446666666666666,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Der Aufgang macht es mir heute aber auch wieder schwierig. Von Haus aus... Der meiste Use Case für Redis ist ein In-Memory-Cache. Meines Erachtens nach nutzt man dadurch aber nicht das Potenzial von Redis. Also Redis kann auch Daten auf Festplatte persistieren. Das bedeutet, du kannst es auch so konfigurieren, dass deine Daten safe sind. Von Haus aus, ohne speziellere Anpassungen, sind deine Daten in einer relationalen Datenbank, die genau dafür ausgelegt ist, sicherer.",
      "start": 438809,
      "end": 469357,
      "confidence": 0.824337837837838,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Das heißt, für einen Shop oder wenn ich eine Bank zum Beispiel implementieren will mit Konten, dann verwende ich keinen Redis?",
      "start": 470077,
      "end": 477341,
      "confidence": 0.7520000000000001,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Doch, kannst du. Du musst halt nur Persistenz anschalten und da vielleicht eine spezielle Art von Persistenz. Kommen wir aber gleich zu zwischen den zwei Arten von Persistenz bei Redis.",
      "start": 477381,
      "end": 486045,
      "confidence": 0.8134000000000001,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Okay, bin gespannt. Dann hast du erwähnt Geospatial, Hyper-Log-Log. Was ist jetzt dieses Zeug?",
      "start": 486445,
      "end": 493009,
      "confidence": 0.6532857142857142,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Geospatial hat das schon im Namen. Geografische Daten und Koordinaten. Und zwar kannst du nativ in Redis Koordinaten, also Längen und Breiten gerade, Longitude und Latitude auf Englisch, speichern und natürlich auch mit denen suchen. Der Klassiker ist irgendwie so Nearby suchen, wenn du ein Radius hast oder eine Boundingbox. Gib mir alle Locations in einem 5km-Radius von der Location, wo ich gerade bin und dann returniert der Redis-Server dir einfach die entsprechenden Koordinaten mit der Distanz. Also sowas kannst du natürlich auch in relationalen Datenbanken machen. In der Regel kombinierst du da aber in deinem Query Cosinus und Sinus und wie die alle heißen, die Funktionen, um dann halt deine Radius-Query zu machen. Und sowas kann halt Redis von Haus aus.",
      "start": 493069,
      "end": 538179,
      "confidence": 0.7764754098360658,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Also man muss erst die Datenbanken in Schutz nehmen, die haben mittlerweile schon auch Funktionen dafür. Gerade Postgres war da schon immer historisch sehr, sehr stark in dem Bereich.",
      "start": 538960,
      "end": 546245,
      "confidence": 0.6945862068965518,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "MySQL aber nicht, oder?",
      "start": 546265,
      "end": 547025,
      "confidence": 0.55,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "MySQL ist ein bisschen schwieriger, hat aber auch Funktionen dafür, aber ist jetzt sicher nicht so leistungsstark wie Postgres.",
      "start": 547445,
      "end": 554150,
      "confidence": 0.6886315789473685,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Gerade nachgeguckt, MySQL 8 hat einen Spatial Data Type.",
      "start": 554847,
      "end": 558410,
      "confidence": 0.6607777777777778,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Und auch einen Index dafür.",
      "start": 558450,
      "end": 560271,
      "confidence": 0.7952,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Wieder was gelernt.",
      "start": 560311,
      "end": 561752,
      "confidence": 0.9103333333333333,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Die Frage ist dann immer, wie gut das auch supported wird, wie du eben sagst, so Queries, wo man dann automatisch den Radius und so weiter mit einbauen kann. Das ist in Postgres sicher am besten supported, aber das kann man demnach dann auch in Redis machen. Und was ist jetzt dieses HyperLogLog?",
      "start": 561792,
      "end": 577024,
      "confidence": 0.790943396226415,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "HyperLogLog ist eine Datenstruktur zur Schätzung der Anzahl von Elementen innerhalb einer Menge. Jetzt würde man sagen, hä? Okay, wenn ich eine Liste habe und ich habe da fünf Elemente, wieso gibt er mir nicht einfach fünf zurück? Bei fünf Elementen ist das relativ einfach, da nimmt man dann vielleicht einfach eine Liste. Aber was ist denn, wenn man eine sehr, sehr, sehr große Liste hat? Und mit sehr, sehr groß meine ich wirklich ein paar Milliarden oder sogar Trilliarden Elemente innerhalb einer Liste. Dann ist es nämlich algorithmisch gar nicht mehr so einfach zu sagen, wie viele Elemente sind denn in der Liste, ohne durch diese ganz lange Liste durchzugehen. Und wer unsere Episode zur Landau- oder zur Big-O-Nutation gehört hat, der weiß dann, umso länger die Liste wird, umso länger dauert die Ermittlung der Anzahl der Elemente in der Liste. Hyper-Log-Log ist nun also ein Algorithmus, der dir nicht die genaue Anzahl in dieser Menge zurückgibt, sondern es ist eine proba... Wie heißt dieses scheiß Wort?",
      "start": 577064,
      "end": 645486,
      "confidence": 0.8207142857142858,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Probabilistisch.",
      "start": 645506,
      "end": 650349,
      "confidence": 0.732,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Es macht halt ein Estimate, ja? Um zu sagen, wie viele Elemente sind denn in dieser Menge? Und dabei wird die Genauigkeit gegen eine effiziente Speichernutzung getauscht. Also HyperLogLog selbst nutzt maximal 12 Kilobyte, kann aber dafür, die die Anzahl von Sets zurückgeben, mit 2 hoch 64 einträgen. 2 hoch 64 ist eine Zahl mit 20 Stellen.",
      "start": 650389,
      "end": 680582,
      "confidence": 0.8087719298245613,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Also groß.",
      "start": 681442,
      "end": 682484,
      "confidence": 0.905,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Sehr groß. Also HyperLogLog ist wirklich nur ein Algorithmus für sehr große Datenmengen. Und da, wo es darum geht, wie viele Elemente habe ich denn jetzt hier in meinem Set.",
      "start": 682524,
      "end": 691314,
      "confidence": 0.8085333333333333,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Also das, was in klassischen Datenbanken der Optimierer eh automatisch weiß, weil er Statistiken von allem mithält.",
      "start": 692023,
      "end": 698369,
      "confidence": 0.7778235294117647,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Richtig, aber auch die Ermittlung dieser Statistiken wird halt dann bei jedem Query, bei jedem Insert und Co. mitberechnet, was dann wieder auf die Performance geht.",
      "start": 698549,
      "end": 706095,
      "confidence": 0.8564230769230767,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Und was ist dann ein Anwendungsfall für sowas? Wann brauche ich sowas?",
      "start": 706115,
      "end": 709478,
      "confidence": 0.7564166666666666,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ein Anwendungsfall wäre zum Beispiel, dass du die eindeutigen Suchbegriffe auf einer High-Traffic-Website tracken möchtest. Stell dir vor Google und Google möchte einfach wissen, Wie viele Unique-Suchbegriffe wurden in der letzten Stunde gemacht? Und dabei würden sie einfach jeden Suchbegriff in die HyperLogLog-Datenstruktur in Redis inserten. Und dann könnten die einfach sagen, HyperLogLog, gib mir mal die Anzahl der Elemente. Dann hätten sie diese Antwort.",
      "start": 709518,
      "end": 734290,
      "confidence": 0.7520461538461539,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Du hast am Anfang auch Bitmaps erwähnt. Kannst du noch kurz erklären, was Bitmaps sind?",
      "start": 734310,
      "end": 739071,
      "confidence": 0.7049999999999998,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Hast du schon mal File-Permissions auf einem Linux-System gesetzt?",
      "start": 739111,
      "end": 741972,
      "confidence": 0.6163333333333333,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "In den letzten zehn Minuten wahrscheinlich nicht.",
      "start": 742012,
      "end": 744052,
      "confidence": 0.8707142857142857,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Aber sehr wahrscheinlich schon mal ein paar in den letzten Wochen, oder? Also dieses ChangeMod 0777 und dann auf irgendeine Datei.",
      "start": 744112,
      "end": 751475,
      "confidence": 0.6152380952380951,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Natürlich.",
      "start": 751515,
      "end": 751995,
      "confidence": 0.89,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Wenn du mal irgendwelche Permission Error hattest, dann setzt du eh immer alles auf 777. Alle Systemadministratoren und Security-Menschen, bitte einmal weghören. Dieses 0777 kann als Bitvektor repräsentiert werden. Und das kannst du zum Beispiel genau in einer Bitmap speichern, wo jedes einzelne Bit eine spezielle Permission darstellt. Natürlich kannst du sowas natürlich auch durch einen ganz klassischen String oder so darstellen, aber es ist natürlich deutlich effizienter, wenn du eine spezielle Datenstruktur dafür hast, die genau auf sowas ausgelegt ist.",
      "start": 752015,
      "end": 783787,
      "confidence": 0.7365802469135803,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Aber wie läuft das jetzt? Habe ich dann da einen Bitmap-Vektor pro Eintrag oder speichere ich da ein großes Bitmap ab, was dann jedes Bit ein File darstellt oder sowas zum Beispiel oder einen Eintrag darstellt?",
      "start": 783847,
      "end": 798249,
      "confidence": 0.8080277777777776,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ja, das kommt ja ganz drauf an, wie du deine Datenstruktur selbst maintainst und wie groß dein Bitvektor ist.",
      "start": 798609,
      "end": 803370,
      "confidence": 0.6987368421052631,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Also wenn wir da mal dieses klassische Beispiel nehmen, wobei man gerade überlegt, eigentlich dieses Geschlechtsbeispiel mit männlich-weiblich, das wir auf der Uni auf- und abgebetet haben, immer als Beispiel für Bitmaps und andere Indexstrukturen, ist eigentlich auch ziemlich veraltet. Gibt es eigentlich ein gutes Beispiel, was 0 und 1 hat?",
      "start": 803870,
      "end": 821404,
      "confidence": 0.8518039215686272,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "In der Redis-Dokumentation gibt es ein Beispiel genau dafür, weil es gibt nämlich auch noch eine spezielle Datenstruktur, die nennt sich Bitfields, und die sind genau für 0 und 1 Elemente ausgelegt und deren Beispiel ist, du möchtest wissen, welcher IoT-Sensor in der letzten Stunde gesendet hat. Und da erstellen die dir ein Bit-Field für jede Stunde und dann kannst du sagen, okay, Sensor 500 hat in der letzten Stunde gesendet und somit setzen die das Bit auf 1. Also wenn du wirklich nur 0 und 1 tracken möchtest, dann kannst du allein ein Bit-Field nehmen und wenn du halt wirklich einen richtigen Bit-Vektor brauchst, dann würdest du halt eine Bitmap nehmen.",
      "start": 821444,
      "end": 859441,
      "confidence": 0.7336785714285715,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Aber wie ist jetzt der Anwendungsfall? Speichert er einen großen Vektor ab oder ich habe immer ein Key, ich rufe ja alles anhand eines Primary Keys ab, oder? Es ist alles in Redis anhand von dem Primary Key gespeichert.",
      "start": 860166,
      "end": 871410,
      "confidence": 0.7443333333333332,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ja, bei einer Bitmap hast du den Key und dann hast du noch ein Offset und dann eine Value und der Offset kann bis zu 2 hoch 32 sein und das repräsentiert Bitmaps in der Größe von 512 MB. Das bedeutet, dein Bitmap-Vector kann eine ganze Menge sein. Und wenn du von mir aus deine File-Permissions so viel machen möchtest, kannst du es halt auch machen.",
      "start": 871810,
      "end": 893142,
      "confidence": 0.7485303030303031,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Aber das wird dann zu einem Key gespeichert. Ich habe einen Key und dann habe ich 512 MB einen Bitvector dazu.",
      "start": 893182,
      "end": 900768,
      "confidence": 0.7417142857142858,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ganz genau. In Redis fängt erstmal generell alles mit einem Key an. Und diesen Key musst du auch kennen oder dir halt irgendwie zusammensetzen.",
      "start": 900788,
      "end": 908435,
      "confidence": 0.7835000000000001,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Also es ist eine Key-Value-Datenstruktur und der Value kann dann aber verschiedene Formate annehmen. Das kann dann eben geospatial sein oder eine Bitmap oder ein String oder auch eine Map dann intern nochmal.",
      "start": 908815,
      "end": 922567,
      "confidence": 0.785030303030303,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ganz genau. Es ist eine klassische Key-Value-Datenstruktur wie Memcached zum Beispiel, wo halt aber Value dann ein spezieller Datentyp sein kann.",
      "start": 922607,
      "end": 930253,
      "confidence": 0.7944761904761906,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Also wenn ich dann zum Beispiel Maps verwende als Format, dann habe ich eigentlich eine Map von einer Map, oder? Weil ich einen Key Lookup habe und als Value habe ich dann eigentlich nochmal eine Map.",
      "start": 931038,
      "end": 940561,
      "confidence": 0.7309444444444444,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Das ist richtig, wenn du die erste Dimension, weil die erste Dimension ist ja dann der Redis-Server. Also der Redis-Server selbst, wenn du so ein bisschen so möchtest, ist eine sehr, sehr große Generic Map.",
      "start": 940581,
      "end": 952505,
      "confidence": 0.7856571428571429,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ja, also ich habe zwei Lookups dann. Ich habe einmal den ersten Primary Key Lookup und dann kann ich nochmal einen Lookup in der Map haben im Value.",
      "start": 952565,
      "end": 960147,
      "confidence": 0.6797142857142856,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ja, richtig, obwohl du natürlich den ersten Lookup, der ist ja transparent für dich, weil das ist ja dann die Funktionalität des Redis-Servers, wie du das abfragst. Du kannst ja zum Beispiel sagen, du hast einen speziellen Befehl, um das fünfte Element in einer Liste zu kriegen, zum Beispiel. Und wenn du das machst, dann sagst du dem Redis-Server ja bereits, dass deine Datenstruktur, auf die du zugreifen möchtest, eine Liste ist. Und somit gibst du dem ja den Key mit. Somit ist der erste Lookup in deiner Generic Map dem Redis-Server ja transparent für dich und davon kriegst du ja eigentlich gar nichts mit.",
      "start": 960608,
      "end": 991524,
      "confidence": 0.7575999999999998,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Also ihr fragt dann zum Beispiel ab, gib mir den fünften Freund von Andi und Andi ist der Primary Key und dann bekomme ich das fünfte Element, den fünften Freund.",
      "start": 991784,
      "end": 1000030,
      "confidence": 0.7309,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ganz genau. Und das ist dann eine Zeichenkette, weil innerhalb einer Liste man Zeichenkennt speichern kann.",
      "start": 1000411,
      "end": 1005134,
      "confidence": 0.6315,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Das heißt aber, wenn man es jetzt wieder im Vergleich setzt zu klassischen Datenbanken, ich habe keinen Sekundärindex, den ich hinzufügen kann. Ich kann nicht mehrere Indizes hinzufügen. Ich habe immer einen Lookup anhand des Primary Keys, also anhand meines Keys, den ich festlege.",
      "start": 1005817,
      "end": 1020806,
      "confidence": 0.7856590909090909,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ganz genau. Du musst halt deinen Key, auf den du zugreifst, musst du halt kennen bzw. irgendwie stabil berechnen können.",
      "start": 1020826,
      "end": 1028250,
      "confidence": 0.7682499999999999,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Warum sollt ihr denn überhaupt Redis verwenden, wenn ihr das auch in der MySQL speichern könnte? Kann das ja alles auch in der MySQL Datenbank speichern.",
      "start": 1028493,
      "end": 1035118,
      "confidence": 0.7172692307692308,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Prinzipiell kannst du erstmal alles tun, was du möchtest. Der große Unterschied ist halt, dass je nach Abfrage und je nach verwendetem Datentyp deine Abfragezeit bei Redis konstant ist, wohingegen bei MySQL natürlich ab und zu mal auf der Festplatte nochmal rumgesprungen werden muss, je nach Datengröße, je nach WHERE-Statement, GROUP BY und so weiter und so fort ist die Abfrage unter Umständen nicht konstant, wo du hingegen natürlich bei Redis alles primär im RAM gespeichert hast, somit der Zugriff natürlich enorm schnell ist und wie gesagt durch den HashMap-Lookup bei sehr vielen Befehlen halt eine konstante Response-Zeit von sehr sub millisecond teilweise hast.",
      "start": 1035159,
      "end": 1074263,
      "confidence": 0.7957596153846149,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ich habe ja zur Vorbereitung von dieser Episode mir natürlich Performance-Statistiken rausgesucht und Blog-Einträge studiert, MySQL vs. Redis, in der Hoffnung, dass ich irgendwas finde, dass MySQL eh gleich schnell ist wie Redis. Ich bin nur leider enttäuscht worden. Alle Statistiken, die ich gefunden habe, waren ungefähr, dass MySQL doppelt so viel Zeit pro Anfrage braucht wie Redis, so im Schnitt, wenn ich so diese Graphen vergleiche. Ist natürlich ein unfairer Vergleich, muss man auch sagen, Datenbank ist für was anderes gedacht oder eine MySQL Datenbank ist für was anderes gedacht und ihr habt da natürlich Transaktionen, Sicherheit, dass das auf der Festplatte auch landet, gespeichert ist, Garantien. Aber ich muss mich leider enttäuschen, habe nichts Gegenteiliges gefunden, obwohl ich im Kopf gehabt habe, dass es mal sehr knapp war für manche Use Cases, aber habe leider nichts mehr dazu gefunden. Also wer wirklich sehr, sehr schnellen Zugriff braucht und auf die restlichen Sachen verzichten kann, was eine klassische Relationale Datenbank anbietet, das heißt Transaktionen, die ganze Sicherheit, User Verwaltung, komplexe SQL Queries, Indices, der ist natürlich mit Redis gut bedient und kann da sehr viel Speed natürlich rausholen.",
      "start": 1074603,
      "end": 1139318,
      "confidence": 0.7942539682539683,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Es ist natürlich ein völlig unfairer Vergleich. Du vergleichst ja ungefähr gerade ein Gewächshaus mit einem Tesla.",
      "start": 1139616,
      "end": 1145081,
      "confidence": 0.7294117647058823,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Jetzt bin ich gespannt was das ist, aber vielleicht beantworte ich es lieber nicht.",
      "start": 1145101,
      "end": 1149225,
      "confidence": 0.5622142857142858,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Naja also MySQL Datenbank hat einen Query Parser, der hat Transaktionen, ACID, allem drum und dran. Was dann gegebenenfalls bei Redis nicht der Fall ist.",
      "start": 1149265,
      "end": 1160936,
      "confidence": 0.75504,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Aber jetzt hast du schon so groß behauptet, du kannst da eh Persistenz speichern und du würdest so eine Bank implementieren. Bin ich gespannt, was für eine Bank dir den Auftrag geben würde, wenn du sagst, du implementierst das mit Redis. Aber wie schaut denn das jetzt aus mit der Persistenz?",
      "start": 1161320,
      "end": 1175670,
      "confidence": 0.7324509803921566,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Also generell habe ich ja gesagt, Redis speichert alles im RAM und der RAM ist natürlich mehr oder weniger als flüchtig markiert. Flüchtig bedeutet, ich speichere...",
      "start": 1176010,
      "end": 1184196,
      "confidence": 0.7124999999999998,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Eher mehr als weniger, aber ja.",
      "start": 1184236,
      "end": 1185357,
      "confidence": 0.6433333333333333,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ich speichere was in Redis, starte den Redis-Server neu und dann sind deine Daten einfach weg, weil, wie gesagt, der RAM ist flüchtig. Persistenz gibt es aber auf zwei Arten. Und zwar gibt es einmal das Format Redis-Database und einmal das Append-Only-File. Das Redis-Database, in Kurzform RDB, besagt, Wenn innerhalb von einem Zeitintervall eine gewisse Anzahl an Keys modifiziert wurden, dann dampfe bitte die ganze Datenbank einmal auf Disk. Das bedeutet, wenn innerhalb von 10 Minuten mehr als 40 Keys modifiziert wurden, dann nehme die ganze Datenbank und dampfe sie auf Disk. Das hat natürlich den Vorteil, dass du für 10 Minuten sauschnelle Performance kriegst, weil halt alles im Rahmen ist. Du hast aber auch den Nachteil, dass du ein 10-Minuten-Fenster hast, wo du einen potenziellen Data-Loss für die letzten 10 Minuten beziehungsweise für die Änderungen der letzten 10 Minuten hast.",
      "start": 1186461,
      "end": 1242509,
      "confidence": 0.8347659574468088,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Und wie erklärst du das der Bank, deinem Auftraggeber, dass du nur 10 Minuten sicher bist?",
      "start": 1242530,
      "end": 1247912,
      "confidence": 0.702,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ich würde auch keine Bank in Redis implementieren, aber der Bank würde ich sagen, nimm doch lieber Append-Only-File. Und Append-Only-File besagt, jeder Befehl, jeder Schreibbefehl, der an Redis gesendet wird, wird erstmal in ein File appendet, also das bedeutet SetCounter1, SetCounter1, SetCounter1, dann hättest du auf den KeyCounter den Value 3 und in dem Append-Only-File hast du dreimal untereinander SetCounter1 stehen. Eine kleine Korrektur, es muss natürlich Increment Counter heißen und nicht Set Counter. Wenn du jetzt den Redis-Server neu startest und der Redis-Server sieht, ah da ist ein Append-Only-File, dann nimmt er sich das, liest das und arbeitet die Befehle von oben ab. Somit hast du eigentlich ein komplettes, ja man könnte fast sagen Transaction-Log vom Redis-Server. Jetzt ist es natürlich so, wenn du sehr sehr viele Operationen hast, dass das Append-Only-Log sehr sehr lang wird und somit der Reboot von einem Redis-Server sehr sehr lange dauern kann, weil jeder einzelne Befehl abgearbeitet wird. Du kannst auch das Append-Only-File kompakten lassen. Das ist ein Prozess, der geht über dein Append-Only-File, schaut sich die ganze Sache an und würde dann diese dreimal SetCounter1 auf SetCounter3 modifizieren, dass du somit die Befehle einfach kompaktest, dass somit der Restart von einem Redis-Server zum Beispiel schneller ist. Und jetzt kommt der Clou, du kannst natürlich auch das Redis-Database-Format mit dem Append-Only-File kombinieren.",
      "start": 1248667,
      "end": 1337904,
      "confidence": 0.790890410958904,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Wird das Ganze dann langsamer im Betrieb? Weil ich muss da ja ständig in irgendeiner Datei schreiben, die dann auf die Platte wahrscheinlich gespeichert wird. Also ich muss wahrscheinlich nicht warten drauf, weil ich kein klassisches Transaktionssystem habe, aber ich muss das natürlich irgendwie rauspushen.",
      "start": 1337924,
      "end": 1351314,
      "confidence": 0.7694222222222222,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ja, langsamer ist immer so ein komisches Wort, besonders wenn wir über Performance sprechen. Ich würde mich mal aus dem Fenster lehnen und sagen, natürlich hat AppendOnlyFile ein Overhead. Aber dieser Overhead wird bei weitem nicht eine Sekunde sein. Und das bringt mich zu meiner nächsten Frage, ist das relevant für dich? Weil das kommt wirklich ganz stark auf die Detailimplementierung von Redis an. Was sie ja machen könnten ist, Redis könnte ja bei aktivierter AppendOnlyFile Persistierung beim Start zwei Threads hochfahren. Einmal den Haupt-Thread von Redis, der nimmt die Schreibbefehle entgegen und führt diese aus und der zweite Thread kümmert sich nur um die Persistierung des Schreibbefehls. Und somit hättest du mit Inter-Thread-Kommunikation dein Overhead wieder minimiert, weil du das Append-Only-File natürlich in den zweiten Thread schreiben würdest. Nachteil wäre natürlich dann in der Hinsicht, dass du wieder ein minimales Zeitfenster hättest, wo du Datenverlust hast. Aber ganz im Ernst, ich glaube dieses Zeitfenster wäre so klein, Das garantiert dir MySQL auch nicht.",
      "start": 1351334,
      "end": 1411662,
      "confidence": 0.7573841463414634,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Aber man muss natürlich schon immer bedenken, dass wenn du jetzt sagst, du hast einen Hauptspeicher und du lastest den Hauptspeicher voll aus, indem du da voll draufknallst, speicherst und 100% auslastest, im Idealfall, dann müsstest du theoretisch in der gleichen Geschwindigkeit auch auf die Platte schreiben können, was natürlich nicht möglich ist. Dann wird automatisch die Platte zum Bottleneck oder dir wird der Cache volllaufen oder der Buffer volllaufen, mit dem du auf die Festplatte schreibst. Also das Szenario geht natürlich dann nur, dass du auch viele Lesezugriffe hast und weniger Schreibzugriffe, dass das im Hintergrund immer rauspipen kann, was ja aber in der Realität wahrscheinlich bei den meisten Use Cases der Fall ist, weil du willst ja viel öfters lesen als schreiben hoffentlich. Weil wenn du 100% nur schreibst, ist die Frage, ob Redis die richtige Struktur, die richtige Datenstruktur oder der richtige Speicherserver dafür ist.",
      "start": 1411722,
      "end": 1462544,
      "confidence": 0.8129121621621623,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Aber wenn ich dir jetzt nur mal zuhöre und keine kritischen Gegenfragen stellen würde, würde ich sagen, oh, Redis würde ich ja niemals einsetzen. Wolfgang, von wie viel Schreibzugriffen reden wir denn hier, dass die Platte nicht mehr nachkommt, ein String, irgendwas zwischen 100 Zeichen dauerhaft auf die Platte zu schreiben?",
      "start": 1462584,
      "end": 1479332,
      "confidence": 0.7786078431372547,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Also die meisten Workloads sind hoffentlich read-heavy und damit hast du dieses Problem nicht. Aber wenn du jetzt davon ausgehst, dass du es voll auslasten willst, dann hast du da natürlich auch wieder ein Bottleneck.",
      "start": 1479830,
      "end": 1490601,
      "confidence": 0.7439714285714284,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Und wenn, angenommen, wir hätten einen Use Case, der knallt an das Schreiblimit der Festplatte. Du hast da natürlich auch noch ein paar Buffer, die du erstmal füllen musst. Es geht ja nicht immer sofort drauf, sondern der hat natürlich auch Write Caches etc. Also da hängen noch ein paar technische Layer zwischen. Das ist die erste Baustelle, die zweite Baustelle. Wenn du wirklich so ein Use Case hast, dann schadest du deine Schreibzugriffe sowieso über mehrere Redis-Nodes und dann wendest du ein Algorithmus wie Consistent Hashing an, wo du einfach deine Schreibzugriffe über mehrere Redis-Server schadest.",
      "start": 1490642,
      "end": 1523727,
      "confidence": 0.7736907216494844,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Aber das wende ich ja sowieso an, egal ob ich jetzt eine klassische relationale Datenbank Redis oder sonst was verwende, wenn ich das klassische Sharding-Algorithmus.",
      "start": 1524076,
      "end": 1531340,
      "confidence": 0.6684800000000002,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ja, richtig, aber durch die Verteilung der Schreibzugriffe und durch Consistent Hashing solltest du deine Schreibzugriffe recht gut balancieren können und somit sehr, sehr schnell deine einzelnen Platten entlasten. Aber das geht schon wieder hier in High-Performance-Optimierung, wo natürlich auch Redis angewendet wird, gar keine Frage.",
      "start": 1532080,
      "end": 1548828,
      "confidence": 0.8001086956521738,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Hat Redis irgendwie so eine Cluster-Variante oder setzt ihr das eigentlich immer auf einem Single-Host ein?",
      "start": 1549645,
      "end": 1555590,
      "confidence": 0.686375,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Architekturtechnisch hat Redis ein Cluster. Ist noch gar nicht so alt. Hab ich selbst noch nicht genutzt, weil das Cluster-Konzept ein bisschen anders ist. Das würde ich jetzt für diese Episode erst mal zur Seite schieben. Da können wir mal eine eigene Episode machen, was eigentlich ein Cluster ist und warum zum Beispiel das Redis-Cluster-Konzept eher Client-heavy ist gegenüber einem Cassandra-Cluster eher Server-heavy. Aber die klassische Architektur, die man bei Redis fährt, ist eigentlich ein Leader-Follower-Prinzip. Das bedeutet, du hast einen Write Leader und hast verschiedene Follower, die die Daten replizieren. Und dann legst du deine Lesezugriffe primär auf die Follower und deine Schreibzugriffe auf den Leader. Und somit hast du dann natürlich ganz klassische Replikation.",
      "start": 1555650,
      "end": 1598621,
      "confidence": 0.7802327586206894,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Muss ich für diese Replikation dann dieses Event-Only-File haben?",
      "start": 1598661,
      "end": 1603084,
      "confidence": 0.7072222222222222,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Nein, musst du nicht.",
      "start": 1603104,
      "end": 1603684,
      "confidence": 0.5822499999999999,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Und die Replikation läuft dann asynchron oder wie läuft die ab?",
      "start": 1604525,
      "end": 1607952,
      "confidence": 0.6796363636363637,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ja genau, kannst natürlich verschiedene Buffer noch konfigurieren und wie lange darf das hinterher hängen und so weiter und so fort.",
      "start": 1607992,
      "end": 1615448,
      "confidence": 0.8567619047619046,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Wie bist denn du eigentlich in die ganze Redis Schiene reingetrifftet und was war dein Anwendungsfall, wo du dann Redis lieben gelernt hast?",
      "start": 1616649,
      "end": 1624031,
      "confidence": 0.7548260869565216,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Es ist also schon ein bisschen her, wir haben ja jetzt 2023, das bedeutet, das war, das ist knapp zehn Jahre her, in meinem, kurz nachdem ich bei Trivago angefangen habe, kam die Systemadministrator zu uns, Und die hatten sehr, sehr viel Knowledge im Bereich MySQL, aber wir hatten halt auch Redis in verschiedenen Situationen eingesetzt. Und irgendwann sagten die zu uns, hör mal, unser Monitoring-System spuckt halt in ganz komischen Intervallen immer so eine 500 aus auf der Webseite. Das bedeutet Server-Error. Und wir verstehen nicht, warum. Kann sich das mal wer ansehen. Und dann bin ich da tiefer rein, tiefer rein, tiefer rein, tiefer rein. Und im Endeffekt hat sich herausgestellt, unsere Redis-Datenbank skaliert nicht.",
      "start": 1624071,
      "end": 1664918,
      "confidence": 0.7924615384615387,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Das heißt, du hast Redis gar nicht eingeführt damals?",
      "start": 1665326,
      "end": 1667747,
      "confidence": 0.7287777777777779,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Nee, Redis war schon da. Der Haupteinsatz von Caching-Systemen war Memcache damals und ich glaube, wir hatten ein oder zwei Redis-Instanzen. Als ich dann gegangen bin, war das Bild andersrum. Auf jeden Fall Grund, von diesen kontinuierlichen Outages auf der Webseite war eigentlich folgender. Wir hatten einen großen Redis-Server, weil der hatte so 150, 180 Gigabyte Daten in einer Redis-Instanz. Die wurden alle im Rahmen gehalten und wir hatten Persistenz aktiviert über das Redis-Database-Format. Und ich hatte gerade gesagt, wenn innerhalb von 10 Minuten 40 Keys geändert werden, dann nimmt er diese ganze Datenbank und schreibt die auf Disk. Diese 10 Minuten und diese 40 Keys kann man natürlich konfigurieren. Du kannst auch 60 Minuten und 3000 Keys draus machen, aber ist ja irrelevant. Der Punkt ist, umso mehr man schreibt in sehr kurzer Zeit, umso öfter wird die ganze Datenbank auf Platze persistiert. Und um eine Datenbank zu persistieren, brauchst du ja eine Kopie der Daten mehr oder weniger, beziehungsweise du musst wissen, ich möchte jetzt persistieren und du musst ja wissen, welche Daten sollen denn persistiert werden. Was Redis intern gemacht hat, der hat sich also diese 180 Gigabyte Datenbank genommen, hat diese Pagetable mit den ganzen Pointern und allem drum und dran kopiert, Und hat dann die auf Platte geschrieben. Und diese Page-Table-Kopiererei hat bei 180 GB irgendwas so um die 3 bis 4 Sekunden bei uns damals gedauert. Und das hat der alle 10 Minuten gemacht, weil wir ihm sehr sehr viel Daten geschrieben haben. Und in dieser Zeit hat der komplette Redis-Server geblockt, und geblockt meine ich, der hat keine neuen Client Connections angenommen, der hat keine Befehle mehr angenommen, der hat einfach geblockt, weil Redis immer noch bei sehr, sehr vielen Befehlen Singles-Reddit agiert. Das bedeutet, auf einem CPU, auf einer CPU, der arbeitet das ab und benutzt bei vielen Operationen gar nicht die kompletten Möglichkeiten von modernen Servern.",
      "start": 1667767,
      "end": 1772650,
      "confidence": 0.7919333333333335,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ja wobei du an sich immer nen snapshot fahren musst und da musst du einfach mal blocken für den snapshot ist es fast nötig.",
      "start": 1773252,
      "end": 1781864,
      "confidence": 0.8515416666666665,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Das ist korrekt aber das war damals der grund warum unsere website halt ab und zu mal 500 ausgesprochen hat beziehungsweise ab und zu. Nämlich nur abends zu Primetime, wenn der Traffic heavy war. Und das war so ein bisschen doof, weil ich konnte es nicht reproduzieren und ich habe es super lange nicht verstanden. Und dann bin ich halt so tief nach Redis rein und habe mich da mehr und mehr und mehr mit beschäftigt. Wir haben auch Segmentation Falls gefunden auf FreeBSD, die haben wir dann mit dem Autor noch gefixt und allem drum und dran. Da kann ich auch mal den Pull-Request nochmal in den Shownotes verlinken. Sehr interessant, wie wir das dann gedebugt haben. Auf jeden Fall ist dann irgendwie die ganze Sache entstanden und es ist primär mit einer Hassliebe entstanden, aber inzwischen habe ich mich halt so tief eingearbeitet, dass ich diese Datenbank echt lieben gelernt habe.",
      "start": 1781884,
      "end": 1824236,
      "confidence": 0.7567908496732028,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Und wie hast du es damals gelöst dann?",
      "start": 1824637,
      "end": 1826378,
      "confidence": 0.537875,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Das war nicht eine Lösung. Auf der einen Seite habe ich mir angesehen, was für Daten schreiben wir und welche Komplexität haben diese Schreib- und Lesezugriffe. Das bedeutet Landennotation, O von N, O-Notation. Das Schöne an Redis ist, in der Redis-Dokumentation steht zu jedem Befehl die Zeitkomplexität von diesem Befehl und ich habe mir ganz genau angesehen, welche Schreibbefehle und welche Lesebefehle nehmen wir und habe die zeitlich optimiert, so dass auf der einen Seite die Ausführung von den einzelnen Befehlen schneller ist und auf der anderen Seite habe ich mir angesehen, was wird eigentlich in dieser sehr großen Redis-Instanz gespeichert und habe die einzelnen Use-Cases getrennt auf verschiedene Redis-Instanzen. Use-Cases, die wirklich Datenpersistenz brauchen, die habe ich da gelassen. Use-Cases, die klassisches Caching haben, das bedeutet, die dann wirklich einfach mal bei einem Neustart weg sein können, habe ich auf einen anderen Redis-Server verschoben, damit man einfach a, eine kleinere Datenmenge pro Redis-Server hat und somit dieser Copy von der Pagetable nicht mehr so lange braucht. Also ich habe, wenn man ganz einfach drüber spricht, die komplette Datenarchitektur von den Redis-Servern umgeschmissen und den Use Case dahin geschoben, wohin er gehört.",
      "start": 1826519,
      "end": 1896292,
      "confidence": 0.8268958333333333,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Jetzt wenn wir dann zurückkommen zu meiner ganz initialen Frage, ist ja schon eine Zeit her. Was sind denn jetzt dann die idealen Use Cases dafür? Jetzt hast du einen Use Case erklärt, der nicht funktioniert hat, beziehungsweise dass du es dann alles verschoben hast. Was wären jetzt so klassische Use Cases, wo du sagst, okay, Redis wäre eine gute Lösung dafür?",
      "start": 1896872,
      "end": 1914716,
      "confidence": 0.7202580645161288,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Also der ganz klassische Use-Case ist erstmal Caching oder zum Beispiel das Speichern von Web-Sessions. Ich glaube, das ist so der Use-Case, der in vielen Content-Management-Systemen eingesetzt wird. Fast jedes Content-Management-System hat irgendwie ein reddes Cache-Adapter. Läuft eigentlich so, wie viele Cache-Systeme laufen. Es kommt eine Anfrage rein, der Code checkt, ist was im Cache, macht eine Abfrage an Redis. Wenn ja, retunier den Cache. Wenn nein, frag bitte in der SQL-Datenbank ab, schreib diese Daten in Redis und retunier dann. Ja, damit der nächste Zugriff zum Beispiel schneller läuft. Das ist so der Standard-Use-Case. Was man aber auch sehr schön machen kann, ist, stellt euch mal vor, ihr habt eine sehr, sehr, sehr große Datenbank-Tabelle. Und auf dieser Datenbank-Tabelle sind auch ein paar Indizes drauf. Schreibzugriffe auf diese Datenbank-Tabelle werden langsamer, umso mehr Daten da drin sind, weil bei den meisten Schreibzugriffen muss der Index neu gebildet werden. Abhängig natürlich vom Index. Was ihr also jetzt vermeiden wollt, ist, dass ihr während eines Request-Response-Behaviors in diese Datenbank-Tabelle schreibt, weil bei steigendem Traffic werden die Schreibzugriffe langsamer und somit wird die API-Response zum Beispiel langsamer. Was man jetzt zum Beispiel machen kann, ist, ihr schreibt diese Daten, die eigentlich in die Tabelle geschrieben werden, in Redis, weil die Schreibzugriffe sind da sehr schnell, habt einen Cronjob, der schaut alle paar Minuten in Redis nach, holt sich die Daten in Redis und schreibt sie dann in die Datenbanktabelle zurück, weil da ist die Schreibgeschwindigkeit ja egal, ihr seid ja im Cronjob. Und falls ihr jetzt irgendwo eine Webview habt im Admin-Panel, die diese Daten aus dieser sehr großen Datenbank-Tabelle rausnimmt und anzeigt, lest ihr einmal aus der Datenbank-Tabelle und aus dem Redis. Weil auch die Leseoperationen aus dem Redis sind ja schnell und merge diese Daten. Somit kann man natürlich so ein Delay-Write, wenn du so möchtest, so ein Delay-Datastore aufbauen, ohne irgendwie die User-Experience zu vernachlässigen. Ein anderer Use Case ist aber auch klassische Message Queues oder beziehungsweise eher PubSub, hatten wir in Episode 52 auch drüber gesprochen. Asynchrone Verarbeitung und PubSub, weil Redis supportet auch PubSubs oder sogar neuerdings auch Streams. Wer so ein bisschen an Kafka denkt, sich aber nicht das Schiff Kafka hinstellen möchte und nicht jedes Kernfeature von Kafka braucht, kann zum Beispiel auch Redis Streams nutzen. Also da gibt es verschiedene Anwendungsfälle. Welche Anwendungsfälle hast du schon so gesehen?",
      "start": 1915096,
      "end": 2064074,
      "confidence": 0.8059517766497464,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ja, für mich ist Redis sowieso nur ein Cache.",
      "start": 2064665,
      "end": 2066726,
      "confidence": 0.23377777777777778,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Bedeutet das für dich, Redis ist keine Datenbank?",
      "start": 2066746,
      "end": 2069068,
      "confidence": 0.721875,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ja, kommt drauf an, wie du Datenbank definierst. Wie definierst du Datenbank?",
      "start": 2069108,
      "end": 2072330,
      "confidence": 0.7479166666666667,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ich habe keinen Doktor in Datenbanken. Also wie definiert der Doktor der Datenbanken denn das Wort Datenbanken?",
      "start": 2072350,
      "end": 2078654,
      "confidence": 0.7909999999999998,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ja, ich habe da eine sehr unwissenschaftliche Definition. Für mich ist es eine Datenbank. Ich speichere irgendwo was rein, kann dem vertrauen, dass es da drin liegt und kann es auch wieder rausholen.",
      "start": 2078674,
      "end": 2086159,
      "confidence": 0.6427272727272727,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Redis mit Append-Only-File ist dann also eine Datenbank?",
      "start": 2086839,
      "end": 2089741,
      "confidence": 0.71025,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ja, keine sichere, aber eine Datenbank, ja.",
      "start": 2090400,
      "end": 2092663,
      "confidence": 0.7101428571428572,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Als Meinungsverstärker habe ich mir nochmal die Definition von Wikipedia rausgeholt. Eine Datenbank ist ein System zur elektronischen Datenverwaltung. Die wesentliche Aufgabe einer Datenbank ist es, große Datenmengen effizient, widerspruchsfrei und dauerhaft zu speichern und benötigte Teilmengen in unterschiedlichen bedarfsgerechten Darstellungsformen für Benutzer- und Anwendungsprogramme bereitzustellen. Über den zweiten Teil in unterschiedlichen bedarfsgerechten Darstellungsformen bereitzustellen, Das ist diskutierbar jetzt für Redis, weil du hast ja keine Quiri-Sprache, sowas wie SQL.",
      "start": 2093067,
      "end": 2128357,
      "confidence": 0.8319857142857142,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ja, und auch der andere Teil, dauerhaft zu speichern, widerspruchsfrei, das zielt halt auf die ganzen Transaktionen ab, dass du ACID-Garantien hast. Und solche Dinge hast du natürlich mit Redis nur bedingt, beziehungsweise, wie gesagt, du kannst halt nicht hundertprozentige Garantie geben, wie so eine ACID-Property natürlich von einer relationalen Datenbank dir geben kann.",
      "start": 2128377,
      "end": 2147942,
      "confidence": 0.7780370370370371,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ja, das ist aber dann jetzt kein Problem von Redis, sondern von jeder NoSQL-Datenbank.",
      "start": 2148242,
      "end": 2151983,
      "confidence": 0.7084285714285714,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Es gibt auch NoSQL mit Transaktionen, aber eher wenige. Und das stimmt schon, du hast natürlich die ganzen Probleme in anderen Datenbanksystemen genauso.",
      "start": 2152724,
      "end": 2161353,
      "confidence": 0.8423478260869566,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Also ist Redis jetzt eine halbe Datenbank, oder?",
      "start": 2161393,
      "end": 2163836,
      "confidence": 0.532875,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ja, so Datenbankisch.",
      "start": 2163876,
      "end": 2165578,
      "confidence": 0.7763333333333332,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Datenbankisch, okay. Lasse ich mich drauf ein.",
      "start": 2165618,
      "end": 2168860,
      "confidence": 0.3301428571428571,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Aber jetzt bist du ja als echter Fanboy nicht nur ein großer Fanboy von Redis, sondern auch ein großer Fanboy vom Core-Entwickler oder dem Erfinder von Redis. Und ihr glaubt gar nicht, ich habe von Andi schon so oft diesen Namen gehört, dass sogar ich mittlerweile diesen Typen kenne, obwohl ich noch nie mit Redis gearbeitet habe so richtig und auch noch nie von diesem Typen irgendwas im Detail mitbekommen hab sondern nur weil andi weiß dass dieser salvadore einfach der größte king ever is andi warum ich glaube die.",
      "start": 2168900,
      "end": 2196802,
      "confidence": 0.8249333333333339,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Apple jünger die huldigen auf steve jobs oder als größten innovator und so weiter.",
      "start": 2196842,
      "end": 2201587,
      "confidence": 0.8009285714285715,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Oder ja nicht nur die apple jünger wahrscheinlich aber vor allem die und die readys jünger und jüngerinnen, Verehren Salvatore Sanfilippo, so heißt der gute Kerl.",
      "start": 2201627,
      "end": 2214760,
      "confidence": 0.7721538461538462,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Könnte man so sagen. Also Salvatore Sanfilippo, Spitzname Antires, ist einer der wenigen Personen, die konstant positiv auf Hacker-News wegkommen.",
      "start": 2214780,
      "end": 2224387,
      "confidence": 0.8663500000000001,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Und das muss man mal schaffen.",
      "start": 2225208,
      "end": 2226188,
      "confidence": 0.7066666666666667,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Also, die Hacker-News-Audienz ist immer sehr, sehr kritisch und findet überall Nachteile. Aber er hat halt mal was auf den Tisch gelegt mit Redis. Und zwar ist AntiRaz der ursprüngliche Autor von Redis und hat das Projekt eigentlich ähnlich wie Guido van Rossum mit Python oder Linus Torvalds mit Linux sehr, sehr lange als ... One-Man-Show. Als BDFL ... BD was? Benevolent Dictator for Life. So heißt es ja, wenn eine Person immer noch unglaublich starke Influenz auf ein Open-Source-Projekt hat. Er hat auf jeden Fall das Projekt super lange getrieben und ist dadurch natürlich auch sehr bekannt geworden als ein sehr, sehr guter C-Programmierer. Denn viele Leute sagen, C muss man nicht mehr lernen und so weiter. Viel zu viele Fehler und C ist super unlesbar. Öffnet mal den Redis-Source-Code. Das ist für mich so ein Beweis, dass man auch lesbaren C-Code schreiben kann.",
      "start": 2226468,
      "end": 2283324,
      "confidence": 0.8182482758620688,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Außerdem mein z ist super man kann sich man kann sich in keiner anderen sprache so schön selber ins knie schießen das ist wunderbar.",
      "start": 2283764,
      "end": 2290847,
      "confidence": 0.7676249999999999,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Das ist nicht falsch das ist richtig wie dem auch sei er wurde dafür bekannt für seine sehr sehr guten implementierungen aber auch für sehr sehr gut durchdachte designs und Gute Verschriftlichung dieser Konzepte. Das bedeutet, immer wenn er ein neues, großes Feature in Redis implementiert hat, hat er so eine Art riesen Design-Dokument dafür geschrieben. Alle Trade-Offs. Was sind die Nachteile? Was sind die Vorteile? Wie könnte man das implementieren? Warum ist die andere Implementierung nicht so gut? Und das war immer super interessant zu lesen. Also wer sich ein bisschen mit Software-Design auseinandersetzen möchte, und damit meine ich jetzt gar nicht große Software-Architekturen, sondern wie verschriftlicht man eigentlich eine Implementierung von einem Algorithmus in einem vorhandenen System, der sollte sich die Design-Papers mal von Salvatore Sanfilippo ansehen. Entweder auf seinem Blog antires.com oder teilweise sogar noch in der Redis-Dokumentation.",
      "start": 2290887,
      "end": 2340900,
      "confidence": 0.8221489361702126,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Und der gute Kerl steht sowieso auf Schreiben, oder?",
      "start": 2341460,
      "end": 2345041,
      "confidence": 0.817111111111111,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Der gute Kerl steht sowieso auf Schreiben. Und zwar programmiert er aktuell nicht mehr. Er hat einfach aufgehört, vor zwei Jahren Code zu schreiben und hat angefangen, einen Fiction-Roman zu schreiben. Und der erste Fiction-Roman wurde jetzt vor kurzem auch veröffentlicht, Mitte letzten Jahres. heißt wo ich weiß gar nicht ob man das richtig ausgesprochen hat auf jeden fall geht es halt um artificial intelligence um das änderung des klimas und programmierer und die interaktion zwischen menschen und technologie.",
      "start": 2345081,
      "end": 2376950,
      "confidence": 0.8126708860759495,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Hast du es gelesen.",
      "start": 2376970,
      "end": 2378490,
      "confidence": 0.55775,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Nee es ist nicht auf englisch das buch ist in italienisch geschrieben und ich bin der italienischen sprache einfach nicht mächtig.",
      "start": 2378530,
      "end": 2384371,
      "confidence": 0.852857142857143,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Und da gibt es noch keine übersetzung ins englische.",
      "start": 2384531,
      "end": 2386692,
      "confidence": 0.6533333333333334,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Das weiß ich gerade gar nicht.",
      "start": 2386732,
      "end": 2387752,
      "confidence": 0.7943333333333333,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Was bist du für ein Fanboy? Aber kannst du dann schön in den Shownotes nachreichen.",
      "start": 2388392,
      "end": 2392656,
      "confidence": 0.6237333333333334,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Mach ich, mach ich.",
      "start": 2392676,
      "end": 2394298,
      "confidence": 0.4065,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Und warum hat dieser Salvatore damals Redis überhaupt erfunden? Wollte der auch ein Cash?",
      "start": 2394338,
      "end": 2400344,
      "confidence": 0.8059999999999999,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Da bin ich jetzt überfragt. Das weiß ich gar nicht, warum Redis einfach geschrieben wurde. Das wäre aber mal eine interessante Fragestellung. Also, liebe Hörerinnen und Hörer, falls ihr das wisst, lasst es uns mal wissen.",
      "start": 2400504,
      "end": 2410134,
      "confidence": 0.7260277777777779,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "So, jetzt haben wir so viele Vorteile schon besprochen. Gibt es irgendwelche Nachteile oder muss man irgendwo aufpassen, wenn man Redis verwendet? Vielleicht auch für Leute, die Redis schon verwenden. Du hast schon ein Beispiel erwähnt mit dem Snapshot, wenn man die Datenbank persistiert.",
      "start": 2410354,
      "end": 2424939,
      "confidence": 0.8161818181818183,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ein paar Fallstricke gibt es auch.",
      "start": 2424959,
      "end": 2426159,
      "confidence": 0.5103333333333334,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Jetzt sage ich auch schon Datenbank. Also wenn man Redis persistiert.",
      "start": 2426179,
      "end": 2429522,
      "confidence": 0.5507272727272727,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ein paar Fallstricke gibt es auf jeden Fall schon. Also auf der einen Seite natürlich die richtige Persistierung, beziehungsweise sofern ihr denn Datenpersistierung braucht. Wenn ihr es nämlich nicht braucht, schaltet es bitte ab. Könnte einen guten Performance Boost geben, falls ihr es nicht braucht. Aber die richtige Einstellung von RDB, Redis Database oder Append-Only-File, macht schon eine ganze Menge aus, abhängig von euren internen Daten und Persistenzgarantien. Es ist aber auch so, dass man sich über die Art und Weise, wie man seine Daten denn wirklich speichert, schon recht viel Gedanken machen muss, denn Ihr fragt jedes Value, also eine Liste, eine set, sorted set, geospatial und so weiter und so fort, auf Basis des Keys ab. Ihr müsst also in der Lage sein, den Key konstant irgendwie zur Hand zu haben. Sei es denn ein Hash von irgendwas oder ein statischer Key, wie eingeloggte User in der letzten Stunde oder oder oder.",
      "start": 2429562,
      "end": 2483908,
      "confidence": 0.8024025974025979,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Also ich kann da nicht mal schnell ne where clause schreiben, wo ich sage, where timestamp größer now minus 5 Tage oder so Sachen.",
      "start": 2484503,
      "end": 2491973,
      "confidence": 0.7135416666666669,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Das geht jetzt so nicht. Was du machen kannst ist, du kannst den Reddit Server fragen, gib mir mal alle Keys in deinem Server. Das Problem ist, da geht man.",
      "start": 2492013,
      "end": 2500785,
      "confidence": 0.7110333333333333,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Das können viele sein.",
      "start": 2500805,
      "end": 2501566,
      "confidence": 0.30974999999999997,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Da geht man natürlich wieder in die Liste, hat eine Zeitkomplexität von O von N. Umso größer der Redis-Server, umso mehr Keys sich da gespeichert, desto länger braucht diese Abfrage. Und ich hatte schon Redis-Server, da hat diese Abfrage sieben Sekunden gebraucht. Ich habe vorhin gesagt, Redis ist an vielen Teilen Single-Threaded, was sehr gut und einfach zu verstehen ist, was aber bei solchen Abfragen enorm komplex sein kann und zum Nachteil, Und der Keys-Befehl wird auch eigentlich als Debugging-Befehl angesehen. Deswegen, du musst halt immer in der Lage sein, direkten Zugriff auf den Key zu haben. Und somit musst du den Key kennen. Ein weiterer Fallstrick ist, dass du keine verschachtelten Datenstrukturen haben kannst. Du kannst jetzt also nicht zum Beispiel eine Liste haben und dann als Einträge in die Liste nochmal Hashmaps. Das geht jetzt nicht.",
      "start": 2502006,
      "end": 2551987,
      "confidence": 0.8243115942028986,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Also du kannst keine Verschachtelungen innerhalb von einem Value machen.",
      "start": 2552007,
      "end": 2555569,
      "confidence": 0.5864,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ganz genau, du kannst halt keine Datenstrukturen mixen und zusammenschmeißen. Es gibt halt nur Top-Level-Datenstrukturen und die Values innerhalb einer Datenstruktur sind dann halt meist irgendwie Zeichenketten. Aber du kannst jetzt nicht eine Hashmap haben und dann als Value von einem Eintrag in einer Hashmap nochmal eine Liste. Das geht jetzt nicht. Also Beispiel, so klassische JavaScript-Objekte, die hast du als JSON. Das, was du da repräsentieren kannst, kannst du jetzt nicht nativ in Redis abspeichern. Was du natürlich schon kannst, ist, du kannst das JSON serialisieren und dann als String abspeichern, das geht halt schon. Aber du kannst halt nicht diese Verschachtelung in JavaScript-Objekten nativ durch Datenstruktur in Redis abbilden.",
      "start": 2555909,
      "end": 2596197,
      "confidence": 0.7910000000000001,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Kann ich in Redis nur Daten speichern oder kann ich auch in irgendeiner Form Logik implementieren? Bei klassischen relationalen Datenbanken gibt es ja PLSQL oder solche Dinge oder Trigger oder kann auch Funktionen teilweise je nach Datenbank auch schreiben. Gibt es da irgendwas, wo ich Logik auslagern kann, damit ich irgendwas schneller machen kann?",
      "start": 2597001,
      "end": 2615856,
      "confidence": 0.8085740740740742,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Oh, Killerfrage, Killerfrage. Supported Redis Lua, Lua die Skript Sprache. Viele kennen Lua vielleicht aus den ersten Zeiten von World of Warcraft, dem Spiel. Weil da kann man nämlich auch eine ganze Menge Zeug skripten und das macht man alles mit Lua. Also wer ein bisschen so World of Warcraft Nerd war, der wird mit Lua bestimmt schon mal in Berührung gekommen sein.",
      "start": 2615916,
      "end": 2640990,
      "confidence": 0.803650793650794,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ist ziemlich out oder? War mal eigentlich sehr gehypt und war auch nie bekannt irgendwie extrem schnell zu sein, wenn ich mich da richtig so erinnere.",
      "start": 2641030,
      "end": 2647874,
      "confidence": 0.7913461538461539,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Nee, das ist richtig, aber ich glaube Lua ist eine Sprache, die schon sehr sehr lange am Start ist. Du kannst ja auch zum Beispiel Nginx, den Webserver, mit Lua pimpen und dann Lua Submodules fahren und Subthreads und solche Geschichten. Also es gibt schon sehr, sehr viele Tools draußen, die eine native Lua Scripting Funktionalität drin haben. Redis hat es zum Beispiel auch und was du damit machen kannst ist, du kannst zum Beispiel eigene Commands implementieren. Falls du irgendwas brauchst, wie zum Beispiel mit einem Redis-Befehl mehrere Keys updaten oder du implementierst dir irgendwelche Lua-Funktionen, die anhand des Mondstandes irgendwelche Keys updaten oder ähnliches. Also all das, was bei Redis nicht nativ supported wird, kannst du mit Lua nachskripten. Und das Tolle ist, du kannst es zu Runtime injecten und zu Runtime auch ändern. Das bedeutet, ohne den Server irgendwie neu zu starten, kannst du da deine Funktion editieren.",
      "start": 2648514,
      "end": 2702515,
      "confidence": 0.7843774834437082,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ich bin schon gespannt, wenn du dann uns das Lua-Skript nachreichst, wo du den Mondstand abfragst. Da bin ich mal gespannt, wie du auf die Daten da zugreifst.",
      "start": 2702795,
      "end": 2712122,
      "confidence": 0.8061071428571429,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Wieso? Ich kann doch, wenn ich Redis abfeuere, kann ich doch in Lua ein API-Request an die Wetter-API machen?",
      "start": 2712163,
      "end": 2718047,
      "confidence": 0.7974210526315789,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Klingt schon wieder sehr nach Overengineering. Wahrscheinlich kann das irgendein Datumsbefehl auch ausspucken. Aber okay, ich bin auch kein Spezialist in den Mondphasen, muss ich zugeben. Gibt's sonst irgendwie Erweiterungsmöglichkeiten?",
      "start": 2718067,
      "end": 2729355,
      "confidence": 0.7159999999999999,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ich hatte grad erwähnt, dass ich ein mega Fan von Redis bin, weil das bei vielen Teilen recht einfach ist. Single-threaded, einfach zu verstehen. Vor einiger Zeit wurde eine Module-API implementiert, womit du in die vorhandenen Datenstrukturen, in die vorhandenen supporteten Datenstrukturen neue Datenstrukturen implementieren kannst. Es gibt jetzt eine Module-API, Redis Module schreiben, die werden in der Regel in C geschrieben. Kannst du natürlich dann auch mit in Go oder in Rust schreiben oder ähnliches durch diese Sprachbrücken. Auf jeden Fall bietet die Module API dir auch die Möglichkeit, neue Datentypen zu implementieren. Zum Beispiel gibt es Module, die implementieren Funktionalitäten für einen nativen JSON-Data-Type. Es gibt ein Search-Modul, das erlaubt dir Full-Text-Search. Ein Modul, was speziell für Datenstrukturen für Time-Series-Databases ausgelegt ist. Graph-Datenbanken. Gibt eigentlich alles, was Leute schon implementiert haben.",
      "start": 2729495,
      "end": 2785511,
      "confidence": 0.8173233082706771,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Hast du mal schon so ein Modul verwendet?",
      "start": 2785685,
      "end": 2787366,
      "confidence": 0.6252500000000001,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ich habe noch keins dieser Module verwendet, nein.",
      "start": 2787406,
      "end": 2789206,
      "confidence": 0.5682499999999999,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Weil erfahrungsgemäß, also wie gesagt, auch aus der MySQL-Welt wieder, diese Module haben sich irgendwie nie durchgesetzt, waren auch nie so stabil. Von der Datenbank erwartet man sich ja auch extreme Stabilität immer. Also falls jemand schon mal mit so Modulen gearbeitet hat, würde mich wirklich interessieren, wie stabil die auch sind, wie gut die funktionieren. Weil das ist normal immer dieses Problem, wenn es um Datenbanken geht. Der Kern ist immer sehr stabil und die Module sind dann so meh.",
      "start": 2789246,
      "end": 2812955,
      "confidence": 0.8175679012345677,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ich sehe es ähnlich wie du. Wer schon mal mit PHP und mit PHP-Extensions gearbeitet hat, das ist immer so ein Hack-Mac und dann hat man ab und zu mal auch Segmentation-Faults, also irgendwie invalide Memory-Zugriffe oder oder oder. Und auch wenn man die Sprache oder den Redis-Server dann mal updaten möchte, dann musst du auch immer gucken, okay, ist das Modul, was du verwendest, wirklich kompatibel mit der neuen Version? Und in der Regel hängen die halt hinten dran und dann kann man zum Beispiel nicht auf die neueste Version updaten, aber obwohl man da ein Feature braucht, Also, das ist unter anderem auch ein Grund, warum ich bisher noch kein Modul verwendet habe. Nicht, weil ich nicht denke, dass die Funktionalität super wäre, doch falls ich wirklich den Bedarf von einer Time-Series-Database habe oder von einer Time-Series-Datenstruktur, dann überlege ich mir halt, ob ich mir nicht eine Time-Series-Datenbank daneben stelle. Dasselbe für eine Graph-Datenbank. Oder muss ich wirklich ein JSON abspeichern? so brauche ich das ganze jason und brauche ich das jason in dem sub key abfragbar oder speicherst du es einfach.",
      "start": 2813415,
      "end": 2870219,
      "confidence": 0.7696684782608691,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Als string genau immer geht ja.",
      "start": 2870239,
      "end": 2872920,
      "confidence": 0.6503333333333332,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Oder als search da gucke ich auch ob ich mir nicht eine search engine wie ein elastic search und opensource dahin stelle oder oder oder.",
      "start": 2872980,
      "end": 2880963,
      "confidence": 0.6829999999999999,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Jetzt hast du PHP schon erwähnt und du hast ja am Anfang erwähnt, dass so ein klassischer Use Case eigentlich die Session-Verwaltung ist, also das Session-Caching. Und jeder, der PHP verwendet, weiß ja auch, dass die Sessions normalerweise einfach in Dateien gespeichert werden. Aber sobald man PHP verteilt, also über mehrere Nodes hinweg, braucht man irgendwo einen zentralen Session-Speicher. Und da würde sich natürlich Redis anbieten. Wird, glaube ich, auch oft verwendet, wenn ich das richtig verstanden habe. Wie kann ich denn jetzt Redis aus PHP ansprechen? Brauche ich da einen eigenen Client? Wie kompliziert ist das jetzt ganz konkret, wenn ich da jetzt einen Redis-Server hochfahre? Wie kann ich denn mit dem kommunizieren?",
      "start": 2881163,
      "end": 2915985,
      "confidence": 0.7323947368421052,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Das ist sogar PHP-unabhängig. Prinzipiell gibt es für jede Programmiersprache Client-APIs, so wie auch einen MySQL-Connector oder eine MySQL-Library gibt es dann auch für Redis eine Library. Da baust du ebenfalls eine Connection auf, ähnlich wie bei MySQL oder Postgre oder ähnliches. Und dann kannst du ganz normal mit Textbefehlen mit Redis kommunizieren, weil das Protokoll.",
      "start": 2916305,
      "end": 2934193,
      "confidence": 0.7236071428571428,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Aber ist das im Hintergrund irgendwie eine HTTP-API, die man ganz simpel anspricht, oder ist das schon irgendein binäres Protokoll, wo man dann wirklich auch vielleicht einen C-Client oder so braucht, wie jetzt bei MySQL?",
      "start": 2934593,
      "end": 2946079,
      "confidence": 0.7568285714285713,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Das Protokoll selbst ist, so viel ich weiß, ein Klartext-Protokoll, was du aber auch binär übertragen kannst. Das Einfachste ist, was du machen kannst, du startest dir einen Redis-Server und connectest via Telnet drauf und dann kannst du eigentlich schon mal loslegen. Also es ist nichts Kompliziertes. Ich würde mich aus dem Fenster lehnen und würde sagen, das HTTP-Protokoll ist komplexer als das Redis-Protokoll.",
      "start": 2946099,
      "end": 2965471,
      "confidence": 0.68225,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Also du kannst im Prinzip dann auch den Client komplett in PHP nativ schreiben und brauchst jetzt keine externe CE, Bibliothek oder ähnliche Sachen.",
      "start": 2965511,
      "end": 2972936,
      "confidence": 0.7405833333333334,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Genau, weil es ist eigentlich nur, du öffnest einen Socket und sendest ein paar Zeichenketten rüber, die wirklich nicht komplex sind. Es ist natürlich schon bevorzugt, wenn du jetzt nicht gerade Interesse hast, das Redis-Protokoll nachzuimplementieren, würde ich schon empfehlen, nutze eine dieser Redis-Libraries. Aber in der Regel sind die Libraries dann nativ in der Sprache implementiert und.",
      "start": 2972976,
      "end": 2992457,
      "confidence": 0.7832241379310345,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Nicht in C. Gut, jetzt habe ich da meinen Redis-Server. Wenn ich in einer Firma arbeite, gibt es ja oft diese Anforderungen, von oben gibt es da Support, das ist ja wieder Open Source. Wie verankert ist das Ganze? Bekomme ich da irgendwo Support, wenn ich einen Problemfall habe? Wie ist da die Tools-Landschaft rundherum? Also sprechen wir da jetzt von irgendeinem kleinen Open-Source-Projekt von dem guten Salvatore oder ist das eine ganze Industrie?",
      "start": 2992497,
      "end": 3016735,
      "confidence": 0.6832432432432434,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Also Redis würde ich inzwischen nicht mehr als kleines Open-Source-Projekt bezeichnen. Ich denke, das ist schon einer der meistgenutzten Datenstrukturen-Server auf der ganzen Welt. Ist aber auch so, dass sich mit der Zeit natürlich durch die Popularität des Redis-Servers dann natürlich auch ein Business herumgebaut hat. Primär eine Firma, die bis vor kurzem noch Redis Labs hieß. Inzwischen heißt diese Firma nicht mehr Redis Labs, sondern heißt wirklich Redis. Das war eine Firma, die hat ganz am Anfang als Hosted-Redis-Provider angefangen. Mitte 2015, also vor acht Jahren, haben sie es irgendwie geschafft, dass der Lead Developer, also Salvatore Sanfilippo, also Antires, für diese Firma arbeitet. Danach haben sie sukzessive mehr und mehr Core-Entwickler eingestellt, die wirklich am Redis-Core arbeiten, wo in der Regel Salvatore Sanfilippo am Anfang schon sehr stark die Hand drauf hatte. Und dadurch bekam Redis Labs dann den offiziellen Sponsor von dem Open Source Projekt und dann hat meines Erachtens nach so ein bisschen das Corporate Thinking angefangen. Da hat so ein bisschen die kleinste Violine der Welt die Regierung übernommen, nämlich das Geld. Und dann ging es so ein bisschen rund. Okay, irgendwie haben sie dann so ein Enterprise Deck gemacht und dann haben sie Redis Modules implementiert und dann haben sie so Online Marketplace gebaut, wo du Module zertifizieren lassen kannst und auch kaufen kannst. Und dann fing es an mit den Lizenzänderungen. Dann haben sie nämlich alle Redis-Module von AGPL auf die Lizenz von Apache 2 mit einer Common Clause geändert und später dann auf eine eigene Lizenz, auf die Redis-Source-Available-Lizenz, halt um irgendwie ein bisschen die Konkurrenz in Schach zu halten. Also da merkt man schon, okay, da will jemand wirklich ein paar Dollar verdienen. Natürlich hängen da hinten auch Venture Capital Leute dran, blabliblub. Und da muss ich zugeben, man hat schon den Einfluss von Redis, der Firma, also Redis Labs, auf das Projekt gemerkt. Die Schönheit des Open Source Projektes ist in meiner Ansicht nach, die ist immer noch da, aber die hat ein paar Knick, aber die hat ein Knick bekommen. Mehr und mehr Concurrency hat in Redis Einfluss erhalten. Redis-Modules. Die Konzepte, die großen Konzepte, die jetzt implementiert werden, hab ich das Gefühl, nicht mehr ganz genau so durchdacht, wie es mal vorher war. Salvatore, also Antirest, hat sich sehr viel Zeit genommen, die Konzepte niederzuschreiben, ein paar Wochen drüber nachzudenken. Und nicht klack, klack, klack, weil irgendein Kunde danach geschrien hat. Und das find ich jetzt schade, aber ... Ja gut, die Welt ist halt nicht immer so, wie ich sie haben möchte, was?",
      "start": 3017155,
      "end": 3173112,
      "confidence": 0.7934929577464791,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ich habe auch gerade in der Zwischenzeit mal die Datenbankindizes gecheckt, also die Rankings, wie beliebt Datenbanken sind. Als erster Dämpfer schon mal für mich, Redis kommt in diesen Datenbanklisten vor, das heißt scheinbar sehen andere Leute das auch als Datenbank an. Die B-Engines.com ist so, glaube ich, eine der bekanntesten. Die listen Redis auf Platz 6. Andere Indizes, die ich gefunden habe, da schwirrt Redis so auf Platz zwischen 8, ja, 9, so in der Gegend herum. Also es ist doch aus einer beliebten Datenbank und wenn man sich so anschaut rundherum, da schwirren so DB2 von IBM, Elasticsearch, MongoDB, Postgres klarerweise, MySQL, Oracle, Microsoft SQL Server, SQLite mittlerweile auch und Microsoft Access unter den Top 10. Also es ist schon ein Data Storage, der unter den Top 10 in allen Rankings eigentlich liegt und demnach natürlich auch einen großen Stellenwert hat, muss man schon sagen, ja. Und gibt es jetzt auch, wie lange schon?",
      "start": 3173172,
      "end": 3232779,
      "confidence": 0.794230769230769,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Da muss ich jetzt wirklich nachgucken.",
      "start": 3232819,
      "end": 3234660,
      "confidence": 0.39200000000000007,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Tu mal was für deine Episode und dein Geld.",
      "start": 3235643,
      "end": 3237924,
      "confidence": 0.6453333333333334,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Meine Güte. Für meine Episode. Du hast dir die gewünscht.",
      "start": 3237964,
      "end": 3243648,
      "confidence": 0.5984,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Jetzt fang ich an zu googeln. Wenn ich schneller bin, bekomme ich ein Bier. Du lachst jetzt, ich meine das ernst. Ja. 2009, 10. Mai, Initial Release.",
      "start": 3243768,
      "end": 3251893,
      "confidence": 0.520962962962963,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Moment, muss ich kontrollieren. Wann? 2009.",
      "start": 3251933,
      "end": 3254264,
      "confidence": 0.8038333333333334,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Er ist korrekt. Natürlich, ich habe immer recht.",
      "start": 3254274,
      "end": 3257416,
      "confidence": 0.6863750000000001,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "22. März 2009, First Comet.",
      "start": 3257426,
      "end": 3257837,
      "confidence": 0.26080000000000003,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Okay, dann darfst du jetzt nochmal die Frage beantworten.",
      "start": 3260705,
      "end": 3263028,
      "confidence": 0.46766666666666673,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ich hab grad, Redis selbst gibt's anscheinend seit 2009, ich hab grad mal das Git-Repository geklont und hab mal ein Git-Log minus minus reverse gemacht und der erste Comet war am 22. März 2009. An einem Sonntag. Dieser Mann hat es wohl wirklich am Wochenende gestartet zu hacken. War anscheinend ein Zeitprojekter.",
      "start": 3263068,
      "end": 3283160,
      "confidence": 0.7829423076923079,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Da sieht man wieder deine Liebe für Overengineering. Du schaust da im Git-Repo nach. Ich gehe einfach auf die Wikipedia-Seite von Redis. Da steht Initial Release 10. Mai 2009. Vor 13 Jahren.",
      "start": 3283200,
      "end": 3294205,
      "confidence": 0.7284375000000001,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ist Wikipedia als Quelle inzwischen in der Akademik angekommen? Darf man das benutzen?",
      "start": 3294246,
      "end": 3298908,
      "confidence": 0.7175384615384617,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Man darf es immer benutzen, aber man darf es nur nicht als Quelle angeben.",
      "start": 3299308,
      "end": 3302070,
      "confidence": 0.6695714285714285,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "So, und wieso tun wir das jetzt hier im Podcast?",
      "start": 3302090,
      "end": 3304232,
      "confidence": 0.7908000000000001,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ja, du hast es ja eh double gecheckt. Dafür haben wir dich hier.",
      "start": 3304252,
      "end": 3307134,
      "confidence": 0.6753076923076922,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Verstehe, verstehe, okay. Lass ich so durchgehen.",
      "start": 3307154,
      "end": 3309195,
      "confidence": 0.5302857142857142,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Und ich habe jetzt auch gelernt, dass man, was? Git reverse, double reverse, was, wie war dieser Befehl?",
      "start": 3309455,
      "end": 3314059,
      "confidence": 0.6303333333333333,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Git log minus minus reverse. Schmeißt dir das Git log. Also Git log gibt dir in der Regel den letzten Comet ganz oben. Und wenn du Git log minus minus reverse rausspuckst, dreht der das ganze Ding um. Und somit hast du den ältesten Comet oben.",
      "start": 3314079,
      "end": 3325947,
      "confidence": 0.6912826086956522,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ja, wieder was gelernt. Jetzt waren wir gerade bei dem professionellen Support durch Redis Labs und das ist eine bekannte Datenbank, will ich nicht sagen, Datenstruktur, Datenspeicher, Server, egal. Wie schaut es denn mit dem ganzen professionellen Hosted-Angeboten aus? Cloud-Provider, kann ich das auf GCP, EWS einfach so irgendwo hochfahren, gemanagt?",
      "start": 3326541,
      "end": 3349426,
      "confidence": 0.7663137254901964,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Also sowas lassen die drei Hyperscaler Google Cloud, Amazon und Azure sich natürlich auch nicht entgehen. Die Antwort ist ja. Du kriegst dann einen gemanagten Redis bei GCP. Bei Google Cloud Platform heißt das Memorystore. Bei AWS heißt es ElastiCache und bei Azure heißt es Azure Cache for Redis. Da kannst du dir das ganz einfach nur zusammen klicken. Da muss man natürlich ein bisschen gucken, was du für eine Architektur möchtest, weil in der Regel haben die dieses klassische Leader-Follower-Prinzip. Ich bin mir gar nicht sicher, wer von den dreien wirklich ein Cluster anbietet, weil ein Cluster zu betreiben ist halt schon nochmal ein bisschen was anderes. Bei Redis Und du hörst es auch schon bei Azure im Namen. Deren primary use case ist dann Azure Cache. Ja, also als Cache use case. Da muss man auch ein bisschen gucken, bieten die alle irgendwie eine Persistenz an mit Redis Database, also RDB oder Append-Only-File. Aber das sind alles immer Details, die man sich sowieso mal reinziehen muss, wenn du einer dieser Hyperscale-Angebote wahrnimmst. Aber prinzipiell, wenn du Redis als Cache nimmst, nutze das. Das ist kein schlechtes Angebot. Zu den Preisen kann ich da nichts sagen, aber Redis selbst ist jetzt auch nicht superschwierig zu betreiben, weil es eine sehr gut geschriebene, sehr gut konfigurierte Software ist.",
      "start": 3349486,
      "end": 3420567,
      "confidence": 0.7541559633027521,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Fällt dir was auf bei den drei Namen von GCP, Amazon und Azure?",
      "start": 3421047,
      "end": 3425330,
      "confidence": 0.736230769230769,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ja, zweimal Cache und einmal Memory.",
      "start": 3425350,
      "end": 3427552,
      "confidence": 0.5178333333333334,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Da kommt nirgends Datenbank vor in diesen Namen. Die haben das verstanden.",
      "start": 3427572,
      "end": 3431735,
      "confidence": 0.8041666666666666,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Weiß ich nicht, weil Amazon zum Beispiel lässt die Cache, Da kannst du wählen zwischen Redis und Memcached. Und Memcached ist ganz klar keine Datenbank. Und bei Memorystore und GCP Memorystore kannst du auch Memcached oder Redis wählen. Also, deren Usecase ist halt eine ganz andere Geschichte. Und ich glaube, die sind halt so früh gestartet damit, ja, vielleicht war es damals wirklich noch nicht so die Datenbank, die es heute ist. Ich denke, aber ich würde mich darauf einlassen, wenn du sagst, okay, du hast jetzt hier jemanden, der wirklich PostGrid programmiert oder eine Oracle oder was weiß der Geile. Logisch, die Leute werden ganz klar sagen, Redis, geh mal weg mit deinem Kinderspielzeug. Geh mal aus deinem Sandkasten da raus und nutz mal eine richtige Datenbank. Bei solchen Leuten würde ich sagen, stimmt, ihr habt recht, weil ihr bewegt euch in Sphären. Ihr habt ein anderes Verständnis als Datenbanken. Für mich als ganz einfacher, simpler Programmierer, Ich möchte mit dem Ding kommunizieren und Daten abspeichern. Das ist für mich eine Datenbank. Und das macht Redis eigentlich ganz gut, glaub ich. Also von meinem dummen Verständnis an der Datenbank, Redis ist dann eine Datenbank. Und GCP, Amazon und Azure, ich glaube, da sind wir uns einig, die overengineeren ja auch, oder?",
      "start": 3431755,
      "end": 3500867,
      "confidence": 0.7580283018867916,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Was hat das mit overengineering zu tun?",
      "start": 3500907,
      "end": 3502909,
      "confidence": 0.5862857142857143,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Die würden zum Beispiel Redis ja nie als Datenbank nehmen. Wenn ich sowas sehe wie BigQuery und Spanner, irgendwie eine Datenbank, die weltweit in so Billiseconds irgendwelche Daten speichern muss. Ich glaube, ich würde mich aus dem Fenster lehnen und sagen, die haben eine andere Antwort.",
      "start": 3502949,
      "end": 3517563,
      "confidence": 0.7170652173913045,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ich glaube, wir können das schon unter Datenbank lassen, aber die Konsistenzgarantien werden nicht gegeben. Aber um ehrlich zu sein, du brauchst sie in 99% der Fällen wahrscheinlich auch einfach nicht.",
      "start": 3518568,
      "end": 3529678,
      "confidence": 0.8070967741935484,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Wie sei denn, du bist eine Bank.",
      "start": 3529738,
      "end": 3531620,
      "confidence": 0.3661428571428571,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Und ganz abgesehen davon würde mich mal interessieren, wie viele Leute in MySQL wirklich Transaktionen überhaupt verwenden. Ich glaube eigentlich, dass das auch irgendwo im 5% Bereich oder so liegt. Ich glaube, das ist so ähnlich, wie früher hat man bei Word immer behauptet, der klassische User, der verwendet so drei bis vier Prozent von dem Funktionsumfang von Word oder Excel. Und ich glaube, so ähnlich ist es oft bei Datenbanken auch.",
      "start": 3531660,
      "end": 3554753,
      "confidence": 0.7858333333333335,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ich hatte gedacht, du sagst jetzt, der klassische Word-User sagt immer, Clippy nervt und hat es nie verwendet. Da würde ich eher sagen, super viele Leute haben Clippy verwendet, haben sich aber nie getraut, es zuzugeben. Und ob Leute nur drei bis vier Prozent der Excel-Funktionalität heutzutage nutzen, da würde ich mal ganz sicher sagen, die benutzen deutlich weniger.",
      "start": 3554773,
      "end": 3573660,
      "confidence": 0.8185593220338979,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ja, nur weil Clippy nicht mehr da ist zum Helfen. Aber bevor wir jetzt alle überfordern, weil niemand mehr so alt ist, dass er überhaupt Clippy kennt, beenden wir mal die ganze Datenbank-Diskussion, glaube ich.",
      "start": 3573680,
      "end": 3583963,
      "confidence": 0.7573428571428571,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Schade, ich hatte gedacht, wir sprechen jetzt darüber, wie man Clippy in VBA nachprogrammiert. Aber nein, kommen wir dem Wunsch von Wolfgang mal nach. Das war ein kleiner Einstieg in Redis, meine bisher immer noch favorisierte Datenbank oder Data Structure Server. Wer sehr viel lernen möchte über Implementierung von Algorithmen, C-Programmierung, Verschriftlichung von Programmierkonzepten, ich denke für diese Person ist Redis ein gutes Projekt, da mal ein bisschen tiefer einzusteigen. Wir haben aber auch bei weitem nicht alles erwähnt. Wir haben nicht über Redis-Streams gesprochen, nicht über Redis-Cluster, nicht um das Tooling drumherum gesprochen wie Trampoxy, Redis-Sentinel, High-Availability und so weiter und so fort. Vielleicht machen wir dazu irgendwann mal eine Episode. Ich hoffe auf jeden Fall, ich konnte ein bisschen meine Liebe und Passion für Redis mit euch teilen. Und ich hoffe, ein paar Leuten wurde auch etwas warm ums Herz. Mir auf jeden Fall.",
      "start": 3583983,
      "end": 3639180,
      "confidence": 0.8142260273972606,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Bei dieser Romantik weiß ich gar nicht, wie ich weitermachen soll. Der Aufruf, wer paar negative Details zu Redis hat oder vielleicht auch negative Erfahrungen oder auch Nachteile, bitte gerne nur her damit. Wir werden die auch dementsprechend verteilen. Am besten auf Twitter, in die Kiosk wie immer oder bei E-Mail stetig at engineeringkiosk.de.",
      "start": 3639200,
      "end": 3658382,
      "confidence": 0.7523148148148145,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Und falls ihr zufällig auf irgendeiner Podcast-Plattform seid, Spotify, Google Podcasts, Apple Podcasts oder ähnliches, bewertet uns doch mal und lasst uns gegebenenfalls einen Kommentar da. Zum Beispiel, das kann man auf Apple ganz gut. Und uns würde sehr freuen, wenn ihr mal auf Folgen beziehungsweise Abonnieren drückt. Das hilft uns ungemein.",
      "start": 3658753,
      "end": 3674820,
      "confidence": 0.7627499999999999,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Moment, musst du nicht noch irgendwie sagen, dass diese Glocke da, die Glocke ist doch auch immer wichtig, Kavikati. Ich verwende diese Plattformen ja nicht, ich bin ja Open Source User.",
      "start": 3675240,
      "end": 3682704,
      "confidence": 0.6575161290322582,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ne, Glocke ist, glaube ich, auf YouTube.",
      "start": 3682764,
      "end": 3684485,
      "confidence": 0.6027142857142858,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ah, die Glocke gibt es auf Spotify meines Wissens auch.",
      "start": 3684605,
      "end": 3687426,
      "confidence": 0.5658000000000001,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ja, wenn es eine Spotify-Glocke gibt, dann drückt auch die Glocke oder so. Das muss ich jetzt auch mal nachgucken, weiß ich jetzt nicht. Uns würde auf jeden Fall eine Bewertung freuen oder wenn ihr uns folgen würdet. Das hilft uns sehr. Wir sehen das alles in den Statistiken und da haben wir natürlich immer einen Motivationsboost, was uns auch in Phasen, wo wir mal nicht so gut drauf sind, dann immer sehr hilft.",
      "start": 3687763,
      "end": 3707112,
      "confidence": 0.7428108108108109,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Obwohl man sich das gar nicht vorstellen kann, dass der Andi einmal schlecht gelaunt ist.",
      "start": 3707152,
      "end": 3710074,
      "confidence": 0.7058666666666666,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Kommt ab und zu auch vor. Ich bin auch nur ein Mensch. Wie dem auch sei, das war's von uns. Wir wünschen euch einen schönen Tag.",
      "start": 3710114,
      "end": 3716317,
      "confidence": 0.7266923076923077,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Bis zum nächsten Mal und eine schöne Woche. Tschau. Tschö.",
      "start": 3716999,
      "end": 3719716,
      "confidence": 0.5549000000000001,
      "channel": null,
      "speaker": "B"
    }
  ],
  "confidence": 0.773886072344064,
  "audio_duration": 3727.0,
  "webhook_status_code": null,
  "webhook_auth": false,
  "summary": null,
  "auto_highlights_result": null,
  "content_safety_labels": null,
  "chapters": null,
  "sentiment_analysis_results": null,
  "entities": null
}
