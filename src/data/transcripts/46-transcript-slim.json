{
  "language_code": "de",
  "audio_url": "https://audio1.redcircle.com/episodes/36ab2e0b-862b-4444-9863-29f51116fbab/stream.mp3",
  "punctuate": true,
  "format_text": true,
  "dual_channel": false,
  "webhook_url": null,
  "webhook_auth_header_name": null,
  "webhook_auth_header_value": null,
  "audio_start_from": null,
  "audio_end_at": null,
  "word_boost": [],
  "boost_param": null,
  "filter_profanity": false,
  "redact_pii": false,
  "redact_pii_audio": false,
  "redact_pii_policies": null,
  "redact_pii_sub": null,
  "speaker_labels": true,
  "speakers_expected": 2,
  "content_safety": false,
  "content_safety_confidence": null,
  "iab_categories": false,
  "custom_spelling": null,
  "disfluencies": false,
  "sentiment_analysis": false,
  "auto_chapters": false,
  "entity_detection": false,
  "summarization": false,
  "summary_model": null,
  "summary_type": null,
  "auto_highlights": false,
  "language_detection": false,
  "speech_threshold": null,
  "id": "62xhyugp26-31eb-4d67-91ee-a74e5dc087dd",
  "status": "completed",
  "error": null,
  "utterances": [
    {
      "text": "Docker und Container, die Buzzwords der letzten Dekade. Und wo es um Buzzwords geht, geht es auch um ein sich schnell entwickelndes Ökosystem. Grund genug, mal zwei Schritte zurückzugehen und sich zu fragen, was ist eigentlich das Warum hinter Docker und wie lautet eigentlich das ursprüngliche Problemstatement von Solomon Hykes und seinem Team? Um diese zwei Fragen geht es in dieser Episode. Natürlich bleiben andere Buzzwords wie Immutability, idempotenz Copy-on-Write, LXC, LibContainer und Chainshoot nicht unerwähnt. Wenn du dir nun denkst, ich nutze Docker jeden Tag, ich weiß doch schon alles, gib uns mal ne Chance. Es wird kein So-nutzt-du-Docker-Audio-Tutorial, sondern eher um den Gedanken dahinter. Vielleicht nimmst du das ein oder andere Quäntchenwissen doch noch mit. Und somit viel Spaß. Wolfgang, soviel ich weiß, bist du ein sehr belesener Mann und hast auch schon die Welt bereist. Zumindest hattest du das mal vor, bis dieses Corona kam. Meines Wissens nach hast du deinen Vollzeitjob gekündigt und ich glaube offiziell nennt man das ein Cervetical. Und dann hast du begonnen, die Welt zu bereisen bzw. war das dein Ziel? Ist das korrekt?",
      "start": 4581,
      "end": 75625,
      "confidence": 0.8119010989010992,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Das klingt alles sehr hochgestochen, aber ich lasse es mal so durchgehen.",
      "start": 75665,
      "end": 79487,
      "confidence": 0.6697500000000001,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Kannst du mal ganz kurz die Länder aufzählen, in die du es geschafft hast in dieser Zeit?",
      "start": 79849,
      "end": 86091,
      "confidence": 0.7332941176470587,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Es waren gar nicht so viele, weil ich mir sehr Zeit gelassen habe, aber ich war zum Beispiel sechs Wochen in der Ukraine. War wirklich sehr spannend, super Land und jetzt im Nachhinein bin ich sehr froh, dass ich damals dort war und das Land gesehen habe.",
      "start": 86131,
      "end": 98874,
      "confidence": 0.7489574468085108,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Warst du auch in Deutschland unterwegs? Hast du dich auch mal ein bisschen tiefer mit Deutschland auseinandergesetzt?",
      "start": 98914,
      "end": 102875,
      "confidence": 0.6890000000000003,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ich war mal für unsere tolle Local Host Konferenz in Düsseldorf zwischendurch. Das muss reichen für Deutschland.",
      "start": 102915,
      "end": 109057,
      "confidence": 0.8123529411764705,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Und du warst ja auch schon ein paar Mal bei mir in Duisburg, richtig?",
      "start": 109477,
      "end": 112119,
      "confidence": 0.6857857142857143,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ja, wobei ich habe noch nie so dieses harte Duisburg im Kern kennengelernt. Du wohnst ja am Land, aber dieses Duisburg, von dem wir immer alle sprechen, das kenne ich nur vom Bahnhof, der mit irgendwelchen Tapes und Seilen geflickt ist seit 15 Jahren.",
      "start": 112159,
      "end": 125806,
      "confidence": 0.7325454545454545,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Wenn ich Duisburg sage, was ist das Erste, was dir in den Sinn kommt? Wofür Duisburg bekannt ist?",
      "start": 125846,
      "end": 132490,
      "confidence": 0.8551111111111112,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Duisburg ist für irgendwas bekannt. Duisburger Landschaftspark vielleicht. Der Landschaftspark, der ist in Duisburg, oder?",
      "start": 133110,
      "end": 139214,
      "confidence": 0.6811333333333331,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Der Landschaftspark Duisburg Nord ist in Duisburg, richtig.",
      "start": 139254,
      "end": 142356,
      "confidence": 0.7232500000000001,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Da war ich mal klettern. Da habe ich sogar den Gipfel bestiegen mit 30 Höhenmetern.",
      "start": 142396,
      "end": 146999,
      "confidence": 0.7576,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Hast du dich oben im Gipfelkreuz in das Buch eingetragen? Da gibt es doch immer so ein Buch, oder?",
      "start": 147039,
      "end": 150801,
      "confidence": 0.6297368421052632,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Keine Ahnung, ob es da ein Buch gab. Ein Foto habe ich auf jeden Fall.",
      "start": 150841,
      "end": 153483,
      "confidence": 0.5420666666666668,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Wie sieht denn dein geografisches Wissen bezüglich Wasserstraßen und Duisburg aus?",
      "start": 153523,
      "end": 157885,
      "confidence": 0.8191818181818181,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Wasserstraßen, meinst du jetzt in Rhein oder so?",
      "start": 157905,
      "end": 159847,
      "confidence": 0.53075,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ist zum Beispiel eine Wasserstraße.",
      "start": 159887,
      "end": 161107,
      "confidence": 0.8151999999999999,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ah, da gibt es noch mehr.",
      "start": 161387,
      "end": 162108,
      "confidence": 0.5486666666666666,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Okay, ich beleuchte dich mal ein bisschen. Und zwar ist die Stadt Duisburg für einen Weltrekord bekannt.",
      "start": 162469,
      "end": 168784,
      "confidence": 0.8395294117647057,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Es geht nicht um Umweltverschmutzung oder? Und höchste Werte oder so?",
      "start": 168824,
      "end": 171771,
      "confidence": 0.6498181818181819,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Es geht nicht um Umweltverschmutzung, es geht auch nicht um CO2-Werte. Es geht um den Binnenhafen. Und zwar besitzt Duisburg den größten Binnenhafen Europas. Und wenn man alle öffentlichen und privaten Hafenanlagen zusammenzählt, liefern wir, wir Duisburger, sogar den größten Binnenhafen der Welt.",
      "start": 172317,
      "end": 193470,
      "confidence": 0.9099767441860465,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ich bin beeindruckt.",
      "start": 193510,
      "end": 195551,
      "confidence": 0.8786666666666667,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Und bezüglich Wasserstraßen haben wir natürlich auch den Rhein, aber wir sind natürlich auch sehr an die Ruhr angedockt. Zugegeben, wenn du jetzt den Straßenverkehr auf dem Rhein mit der Ruhr vergleichst, ist es halt eher ein schlechter Vergleich. Aber warum erwähne ich das heute, dass wir den größten Binnenhafen der Welt liefern? Nicht nur, weil ich jede Nacht davon nicht geweckt werde. Ich hör das schon gar nicht mehr. Also, ich wohne relativ nah auch an Krefeld dran und relativ nah auch am Rhein. Und ich hab das Gefühl, Krefeld, speziell Krefeld-Ürdingen, hat auch einen kleinen Containerhafen. Und ich hab das Gefühl, nachts lassen die immer die Container extra fallen. Deswegen, wenn der Wind gut steht, hör ich das. Aber ich hab das Wort schon genannt, Container, darum geht's heute.",
      "start": 195923,
      "end": 238585,
      "confidence": 0.8109007633587784,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Genau, und zwar haben wir irgendwie in letzter Zeit erstaunlich viele Anfragen zu Docker und zu Containern bekommen. Keine Ahnung, warum das gerade irgendwie so in aller Munde ist. Wir haben auch öfters darüber gesprochen. Andi hat mir mal erklärt, Docker ist sowieso tot und Docker gibt es auch fast gar nicht mehr und lauter so Schlagzeilen mir in den Kopf geworfen und darum haben wir mal gedacht, ich glaube, wir müssen über Docker sprechen.",
      "start": 238626,
      "end": 261947,
      "confidence": 0.7970133333333332,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Die Anfragen waren wirklich komplett durch die Bank. Von teilweise, was ist Docker? Oder könnt ihr mal eine Folge zu Docker machen? Oder ihr sagt öfters, dass Kubernetes viel zu groß und viel zu komplex ist. Was ist denn die Alternative? Bis über, was ist denn Nomad von HashiCorp? Oder welche Cloud-Provider gibt es? Oder wie kann ich datensensitiv Docker-Container in Deutschland hosten? Und so weiter und so fort. Eine eine frage hat uns in die aktuellste frage die wir bekommen haben ist auf welche art und weise würdet ihr den empfehlen docker container zu orchestrieren.",
      "start": 262308,
      "end": 293741,
      "confidence": 0.824875,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Und das ist ja die frage schlechthin die sich aktuell immer stellt was soll man denn wirklich für dieses orchestrieren verwenden gibt es ja doch mittlerweile zahlreiche lösungen. Und darum haben wir uns gedacht, wir nehmen uns mal dem ganzen Docker-Thema an, in Ruhe. Wir sprechen dann auch natürlich die Orchestrierung, was es da so gibt. Aber dieses Thema ist so groß, dass wir das, glaube ich, in mehrere Episoden aufteilen müssen. Und wir starten heute einfach mal mit den, ich würde jetzt nicht sagen Basics, aber vor allem auch mit der Geschichte und probieren das auch ein bisschen aufzuarbeiten, wie das Ganze entstanden ist mit Docker, wo Docker aktuell steht, ob Docker wirklich tot ist und ob Docker und Container dasselbe sind.",
      "start": 294442,
      "end": 331927,
      "confidence": 0.8179349593495934,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ich muss grad super grinsen, weil du sagtest schon, wir schauen uns das ganze Thema Docker mal an und da hast du ja schon die erste Verwirrung reingebracht, die wir auch in dieser Episode klären werden. Was Wolfgang sagen möchte ist, das komplette Container-Ekosystem ist sehr, sehr stark im Wandel, aber schon seit Jahren und es ist unglaublich schwierig, da mitzukommen. Und ja, vielleicht hat alles irgendwie mit Docker angefangen, obwohl die ganzen System-Investoren, System-Engineers und Co. jetzt sagen, wie, Docker hat doch Container gar nicht erschaffen. Ja, das ist jetzt richtig, weil die ganze Thematik gibt's halt schon alles ein bisschen länger mit Linux, LXC und Jails und was weiß der Geier nicht. Und um da mal so ein bisschen den ganzen Überblick über das ganze Container-System zu bringen, haben wir uns mal vorgenommen oder selbst den Anspruch auferlegt, okay, wir machen jetzt mal ein paar Episoden über Container. Wir werden Themen beleuchten wie Kubernetes, wir werden Themen beleuchten wie, wo ist eigentlich der Unterschied zwischen RunC, LibContainer, LXC, ChangeRoot und so weiter. Aber das Thema, was halt jeder kennt, ist halt mal das Wort Docker.",
      "start": 332407,
      "end": 394818,
      "confidence": 0.8066844919786095,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ich habe mir auch immer gedacht, dass ich mich bei Docker auskenne, bis du mir dann die ganzen anderen Schlagwörter so in den Kopf geworfen hast und dann habe ich mir gedacht, okay, vielleicht muss ich auch mal mehr nachlesen über das ganze Thema. Man verwendet zwar das Ganze und kennt sich, ich würde sagen, doch eigentlich ganz gut aus, es ist ein Werkzeug, was man tagtäglich verwendet, aber es gibt dann schon viele Kleinheiten, Feinheiten und es hat sich doch in den Jahren einiges getan. Und darum wollen wir da mal tiefer rein blicken in das Ganze.",
      "start": 395238,
      "end": 421845,
      "confidence": 0.7742346938775512,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Falls ihr Docker schon jeden Tag nutzt, schaltet nicht ab. Wir werden euch jetzt nicht Docker Run erklären. Wir werden euch jetzt nicht erklären, wo ist der Unterschied zwischen Docker Run und Docker Start und dass ein Docker-Container immer nur einen Prozess haben sollte. Sondern wir werden mal ein bisschen versuchen unter die Oberfläche zu gehen.",
      "start": 421865,
      "end": 436128,
      "confidence": 0.8081071428571429,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Jetzt ist Docker für mich schon so ein Standard-Tool geworden, was ich wirklich tagtäglich verwende. Mir kommt vor eigentlich, dass das schon Jahrhunderte alt ist fast. ist ja eigentlich gar nicht mehr wegzudenken. Aber wie lange gibt es denn Docker eigentlich schon?",
      "start": 436148,
      "end": 448273,
      "confidence": 0.8084999999999999,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Docker, so wie wir es kennen, gibt es offiziell seit 2013. Und zwar hat der Gründer oder einer der Co-Entwickler Solomon Hikes die ganze Sache das erste Mal auf der Python-Konferenz PyCon im Jahre 2013 vorgestellt.",
      "start": 448714,
      "end": 462425,
      "confidence": 0.8384722222222223,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Das heißt, Docker ist noch gar nicht zehn Jahre alt.",
      "start": 464687,
      "end": 467168,
      "confidence": 0.8036000000000001,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Also, Docker hat jetzt in sehr kurzer Zeit, in ein paar Monaten Geburtstag, genau.",
      "start": 467208,
      "end": 471669,
      "confidence": 0.7700714285714285,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ist eigentlich schon unglaublich, wenn man sich vorstellt, wie das die Welt verändert hat.",
      "start": 472249,
      "end": 475549,
      "confidence": 0.7527857142857144,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Also, es ist jetzt natürlich die Frage, was ist der reale Geburtstag, was ist der wirkliche Geburtstag von Docker? Es ist ja nicht so, als hatte der einen guten Morgen, hat einen guten Espresso getrunken, hat einen Wochenendprototyp gehackt und danach war das fertig. Solomon Hikes hat bei einer Firma gearbeitet, die DotCloud hieß. Und DotCloud hat seit circa drei Jahren an dem Problem, was Docker lösen sollte, gearbeitet, bis sie mal die richtige Lösung hatten, da wo die gesagt haben, hey, das hier hat einen roten Faden, das hier macht Sinn. Und diese Lösung haben sie halt in der Python-Konferenz PyCon 2013 vorgestellt. Und daraus ist dann Docker entstanden. Und das wurde dann ein paar Monate später nochmal bei der französischen Konferenz .scale nochmal vorgestellt. Aber nicht vorgestellt so, hey ich geh jetzt auf die Bühne und demo das jetzt. Sondern da hat Solomon Hayek mal einen richtig guten, schönen, recht kurzen 20-Minuten-Vortrag gehalten über das Warum. Denn ich denke, es wird viel zu wenig über das eigentliche Warum von Software gesprochen.",
      "start": 476550,
      "end": 542499,
      "confidence": 0.8027109826589599,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Drum sprechen wir jetzt über das Warum. Schieß mal los. Warum?",
      "start": 542519,
      "end": 546083,
      "confidence": 0.6838181818181819,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Welches Problem löst Docker jetzt eigentlich? Immer wenn ich an Docker denke, denke ich an Container und blabliblub, ja? Aber der Gedankengang von Solomon Hikes und seinem Team ist unglaublich interessant. Und zwar haben die sich gedacht, das kann doch nicht so schwer sein, Software von A nach B zu schieben. Und dann fing der in dem Talk eigentlich relativ gut an darüber nachzudenken, okay, der war irgendwo in einem Projekt drin und dieses Projekt hatte eine Landingpage mit einem Static Site Generator, das Ding hatte ein Webfrontend, das Ding hatte eine Userdatenbank, sehr wahrscheinlich noch einen API Endpoint, hinten dran eine Queue mit Redis, dann Background Workers und eine Analytics DB.",
      "start": 546722,
      "end": 580543,
      "confidence": 0.7652053571428572,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Im Moment hat es 2013 schon einen Static Site Generator gegeben.",
      "start": 580583,
      "end": 583405,
      "confidence": 0.5021818181818182,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ja, das nannte man gegebenenfalls einfach HTML-Seiten.",
      "start": 584229,
      "end": 586772,
      "confidence": 0.7935714285714285,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Okay, eine Webseite.",
      "start": 587092,
      "end": 588414,
      "confidence": 0.502,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Das ist so die Applikation. Und dann hat man natürlich auch noch die Infrastruktur. Man hat den Laptop von dem Contributor, man hat eine Development Virtual Machine, man hat sehr wahrscheinlich einen QA-Server, dann hat man irgendwie ein paar Produktionsserver und dann hat man natürlich auch noch irgendwas im Thema Disaster Recovery. Und da rennt man natürlich in so ganz klassische Probleme, wie die Development VMs laufen auf Debian, aber Production ist irgendwie auf Red Hat, weil man irgendwie offiziell Support braucht und der, der Engineer, den entwickelt auf Python 3 und Production läuft auf Python 2.7 und so weiter und so fort. Auf jeden Fall haben sie sich halt fast drei Jahre damit beschäftigt, wie kann ich denn jetzt reliable Software von A nach B schieben, ohne in Seiteneffekte zu laufen.",
      "start": 588454,
      "end": 634907,
      "confidence": 0.7851666666666666,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Und da kommt jetzt dein Bremerhaven, Duisburger Hafen ins Spiel.",
      "start": 634947,
      "end": 640311,
      "confidence": 0.7684,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Und da kommt mein Duisburger Hafen ins Spiel, weil die haben sich halt nachgeguckt, okay, wie machen das denn andere Industrien? Und da war, ist der Vergleich super. Und zwar haben die sich gedacht, okay, was brauche ich denn, um einen Sack Kaffee von Chile nach Duisburg zu kaufen?",
      "start": 640591,
      "end": 653779,
      "confidence": 0.7175714285714289,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Kaffee und Chile, genau. Kaffee, Chile, nicht Kiel.",
      "start": 653819,
      "end": 657682,
      "confidence": 0.6387499999999999,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Chile, China, Chemie, Kaffee. Kaffee ist ja keine Bohne, ist eine Lebenseinstellung, Lebenskultur oder wie war das, ne?",
      "start": 658072,
      "end": 664695,
      "confidence": 0.7076666666666668,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Genau, Kaffee ist eine Lebenseinstellung.",
      "start": 664735,
      "end": 666616,
      "confidence": 0.7308000000000001,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Okay, ich rede jetzt einfach von Kaffeebohnen, ja? Was passiert eigentlich, wenn ich einen Sack Kaffeebohnen aus Chile und ein Klavier, also zum Beispiel ein Piano, transportieren möchte? Dann muss ich jemanden haben, der das genau weiß. Okay, ich darf das Piano nicht auf die Kaffeebohnen stellen, weil dann gehen die Kaffeebohnen kaputt. Was passiert denn, wenn ich die Säcke Kaffeebohnen auf das Klavier stelle? Ja, das funktioniert sehr wahrscheinlich auch nicht, weil dann sind Tasten sehr wahrscheinlich durchgerückt oder vielleicht ist der... ist das Gewicht der Kaffeebohnen zu schwer, was das Piano beschädigt. Also... Dann habe ich jemanden, der weiß, wie ich dann das Kaffeebohnen von Pianos auf dem Schiff trenne. Aber dann muss ich noch jemanden in dem Hafen haben, der auch weiß, wie ich ordentlich einen Sack Kaffeebohnen lager und transportiere und dann auch wirklich zum Endkunden bringe, weil gegebenenfalls dürfen die nicht nass sein oder nicht frieren oder sowas. Und dasselbe mit Piano. Piano darf keinen Kratzer haben, sonst bleibt der Wertverlust. Und dann hat er sich halt sich damit mal ein bisschen beschäftigt und zwar gab es 1950 haben sich ganz viele intelligente Leute zusammengesetzt und sind zu einem shipping container agreement gekommen. Also was sie eigentlich gemacht haben ist jeder hatte dieses Problem auf der Welt und die haben sich darauf geeinigt auf also die Infrastruktur provider in diesem Sinne das bedeutet die die Leute die, Häfen haben, die Häfen bauen, die Schiffe bauen und so weiter und so fort. Die haben sich gedacht, irgendwie müssen wir dieses Problem lösen, weil ich kann jetzt hier nicht kontinuierlich Leute einstellen, die wissen, wie man Kaffee transportiert oder Klaviere transportiert. Und dann haben die sich halt hingesetzt und haben halt gesagt, okay, wir einigen uns auf ein Format und das war der Schiffscontainer. Ja, also die haben sich dann auf die Masse geeinigt, aufs Gewicht, wie die Türen aufgehen, wie man die Türen abschließt, wie die Kanten sind und so weiter und so fort. Und das ist das, was wir heute so kennen als klassischer Schiffscontainer. Und was die, was das eigentlich aus Softwareperspektive bedeutet, ist, dass ein Schiffscontainer selbst eigentlich die Natur von Separations of Concern ist. Weil eigentlich sagt man jetzt, egal was im Container ist, es kann transportiert werden. Also man muss gar nicht mehr die Details kennen von, wie man Kaffee transportiert und wie man ein Piano transportiert, sondern man transportiert einfach nur diese Box, diesen Shipping-Container aus Stahl, diesen Schiffscontainer. Der, der bei mir in Krefeld-Urding immer nachts fallen gelassen wird.",
      "start": 666916,
      "end": 794723,
      "confidence": 0.7925309523809531,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Und man kann theoretisch auch eine Kühlung einbauen, wenn man will. Also dann hat man intern die Kühlung eingebaut, wenn man irgendeine spezielle Temperatur halten will oder so. Also das ist ja alles möglich.",
      "start": 795183,
      "end": 803947,
      "confidence": 0.806264705882353,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Und weil man jetzt ein standardisiertes Format hat, nämlich diesen Schiffscontainer, ermöglicht das nämlich dann so eine Art Automatisierung. Das bedeutet, die Infrastrukturprovider waren jetzt frei zu wählen, welchen Kran sie bauen wollen. Weil es ist ja völlig egal, weil der Kran muss ja nur dieses Interface, diese Maße von dem Schiffscontainer handhaben können und dieses Gewicht von diesem Schiffscontainer.",
      "start": 804347,
      "end": 824677,
      "confidence": 0.8298666666666664,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Also die API von dem Container sozusagen.",
      "start": 825097,
      "end": 827518,
      "confidence": 0.7675714285714286,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Kann man so sagen.",
      "start": 827558,
      "end": 828718,
      "confidence": 0.848,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Die Schnittstelle.",
      "start": 828758,
      "end": 829658,
      "confidence": 0.8845000000000001,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Und was nach 1950 dann passiert ist, die Logistikindustrie, die Schiffindustrie ist explodiert. Weil natürlich durch diese Separation of Concerns wurde Automation enabled und jeder hat einen Hafen gebaut, jeder hat einen Kran gebaut und natürlich sind dann die Geschwindigkeiten nach oben gegangen. Man kann also eigentlich sagen, wie man Kaffee um die Welt verschifft ist besser organisiert als wie wir alles Software deployen.",
      "start": 829698,
      "end": 853964,
      "confidence": 0.812578125,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Oder deployed haben.",
      "start": 854004,
      "end": 854724,
      "confidence": 0.4323333333333333,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ja, da muss ich dich mal ganz kurz rausholen. Ich denke, du bist immer noch in deiner Cloud- und Container-Bubble. Ich denke, dass es immer noch sehr, sehr viele Firmen draußen gibt, die noch nicht auf Container umgestiegen sind. Was völlig okay ist, weil es gibt auch Use Cases gegen Container. Doch ich will nur sagen, es gibt sehr viele Leute immer noch da draußen, die per FTP deployen oder die vielleicht sogar manuell auf irgendwelchen Server gehen und Files modifizieren, sofern das denn keine kompilierte Sprache ist.",
      "start": 854744,
      "end": 878017,
      "confidence": 0.794147727272727,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ja, aber es gibt auch sicher Transportunternehmen, die nicht Container verschiffen. Wenn du ein Windrad liefern musst, kannst du auch keine Container verwenden.",
      "start": 878617,
      "end": 886945,
      "confidence": 0.7120000000000001,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Das ist richtig. Auf jeden Fall ist das so das ursprüngliche Problem, und dann haben die sich natürlich gedacht, okay, was ist denn ein Container in der Softwarewelt?",
      "start": 887665,
      "end": 893811,
      "confidence": 0.6660357142857144,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Aber man könnte jetzt ja auch sagen, okay, 2013, das ist noch nicht mal zehn Jahre her, da war die Softwareentwicklung ja doch schon relativ weit. Man hatte da seine schönen Packages, man hatte JAR-File, das man ausliefern konnte, man hatte schon Virtualisierung, ich hab da wahrscheinlich auch schon meinen Server virtualisiert damals. Das war ja schon alles schön abstrahiert. Also ich hab da mein JAR-Package ausliefern können auf meine VM und hab das dort laufen lassen können. Also wofür ich dann noch Docker irgendwie gebrauche.",
      "start": 893831,
      "end": 923304,
      "confidence": 0.7689186046511627,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ja, das Problem ist das, was du jetzt angesprochen hast, das geht so in zwei Richtungen. Auf der einen Seite hast du gesagt, okay, wir haben irgendwie Isolation von Sprachen mit Java, du hast ein Java, was du drauf packst, und auf der anderen Seite haben wir diese Virtual-Maschinen. Lass das mal ganz kurz trennen. Bei den Sprachen hast du völlig recht, also wir haben ja Möglichkeiten, irgendwie Sprachen in ein Paket zu packen. Wie zum Beispiel JAR in Java, VirtualEnv für Python und RVM bei Ruby zum Beispiel. Das Problem ist hier, man kann da nicht wirklich alles reinpacken. In JAR kann man ja wirklich nur Java- und JVM-Geschichten reinpacken und in VirtualEnv halt wirklich nur irgendwie Python-Dependencies. Aber was ist denn mit allem, was da drunter liegt? Also, das bedeutet die OpenSSL-Library, libcurl, von mir aus auch FFmpeg. Also all das, was irgendwie halt nicht Python ist oder was halt nicht Java ist.",
      "start": 923464,
      "end": 969251,
      "confidence": 0.7754129032258065,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ja, die liegen ja eh in meinem VM-Image.",
      "start": 969711,
      "end": 972952,
      "confidence": 0.509125,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ja, ja, das ist richtig. Das bedeutet, die ganzen Libraries, die ich grad gesagt hab, ja, die sind auf deiner VM, das stimmt schon. Aber jetzt gehst du ja grad davon aus, dass in dieser komplexen Welt, von der ich grad erzählt hab, dass du den Contributors-Laptop hast, dass du die Development-VM hast, den QA-Servers, Production und so weiter und so fort, dass das alles auf demselben VM-Image läuft. Und wenn du jetzt nur die Software daraus auftauschst, tauschst du ja nicht die unterliegenden Dependencies aus. Einer der Probleme. In der Regel versucht man natürlich, dass das Staging-System gleich dem Produktionssystem ist, gleich dem Entwickler-Laptop. Sind wir mal ehrlich, das funktioniert einfach nicht. Da ist die Realität einfach off. Das bedeutet, die heftigsten Fehler und die, die am meisten zum Debuggen brauchen, sind halt oft diese Fehler. wo du irgendwie eine meiner Version Unterschied hast, wo irgendeine API gechanged ist, wo dann gegebenenfalls kein Semantic Versioning funktioniert hat. Das bedeutet, die Dependencies, von denen du ansprichst, ist ja alles in meinem VM-Image. Das ist schön, wenn das so wäre, aber es ist halt einfach nicht so. Ja, also die Setups sind nicht gleich. Und wenn man jetzt sogar noch On-Premise-Setups hat, also man schreibt eine Software, die dann bei Kunden wirklich On-Premise gehostet wird, wo dann zum Beispiel der Server, also diese virtuelle Maschine, gar nicht unter deiner Kontrolle ist, ist es ja noch schlimmer. Nicht schlimmer, beziehungsweise komplexer.",
      "start": 972992,
      "end": 1047487,
      "confidence": 0.7803765690376563,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Und warum kann ich jetzt nicht einfach die vm verwenden dass ich die die vm durchziehe durch meinen ganzen stack für entwickler für staging für production.",
      "start": 1047686,
      "end": 1057693,
      "confidence": 0.7549230769230773,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Kannst du und das wurde ja auch jahrelang gemacht und ich meine so technologien wie wie mw und so weiter und so fort sind ja immer noch sehr populär und es ist auch immer noch super. Es gibt verschiedene Herausforderungen bei Virtual Machines und mir fallen jetzt gerade recht schnell zwei Stück ein. Auf der einen Seite, bei einer Virtual Maschine selbst, hast du halt sehr viele Maschinendetails. Das bedeutet, du bundlest halt schon, okay, wieviel Harddrive hat die, dein Netzwerkinterface und so weiter und so fort. Also du shippst ja wirklich eine komplette Virtual Maschine. Und bundles halt so viel, was die Applikation gegebenenfalls gar nicht so im Detail abstrahiert. Also du sagst halt, okay, diese virtuelle Maschine muss 100% 100 Gigabyte haben und diesen Netzwerkthroughput und so weiter und so fort. Das ist die eine Geschichte. Die andere Geschichte ist natürlich die Geschwindigkeit. Eine virtuelle Maschine ist halt eine virtuelle Maschine mit einem Betriebssystem, mit allem drum und dran. Und wenn das natürlich in ein Paket packe, irgendwo hinschippe und starte, Systeme brauchen halt Zeit zum Booten und Systeme brauchen halt Zeit zum Operieren, deswegen ist es halt nicht innerhalb von ein paar Sekunden getan, wie der in die Kiste oben ist oder ähnliches. Also jeder, der zum Beispiel schon mal Virtual-Maschinen von A nach B geschoben hat, weiß, dass das je nach Größe ein andauernder Prozess sein könnte.",
      "start": 1057733,
      "end": 1140233,
      "confidence": 0.8177662337662347,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Wie hat eigentlich die ganze CICD Bewegung da mit reingespielt? War die eigentlich vor Docker? Ist die mit Docker entstanden? Ist die erst nach Docker gekommen?",
      "start": 1140773,
      "end": 1150324,
      "confidence": 0.8680384615384616,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Meines Wissens nach war das alles vor Docker, weil diese ganze Continuous Integration, Continuous Deploy, Continuous Delivery Thematik hat ja meines Erachtens nach den richtigen Hype und erst den richtigen Kickoff, Mit der Präsentation von John Oldsport und Paul Hammond von Flickr auf der Velocity-Konferenz 2009 gekriegt, da wo die gesagt haben, hey, pass mal auf, wir zeigen euch mal, wie unsere Entwicklungsabteilung und unsere Operationsabteilung auf Flickr kooperieren. Flickr kennst du noch, dieses Foto-Teil-Plattform-Ding?",
      "start": 1150364,
      "end": 1179768,
      "confidence": 0.8099333333333335,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Natürlich, gibt's auch noch.",
      "start": 1179788,
      "end": 1181109,
      "confidence": 0.6355000000000001,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ist glaube ich aber nicht mehr so populär, oder?",
      "start": 1181609,
      "end": 1182750,
      "confidence": 0.47200000000000003,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ja, Instagram hat alles gekillt.",
      "start": 1182790,
      "end": 1185652,
      "confidence": 0.779,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Naja, auf jeden Fall so im Juno 2009 haben sich halt John Oldspore und Paul Hammond da hingestellt auf der Velocity-Konferenz und haben gesagt, hör mal auf, auf Flickr deployen wir 10 Mal pro Tag. Und das war für 2009... Brainfuck, ja? Also das war wow, wie macht ihr das denn? Wo heutzutage in einer guten Organisation, die sehr gut aufgestellt ist, die auch stabiles Testing hat und so weiter, wo man sagen kann, okay, zehn Deploys am Tag sollten der Standard sein, wenn es nicht der Standard ist, sollten das Ziel sein, aber für 2009, also ich meine, das war 13 Jahre her, war das schon massiv und Da wir gerade gesagt haben, Docker wurde das erste Mal public announced auf der PyCon 2013, wird für mich bedeuten, also für mich ist der Start diese Präsentation mit CI, CD. Das bedeutet, auch wenn wir sagen, .cloud hat schon drei Jahre an Docker gearbeitet, dann wären wir bei 2010. Das bedeutet für mich, der richtige Ursprung von CI, CD und Co. war mit dieser Präsentation somit vor Docker.",
      "start": 1185712,
      "end": 1245284,
      "confidence": 0.8049438202247188,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Aber das hat dann durchaus vielleicht die Docker-Bewegung angeschoben, weil das natürlich in dem in dem Ecosystem dann auch viel, viel vereinfacht.",
      "start": 1245324,
      "end": 1252549,
      "confidence": 0.8195909090909091,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Wir reden hier über zwei Dinge. Ich glaube, wir reden hier über auf der einen Seite die Kultur und das Mindset, dass wir zehnmal am Tag deployen, dass wir unsere Changes sofort in Produktion packen oder mit einem sehr geringen Delay. Also, dass wir wollen das und das What and Why. Und Docker hat dazu beigetragen und hat die technische Hürde gesenkt und somit eher das How beantwortet. Also, wie machen wir das?",
      "start": 1252944,
      "end": 1281927,
      "confidence": 0.8688493150684932,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Also das habe ich gemeint, dass die CI-CD Bewegung Docker angeschoben hat, weil das natürlich ein cooles Tool war für die, um den Prozess zu vereinfachen.",
      "start": 1282263,
      "end": 1290150,
      "confidence": 0.7893846153846155,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ja, auf dem generellen Aspekt hast du halt schon recht.",
      "start": 1290502,
      "end": 1293525,
      "confidence": 0.7358,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Okay, jetzt haben wir also VMs, die sind zu schwergewichtig. Wir haben diese Jars, die Packages für Software, für eine Sprache. Da hat zu wenig Platz, weil man da zu wenig Abhängigkeit noch mit reinpacken kann. Docker ist dazwischen, beziehungsweise Container sind dazwischen. Aber was sind jetzt diese Container überhaupt oder Docker? Was ist denn so ein Container-System? Oder wie ist denn dieser Container überhaupt spezifiziert mit seinen Türen und Maßen und so weiter? Was ist das technisch eigentlich?",
      "start": 1293585,
      "end": 1321489,
      "confidence": 0.7899620253164557,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Einen Container kann man als gesunden Mittelweg zwischen diesen beiden zwei Welten, Packaging in einer spezifischen Sprache und einer virtuellen Maschine sehen. Und zwar, wenn wir jetzt einfach nur mal uns auf Linux fokussieren, erfindet Docker jetzt nicht das Rad neu. Das bedeutet, dieses Wort Linux-Container, die gibt es schon seit Ewigkeiten. Und was es unten drunter ist, ist eigentlich eine Prozessisolation. Man isoliert eigentlich Prozesse voneinander. Diese Prozesse teilen zwar dann noch den Linux-Körner, also das unten drunter, das Basis-System.",
      "start": 1321549,
      "end": 1354080,
      "confidence": 0.8560864197530863,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Das heißt, ihr könnt kein Windows in Docker laufen lassen.",
      "start": 1354100,
      "end": 1356563,
      "confidence": 0.6894000000000001,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ich kann jetzt keinen Windows-Docker-Container auf einem Linux-Host-System laufen lassen, weil ich ja gesagt habe, die sharen den Kernel und es ist eine Prozessisolation. Das bedeutet, ich kann jetzt kein anderes, kein grundlegendes andere Betriebssystem-Architektur laufen lassen. Was ich aber tun kann, es gibt inzwischen Windows-Docker-Container und die kann ich auf einem Windows-Host-System laufen lassen, weil Docker mehr und mehr in die Richtung geht, auch Windows zu supporten.",
      "start": 1356843,
      "end": 1381347,
      "confidence": 0.8317941176470585,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Und da hat man schon ein Problem gesehen mit dem ganzen, wie die neue Mac-Architektur rausgekommen ist, auf ARM, dass die halben Images nicht funktioniert haben und dass das extremes Problem war, die Images auf Mac zum Laufen zu bekommen, weil halt das eben eine andere Architektur ist und daher das Host-System nicht matcht mit dem Container-System.",
      "start": 1381927,
      "end": 1401327,
      "confidence": 0.8497719298245613,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ja gut, aber mit ARM würde ich fast so weit gehen, dass das jetzt kein Docker-Problem war, weil auch Photoshop auch Probleme hat. Und da geht's einfach nur um andere CPU-Instructions und Co. Da geht's dann wirklich... Also das ist kein Problem, was Docker hat, meines Erachtens nach. Das ist ein Problem der Software-Industrie, dass wir einfach die CPU-Architektur ändern und somit andere Instructions haben. Also was Docker dann jetzt wirklich macht, ist Prozessisolation. Und das ermöglicht dir natürlich unter anderem auch, andere Python-Versionen zu installieren, weil du kannst ja den Python-Prozess von anderen Python-Prozessen isolieren. Was aber unten drunter geteilt wird, ist halt schon die gemeinsamen Ressourcen. Zumindest im Anfang von Docker gab es nur die Prozessisolation, weil am Anfang Docker ganz stark auf LXC gesetzt hat. LXC ist die Abkürzung für Linux Containers und ist eine Art und Weise, wie man Linux Containers auf einem Linux Host startet. Inzwischen nutzt Docker kein LXC mehr, inzwischen nutzt Docker Lib Container, was eine eigene Entwicklung ist, um die Dependency zu LXC loszuwerden und um mehr Möglichkeiten vom Linux Kernel zu nutzen. Auf LXC gehen wir später mal ein in einer weiteren Folge. Der Punkt ist jedoch, neben der Prozessisolation geht es natürlich im Containerwesen auch um Ressource-Isolation. Das bedeutet wie viel RAM, wie viel CPU, wie viel Harddisk darf so ein Container benutzen und das kam erst später beziehungsweise das war noch nicht im initialen Release von Docker vorhanden. Man kann also sagen, Linux und Container und Linux Namespacing isoliert eigentlich unter anderem auch, es schafft ja einfach ein neues Filesystem. Und das ist unter anderem der Grund, warum man zum Beispiel nicht in jedem Docker-Container eine Bash-Shell starten kann, weil die Bash-Shell auch in dem isolierten Filesystem mit dabei sein muss. Und was halt nicht immer der Fall ist, wie zum Beispiel bei einem Docker-Stretch-Container oder ähnliches. Und das ist der Grund, warum ziemlich viele Leute aus Convenience-Reason ein Alpine, Debian oder Fedora-Base-Image nehmen, weil man dann schon ziemlich viel mitgeliefert hat, was man dann vom klassischen Betriebssystem kennt, was man aber nicht muss. Das bedeutet, es wird das Filesystem isoliert, es wird die Prozesse isoliert, der Kernel wird geteilt und das hat zur Folge, alles was man haben möchte, muss man in den Container packen, weil sonst hat man noch nicht mal das bare Minimum wie eine Shell.",
      "start": 1401762,
      "end": 1548528,
      "confidence": 0.8508282051282051,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Wer Interesse hat, ist besser zu verstehen. Wir können da einen Artikel verlinken, der ist wirklich gut, der erklärt eigentlich, wie man mit ChangeRoot so ein Mini-Container-System bauen kann, mit wirklich drei Kommandos. Ist natürlich jetzt nicht gleichwertig mit einem Full-Fledged-Container-System, aber wie einfach das ist eigentlich mit ChangeRoot, in Linux so einen Container zu machen und zu bauen und wie der wirklich funktioniert. Weil dadurch bei Linux ja alles über das File-System bzw. über die Pfade geregelt ist, kann man über Change Root, wo einfach das Root-Verzeichnis geendet wird, eigentlich alles kontrollieren, weil man dann eben keinen Zugriff mehr hat auf andere Prozesse zum Beispiel.",
      "start": 1548828,
      "end": 1586292,
      "confidence": 0.7995754716981132,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Wolfgang, hilf mir doch mal eben ganz kurz, was ist ChangeRoot?",
      "start": 1586478,
      "end": 1588780,
      "confidence": 0.23063636363636364,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "ChangeRoot macht nichts anderes, als dass dein Slash, den du sonst kennst, als dein Root-Verzeichnis auf Linux umzusetzen auf irgendein anderes Verzeichnis. Und damit kannst du nicht mehr auf //proc//etc//home zugreifen, weil dein Slash ist eben irgendein Unterverzeichnis. Und dort musst du dann, wie du jetzt erklärt hast, Dein eigenes Umfeld mit reinpacken, deine eigene Bash. Alles was du so brauchst, musst du dort reinpacken und das lebt dann dort in diesem neuen Root. Also aufgerufen wird es dann oder executed wird es dann natürlich im Kernel, aber das ganze Filesystem musst du einfach mitliefern. Die Dateien, die du brauchst, die executables, die du brauchst, wie Bash zum Beispiel. Und das zeigt eigentlich, wie einfach das funktioniert. Also kann ich wirklich jedem ans Herz legen, den Artikel mal durchzulesen oder vielleicht mit den Kommandos rumspielen. zeigt eigentlich, dass das alles keine Blackmagic ist, die dahinter steckt, sondern wirklich Linux-Grundlagen.",
      "start": 1588840,
      "end": 1643776,
      "confidence": 0.8035906040268457,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Und wenn man uns jetzt so zuhört, kann man sich denken, okay, ja, Moment mal. Also, wir haben jetzt zwei Problemfelder. Einmal die Programmiersprachenpackaging, einmal die VMs. Okay, haben wir. Jetzt haben wir Container, das ist so ein Mittelding dazwischen. Und jetzt erzählt ihr die ganze Zeit, hey, das gibt's doch schon. Mit Changeroot und so weiter. Also Linux kann das schon. Was ist denn jetzt das Ding an Docker? Jetzt kann man böse sein und sagen, Docker ist Changeroot mit dem Marketingbudget. Oder man kann wirklich mal gucken, was Docker ist. Weil Docker, das, ich sag mal in Anführungszeichen, Revolutionäre an Docker ist Folgendes. Und zwar genau drei Dinge. Die erste Baustelle. Docker definiert ein einheitliches Format zur Definition von Containern. Wie man Container baut. Und wie Container paketisiert werden und allem drum und dran. Die haben halt ein einheitliches Format geschaffen. Also sozusagen wir haben 50 Standards. Wir machen den 51. Standard. Dieser Standard hat sich aber durchgesetzt. Und ich bin mir nicht sicher, ob wenn die nur den Standard gemacht hätten, ob die erfolgreich gewesen sind, weil ich denke, die nächsten beiden Punkte sind genauso wichtig. Und zwar haben sie Entwicklern ein Tool an die Hand gegeben, um Container sehr einfach zu bauen. Sie müssen sich nicht mit Chainshoot auseinandersetzen, sie müssen sich nicht mit Machine Types auseinandersetzen, sie müssen sich nicht mit LXC auseinandersetzen und SystemDN spawnen und was es nicht noch alles da unten drunter gibt oder Jails. Sie haben einfach ein Docker-Build-Command gekriegt, womit Sie das einheitliche Format, zum Beispiel die Definition durch ein Docker-File, simpel bauen können. Und das dritte im Bunde, Sie haben der Operations-Abteilung, den Systemadministratoren, den Cloud-Providern, den Systems-Engineers einfache Tools an die Hand gegeben, um einen Container zu starten und ihn laufen zu lassen. Und meines Erachtens nach kann man den Erfolg von Docker auf diese drei Dinge zurückzuführen, dass sie einfach das ganze Paket mitgebracht haben. Der Grund für den Erfolg ist also eigentlich, dass Docker die Problematiken des Linux-Container-Systems sehr vereinfacht hat und für das komplette Container-Ökosystem eine Managementlösung geschaffen hat. Ich bin immer sehr böse und sage immer, Docker ist einfach nur richtig, richtig einfach zu benutzende UI, User Interface für Container. Und meines Erachtens nach ist das der Erfolg von Docker, dass sie einfach diese komplexe Thematik von Linux Containern zugänglicher gemacht haben. Ich sage nicht, dass es immer noch einfach ist, das sage ich nicht, weil unten drunter wird es immer schwierig, wenn man sich mit den Details auseinandersetzt. Doch der Zugang, die Einstiegsbarriere wird deutlich heruntergehoben.",
      "start": 1644085,
      "end": 1791672,
      "confidence": 0.8095413711583921,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Man muss sich ja nur überlegen, wie einfach das jetzt ist als Developer oder wenn man irgendein Tool ausprobieren will. Docker ist fast standardmäßig schon installiert, sonst installiert man sich das halt einmal schnell über das Betriebssystem und dann sagst du docker run von irgendeinem Image Von irgendeiner Software, die du ausprobieren willst, kann was komplexes sein. Irgendwie, Metabase haben wir zum Beispiel besprochen. Da gibt es ein Command, das führst du auf deiner Command-Line aus. Du musst nichts runterladen, das passiert alles automatisch. Ein Docker-Run-Befehl und du hast eine Metabase laufen, lokal. Und ich glaube, das ist eben genau wie du sagst, das ist die Stärke von Docker, dass das so einfach gemacht wurde. Wo ich das erste Mal Docker verwendet habe, hatte null Ahnung, was das eigentlich macht. Du führst einen Befehl aus und wie ein Wunder hast du plötzlich irgendwas am Laufen lokal bei dir. Und das ohne Probleme, ohne irgendwie viele Einstellungen zu machen. Wenn man das früher mit der VM probiert hatte, klar, die Anbieter hatten auch so VM-Images. Aber da hast du das richtige VM-Image gebraucht, da hast du die richtige Umgebung gebraucht, es hat alles passen müssen, es war langsam. Es hat alles gebraucht, bis das Online war. Und dann hat es meistens aus irgendeinem Grund doch nicht funktioniert. Und mit Docker, die Erfahrung, die User Experience, die Dev Experience war einfach super, super gut. Und das ist dann eher die Endanwender Sicht. Aber es gibt natürlich auch die Developer Sicht. Wenn man jetzt irgendetwas entwickelt, vor allem im Team gemeinsam, das war plötzlich so einfach, wenn man mit Docker gearbeitet hat, wenn man sich geeinigt hat auf die Container, weil vermutlich können das alle Devs, wie das früher war, man hat zuerst 100.000 Dependencies installieren müssen, irgendwas hat nie funktioniert lokal, dann hat man wieder was anderes ausgecheckt, dann hat es wieder einen Versionskonflikt gegeben. Also es war alles nicht sauber getrennt, Auch wenn man jetzt irgendwelche Chars oder solche Dinge hat, irgendwo hat es immer irgendwelche Probleme gegeben. Und das fällt mit Docker eigentlich komplett weg, weil einfach immer die gesamte Umgebung mitgeliefert wird, so wie wir entwickeln für dieses Projekt. Und damit habe ich immer up-to-date die Environment zur Verfügung, die dann auch produktiv eingesetzt wird, im Idealfall. Und das hat natürlich das Developerleben stark vereinfacht. Am Anfang hat man meistens so gesagt, Docker ist eher nichts für produktiven Einsatz. Da hat man das langsam so im Development-Prozess eingesetzt. Aber auch da hat es schon so viele Sachen vereinfacht. Und ich glaube, das war eigentlich so das Erfolgsrezept, die Einfachheit und die vielen Schmerzen, die dann auf der Dev-Seite eben nicht mehr da waren. Das war, glaube ich, der große Erfolg von Doc.",
      "start": 1791872,
      "end": 1942916,
      "confidence": 0.8048476821192045,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Prinzipiell würde ich dir zustimmen, aber da sage ich auch wieder, der Teufel liegt im Detail. Also ich habe schon sehr, sehr viele Docker-Container gesehen, wo einfach während des Docker-Build-Commands, also wenn der Container gebaut wird, ein Update und ein Upgrade gemacht wird. Und das heißt natürlich, man hat bei jedem Build gegebenenfalls eine neue Version von irgendeiner unterliegenden Software. Wenn man halt nicht wirkliches Version Pinning betreibt, dann holt man sich gegebenenfalls neue Dependencies, geupdated Dependencies, die dann auch wieder Bugs und Regressions haben könnten, holt man sich dann rein und somit wird dieser Vorteil, den du gerade genannt hast, relativiert, aber man kann ihn immer noch erreichen.",
      "start": 1943429,
      "end": 1979421,
      "confidence": 0.8038623853211011,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Das ist vielleicht ein wichtiger Punkt, weil das ist ja einer der großen Vorteile von Containern, dass du diese Wiederholbarkeit hast. Wenn du auf Maschine A irgendwas machst, dann kommt da dasselbe Resultat raus wie auf Maschine C. Das stimmt natürlich nur bedingt, genau wie du sagst, wenn du natürlich die Docker Images bildest. dann hast du dasselbe Problem, dass du dann auch externe Abhängigkeiten und wenn du da auf irgendeine Lip verweist, die es nicht mehr gibt, dann hast du natürlich auch ein Problem. Aber solange du mit Images arbeitest, also mit den fertig gebauten Images, kannst du das natürlich verhindern. Also diese Idempotenz, also dass immer dasselbe rauskommt, wenn man was ausführt, das hat man natürlich nur bedingt.",
      "start": 1979781,
      "end": 2016666,
      "confidence": 0.7790666666666666,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Natürlich kann man auch sowas bauen, wie ich habe ein fertiges Docker-Image und mache dann beim Docker-Run, also wenn ich den Container, die Containerinstanz hochfahre, also eine neue Instanz aus dem fertigen Image, wenn ich da natürlich auch irgendwas mit Upgrade, Update, Upgrade, Upgrade mache, dann kann sogar jede Containerinstanz natürlich unterschiedlich sein. Also falls ihr sowas mal seht, hebt mal bitte die Hand und sagt, gegebenenfalls sollten wir uns hier über die Idempotenz dieser Container und Containerinstanzen mal unterhalten, weil dadurch könnt ihr euch natürlich eine ganze Menge Probleme ins Haus holen. Auf der anderen Seite macht das natürlich auch das Upgrade ein bisschen aufwendiger, weil man dann explizite Package-Upgrades haben muss. Meines Erachtens nach überwiegen da die Benefits den Nachteilen. Thema Nachteile. Ich bin immer so ein Fan davon, okay, lass mal bitte eine Lösung kritisch betrachten, weil es klingt nämlich so ein bisschen wie, ist Docker jetzt das neue geschnitten Brot? Also ist Docker jetzt die Allerweltslösung und heilen wir damit Krebs? Nein, tun wir nicht. Docker hat auch Nachteile. Und Docker ist gegebenenfalls nicht für alles.",
      "start": 2016984,
      "end": 2077022,
      "confidence": 0.8178444444444447,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Naja, Freunde von mir arbeiten in der Krebsforschung, die verwenden Docker, also... Ich hoffe.",
      "start": 2077643,
      "end": 2082025,
      "confidence": 0.7512857142857142,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Für deine Freunde, dass sie bald Erfolg haben, damit Docker dann auch Krebs heilen kann. Schauen wir uns mal ein bisschen so die Nachteile an. Und zwar, jetzt reden wir hier gerade, Docker-Container sind super, Prozessisolation, blabliblub. Wir sagen aber auch, Container teilen gewisse Ressourcen. Und das ist nämlich genau der Punkt. Docker-Container sind nicht virtuelle Maschinen. Das bedeutet, die Elemente innerhalb eines Containers sind nicht strikt isoliert. wie in Virtual-Maschinen. Das bedeutet auch, wird auf eine erhöhte Security Wert gelegt, kann man deutlich bessere Isolation mit ganz klassischen Virtual-Maschinen an den Tag legen, als mit Docker-Containern. Weil die Popularität von Docker und von Containern, beziehungsweise von Linux-Containern, hat natürlich auch sehr viele Security-Researcher und Hacker auf den Plan gerufen, die natürlich in irgendeiner Art und Weise jetzt versuchen, okay, aus Containern auszubrechen, um Zugang aufs Host-System zu kriegen. All diese Versuche gibt's natürlich auch bei klassischen Virtual-Maschinen, um auf den Hypervisor zu bekommen, gar keine Frage. Doch von Haus aus hat man natürlich bei Virtual-Maschinen ein erhöhtes Isolationslevel.",
      "start": 2082065,
      "end": 2142230,
      "confidence": 0.8159408284023674,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Vor allem, weil man da halt dann wirklich auch die Hardware simulieren kann, unter Umständen in VMs, und dann kann die natürlich eigentlich alles machen. Dann kann die genau den Speicherplatz begrenzen, dann kann die Art, die Geschwindigkeit sogar begrenzen, wie auf die ... Hardware zugegriffen wird auf ein virtuelles Filesystem zum Beispiel. Das kann ich natürlich bei Docker alles nicht machen, weil das nativ zugreift. Das kann ein großer Vorteil sein, was natürlich viel viel schneller ist, aber wenn ich da natürlich irgendwas begrenzen will, limitieren will, einstellen will, filtern will, dann habe ich dann natürlich keine Möglichkeiten bei Docker oder nur sehr sehr begrenzt. Memory geht ja mittlerweile, aber es sind doch sehr rudimentäre Einstellungen, die da getroffen werden können. Im Vergleich zu einem KEMU, keine Ahnung, ich weiß bis heute nicht, wie man es genau ausspricht, diese Virtualisierung, die sogar einen ARM-Prozessor virtualisieren kann, zum Beispiel, oder simulieren kann.",
      "start": 2142250,
      "end": 2189671,
      "confidence": 0.7788026315789469,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Man kann schon sagen, dass Docker-Container halt kein Bare-Metal-Speed leisten, weil man hat natürlich ein paar Layer dazwischen. Virtuelle Maschinen sind halt schon näher dran an der richtigen Hardware.",
      "start": 2189711,
      "end": 2201181,
      "confidence": 0.804551724137931,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Da erinnere ich mich immer gern zurück an die Diskussion, man kann Datenbanken nicht in Docker betreiben.",
      "start": 2201221,
      "end": 2205865,
      "confidence": 0.734,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ja, aber davon rede ich nicht. Also Datenbanken ist meines Erachtens nach eine andere Liga. Nicht wegen dem klassischen Per Metal Speed, sondern einfach nur wegen dem Write-Throughput. Es geht hier einfach nur darum, je nachdem, dass der Zugang zur Hardware, dass da ein paar Layer dazwischen sind und das automatischen Performance-Impact hat. Ich sage nicht, dass dieser automatische Performance-Impact relevant für jede Anwendung ist.",
      "start": 2205925,
      "end": 2229092,
      "confidence": 0.8126923076923077,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Nein, nein, aber lass mich fertig reden. Das war eben lange die Diskussion und ich kann mich erinnern, wie dann Percona endlich so einen Test rausgebracht hat zum MySQL zumindest. Wie performt MySQL auf Docker? Und im Prinzip haben die gemeint, klar siehst du einen minimalen Unterschied bei manchen Dingen, aber im Prinzip ist es komplett zu vernachlässigen. Also bei MySQL. Es ist ja zum MySQL gegangen.",
      "start": 2229512,
      "end": 2250976,
      "confidence": 0.7597164179104479,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Aber Datenbanken und Container ist ja ein super Thema. Und zwar sagt jeder, du darfst keine Datenbanken und Container betreiben und so weiter, weil das hat ja einen Performance Impact und ist langsam. Ja, das stimmt halb. Was man sich bewusst werden muss, ist, dass Container von Haus aus erstmal stateless und immutable sind. Das bedeutet, wenn ich einen Container starte und da werden Daten innerhalb des Containers geschrieben und ich stoppe den Container, Dann werden die Daten nicht auf dem Host-System persistiert. Wenn ich dann die Container insgesamt sogar lösche, dann sind die Daten erstmal weg. Datenschreiben innerhalb eines Containers hat auch eine gewisse Art von Performance-Impact. Und ich sag gewisse Art, weil Container von Haus aus erstmal mit der Copy-on-Write-Methode arbeiten. Was bedeutet das? Container sind optimiert auf Lesezugriffe. Mehrere Prozesse greifen auf eine Datei zu. Jeder dieser Prozesse bekommt eine eigene inode für diese Datei. Die Zeigerinformationen in dieser inode greifen aber alle auf dieselbe Stelle auf der Harddisk zu. Das bedeutet, super viele Prozesse können auf dieselbe Datei zu greifen, ohne irgendwie richtige Kopien zu erstellen, ohne irgendeinen Performance-Impact. Kommt jetzt ein Prozess um die Ecke und schreibt diese Datei, just in diesem Moment wird eine Kopie von dieser Datei, eine reale Kopie von dieser Datei erstellt. Das hat auch zur Folge, dass wenn du eine write-heavy-Applikation hast, wie zum Beispiel eine Datenbank, dann wird natürlich bei jedem Schreibvorgang erstmal eine neue Datei erstellt. Das kann dazu führen, dass schreiblastige Applikationen, wie zum Beispiel Datenbanken, die ihren Schreibfahrt innerhalb des Containers haben, einen gewissen Performance Impact erleiden. Im Detail ist das aber jetzt auch nur so halbwahr, weil da muss man jetzt unterscheiden, welchen Storage Driver hat man denn konfiguriert für Docker und der Standard Storage Driver ist mit Copy-on-Write oder nutze ich ein Docker-Volume. Und ein Docker-Volume bedeutet, ganz generell gesprochen, man mountet ein Folder vom Host-System in den Container und somit hat man dieses Copy-on-Write partiell umgangen. Das hat natürlich dann andere Eigenschaften, wie zum Beispiel, dass innerhalb eines Containers direkt einen Weg aufs Host-System geht. Das bedeutet Security und Co. Stellen wir jetzt einfach mal zur Seite. Aber das ist immer der Punkt, wo die Leute sagen, uuh, uuh, uuh, Docker-Kartiner sind langsam. Ja, weil sie in der Regel auf dieses Copy-on-Write hinaus wollen, weil sie in der Regel auf den konfigurierten Storage-Driver hinaus wollen, weil sie sehr wahrscheinlich dann auch auf den Unterschied zwischen Storage-Driver und Docker-Volumes hinaus wollen.",
      "start": 2251016,
      "end": 2390005,
      "confidence": 0.815002457002457,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Und wenn man Volume eingebunden hat, bekommt man eigentlich nativen Speed. Da gibt es eigentlich keine Nachteile, weil da dann kein Virtualisierungslayer mehr dazwischen ist.",
      "start": 2390285,
      "end": 2399827,
      "confidence": 0.8106799999999997,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Da hat man dann andere Herausforderungen, zum Beispiel wenn man jetzt an PHP-Dateien oder Node.js oder JavaScript-Dateien denkt, wo man halt mit unglaublich vielen Dateien über ein Docker-Volume arbeitet, da hat man eine andere Herausforderung. Aber das liegt dann primär an der schieren Menge an Dateien, wenn ich so an Open-File-Limits denke und Co. Ein dritter Nachteil ist, und da muss ich zugeben, da weiß ich gar nicht, wie relevant dieser Nachteil wirklich in der Industrie ist, Docker selbst wurde für Server-Applikationen designt und nicht für grafische User-Interfaces. Das bedeutet irgendwie, wenn du Applikationen hast, die wirklich eine UI haben, und davon rede ich jetzt nicht von einer Web-UI, ich rede wirklich von einer Desktop-Applikation oder ähnliches, dann ist das immer so eine Thematik. Und natürlich, da gibt's irgendwie Workarounds mit X11 Video, mit der Weiterleitung von einem Videostream mit X11 und solche Geschichten. Aber die fühlen sich alle eher so wie ein dreckiger Workaround, wie ein dreckiger Hack an. Also, auch heutzutage, Docker ist halt noch nicht wirklich geil für grafische Applikationen. Man kriegt's ans Fliegen, aber die Frage ist, nutzt man da nicht das falsche Tool für ein Problem? Weil es wurde halt einfach designt. für Serveranwendung. Allem in allem denke ich, die Nachteile sind überschaubar und ich plädiere wirklich dafür, sich das auch mal anzusehen. Ich bin schon ein Fan von Containern.",
      "start": 2400138,
      "end": 2481244,
      "confidence": 0.7939999999999995,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ich würde fast sagen, das sind teilweise keine Nachteile, sondern sind halt einfach Eigenheiten von der Technologie, mit denen man sich auseinandersetzen muss, um die man auch rumarbeiten kann. Und so wie halt jedes Tool muss man das halt gut kennen und wissen, für welchen Einsatzzweck es gedacht ist.",
      "start": 2481284,
      "end": 2496217,
      "confidence": 0.8002244897959185,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Was würdest du denn sagen ist dein geschnitten Brot Vorteil?",
      "start": 2497026,
      "end": 2500910,
      "confidence": 0.8568000000000001,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Wo sagst du... Men, men, was?",
      "start": 2500930,
      "end": 2502832,
      "confidence": 0.7483333333333334,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Geschnitten Brot. Kennst du nicht? Das verkauft sich wie geschnitten Brot. Also geschnitten Brot war ja eine Erfindung, die ist ja durch die Decke gegangen. Und meines Erachtens nach frage ich dich jetzt, was ist denn dein Hauptvorteil? Weswegen sagst du, wow, das ist der Killer?",
      "start": 2502852,
      "end": 2514463,
      "confidence": 0.7709782608695656,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Also geschnitten Brot Vorteile gibt es bei mir nicht, weil geschnittenes Brot hat nur Nachteile. Ich bin ja auch jemand der gerne selber Brot backt und geschnittenes Brot trocknet nur viel schneller aus. Aber warum schneidet man Brot? Man macht weniger Sauerei oder?",
      "start": 2514863,
      "end": 2531928,
      "confidence": 0.8425581395348835,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Kurze Frage, wo wir bei Brot sind. Wie nennt ihr das Endstück von einem Brot?",
      "start": 2531948,
      "end": 2535429,
      "confidence": 0.7915333333333334,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Scherzl.",
      "start": 2535469,
      "end": 2536049,
      "confidence": 0.75,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Scherzl? Das ist doch kein Witz.",
      "start": 2536609,
      "end": 2538170,
      "confidence": 0.5,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ja, ich glaub Scherzl, wenn man jetzt nicht alles täuscht.",
      "start": 2538951,
      "end": 2541537,
      "confidence": 0.4726,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ihr?",
      "start": 2541597,
      "end": 2543040,
      "confidence": 0.735,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ist das schon wieder so eine Stulle oder sowas?",
      "start": 2543100,
      "end": 2544964,
      "confidence": 0.6761111111111111,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Knäppchen kenn ich, Knistchen kenn ich auch, Ende ab und zu ganz einfach.",
      "start": 2545024,
      "end": 2549133,
      "confidence": 0.6869230769230771,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Okay, wir werden den Sprachatlas zu Scherzl verlinken.",
      "start": 2549660,
      "end": 2552901,
      "confidence": 0.659125,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Ich hab hier gerade mal geguckt und zwar heißt hier ein Artikel die 100 häufigsten Wörter für das Brotende. Geiles Ding, werden wir natürlich in den Shownotes verlinken. Aber was ist denn jetzt hier dein Verkaufsargument? Du bist jetzt hier Vertriebler, so warum muss ich jetzt Docker einsetzen und was sagst du? Hör mal, das ist das Killer-Argument.",
      "start": 2553321,
      "end": 2569908,
      "confidence": 0.7428103448275862,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Ja, es gibt schon viele Argumente, die wir hier auch besprochen haben. Mein persönlicher Favorit ist einfach, auch wenn ich jetzt sehe, wie das mit VMs ist, dass der Updateaufwand viel geringer ist von Docker. Weil eine VM muss ich immer updaten, muss ich das ganze Betriebssystem up-to-date halten, das muss ich in verschiedenen Environments machen. Und mit Docker habe ich ein sehr abgespecktes System, das heißt, ich muss nur, unter Anführungszeichen, nur diese Umgebung up-to-date halten von meinem System. Und wenn ich da auf andere Docker-Container vertraue, wenn ich da jetzt für PHP und PHP-Docker-Container verwende, dann ist der eigentlich up-to-date gehalten und jedes Mal, wenn ich das Docker-Image neu baue oder halt Ich muss die Versionen natürlich anpassen, kann das schnell lokal testen. Das heißt, das ist auch super im Vergleich zu VMs, weil da muss ich mich irgendwo einloggen, muss updaten, muss hoffen, dass da irgendwie nichts kaputt geht oder muss eine eigene Staging-Environment haben, die genau gleich ist. Das ist mit Docker viel einfacher. Das mache ich lokal, updaten, schauen, ob alles funktioniert, Tests laufen durch, kann ich deployen, fertig. Also dieser Cycle ist auf jeden Fall viel viel einfacher und da spare ich glaube ich persönlich schon sehr viel Zeit. Das ist mein persönlicher Favourite. Hast du ein Favourite?",
      "start": 2570565,
      "end": 2643831,
      "confidence": 0.7633691588785047,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Spezifisch einen anderen Favourite hätte ich jetzt nicht, aber da würde ich schon mitgehen. Also es ist schon sehr einfach. Natürlich ist da auch der Teufel immer im Detail und ich möchte da nicht negativ drüber kommen, aber wenn die Applikation intern das Dateiformat ändert, welches du nach außen mit einem Docker-Volume aufs Host-System gemontet hast, dann kann es natürlich auch zu sehr vielen Problemen geben. Aber stimmt schon, du kannst halt schon da die Reifen von einem Formel-1-Wagen während des Rennens tauschen, meines Erachtens nach, wenn du ebenfalls noch eine Komponente davor hast mit Blue-Green-Deployments und solche Geschichten. Das geht halt schon. Und Zero-Downtime-Deployments, ich glaube schon, da hast du schon einen sehr, sehr guten Grund. Das ist es von uns soweit. Also das ganze Thema Docker und Container ist natürlich riesig. Und wir werden uns bemühen, in zukünftigen Episoden da ein bisschen tiefer einzusteigen. Wir haben das ganze Thema Docker jetzt noch gar nicht komplett beleuchtet. Also Themen, die wir in Zukunft auch anreißen werden, ist, wie überladen ist das Wort Docker eigentlich und was schließt das eigentlich ein? Reden wir hier von der Firma? Reden wir hier von einer Containerinstanz? Reden wir hier von einer Image? Oder wie sieht es eigentlich aus mit Docker Images? Was ist eigentlich die OCI, die Open Container Initiative? Kann ich Docker Images eigentlich auch mit anderen Applikationen wie zum Beispiel Podman laufen lassen? Ja, nein. Und wieso geht das überhaupt?",
      "start": 2643851,
      "end": 2716652,
      "confidence": 0.7856945606694568,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Oder warum Kubernetes nicht Docker verwendet?",
      "start": 2716692,
      "end": 2718632,
      "confidence": 0.7818333333333335,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Genau, was war da los mit dem Shitstorm, ne? Woraus besteht Docker eigentlich? Also die Docker-Komponenten. Was ist denn die Docker-CLI? Was ist Container-D? Was ist Run-C? Und so weiter. All das werden wir versuchen so ein bisschen in den nächsten Episoden zu beleuchten und vielleicht ein bisschen Zugänge euch dazu machen. Heute ging es nur um Docker. Was war das originale Problem von Docker?",
      "start": 2719112,
      "end": 2739946,
      "confidence": 0.8345999999999996,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Also nicht von Docker, sondern was Docker lösen wollte.",
      "start": 2739986,
      "end": 2742508,
      "confidence": 0.7586666666666667,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Und warum Duisburg eine essentielle Rolle im Container-Ökosystem spielt.",
      "start": 2743160,
      "end": 2748367,
      "confidence": 0.8644444444444445,
      "channel": null,
      "speaker": "A"
    },
    {
      "text": "Genau, und wenn ihr Feedback habt oder Vorschläge, was wir auch allgemein machen könnten oder im Docker-Umfeld oder wenn wir weniger über Duisburg sprechen sollen oder über mehr über Bremen zum Beispiel, weil die den besseren Hafen haben, dann bitte alles an stetisch.engineeringkiosk.de oder unter Twitter ENG Kiosk, solange es Twitter noch gibt. Und dann hören wir uns hoffentlich in alter Frische und hoffentlich endlich bei mir auch mit besserer Stimme in einer Woche.",
      "start": 2748387,
      "end": 2775415,
      "confidence": 0.7953918918918921,
      "channel": null,
      "speaker": "B"
    },
    {
      "text": "Und schaut wirklich mal in die Show nachts, da sind ein, zwei interessante Artikel, die das ganze Thema auf sehr einfache Art und Weise echt zugänglich machen. Also ich war auch sehr überrascht. Bis dahin, happy learning, bis bald. Ciao.",
      "start": 2775455,
      "end": 2784844,
      "confidence": 0.6937000000000002,
      "channel": null,
      "speaker": "A"
    }
  ],
  "confidence": 0.7954671541742848,
  "audio_duration": 2792.0,
  "webhook_status_code": null,
  "webhook_auth": false,
  "summary": null,
  "auto_highlights_result": null,
  "content_safety_labels": null,
  "chapters": null,
  "sentiment_analysis_results": null,
  "entities": null
}
