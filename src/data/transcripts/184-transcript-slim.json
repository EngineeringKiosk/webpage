{
  "language_code": "de",
  "audio_url": "https://cloud.inlupus.at/s/FqDFYP25m7nmzme/download/ep_gpu.mp3",
  "punctuate": true,
  "format_text": true,
  "dual_channel": false,
  "multichannel": null,
  "audio_channels": null,
  "webhook_url": null,
  "webhook_auth_header_name": null,
  "webhook_auth_header_value": null,
  "audio_start_from": null,
  "audio_end_at": null,
  "word_boost": [],
  "boost_param": null,
  "filter_profanity": false,
  "redact_pii": false,
  "redact_pii_audio": false,
  "redact_pii_audio_quality": null,
  "redact_pii_policies": null,
  "redact_pii_sub": null,
  "speaker_labels": true,
  "speakers_expected": 3,
  "content_safety": false,
  "content_safety_confidence": null,
  "iab_categories": false,
  "custom_spelling": null,
  "disfluencies": false,
  "sentiment_analysis": false,
  "auto_chapters": false,
  "entity_detection": false,
  "summarization": false,
  "summary_model": null,
  "summary_type": null,
  "auto_highlights": false,
  "language_detection": false,
  "language_confidence_threshold": null,
  "language_confidence": null,
  "speech_threshold": null,
  "speech_model": null,
  "id": "7c4464f4-2e17-4b7b-a0e1-e427fbd69c3d",
  "status": "completed",
  "error": null,
  "utterances": [
    {
      "text": "Andi, ich habe mal eine Frage an dich. Und zwar kürzlich habe ich mit meinem Neffen versucht, so einen neuen Computer zusammenzubauen und bin draufgekommen, irgendwie ist dasselbe, was in meiner Jugend noch in war, immer noch in. Man optimiert da irgendwie Grafikkarten, nur jetzt blinkt nur alles bunt in diesem komischen Gehäuse drin. Bei uns waren die Gehäuse noch geschlossen, jetzt sind es so transparente Gehäuse. Warst du auch so jemand, der früher optimiert hat und sich so eine spezielle Grafikkarte gekauft hat, um deine, keine Ahnung, was für Ballerspiele du da immer gespielt hast, früher spielen zu können?",
      "start": 0,
      "end": 30780,
      "confidence": 0.9242721,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Ja, und ich habe sogar teilweise versucht, damals die Taktfrequenz des Rams irgendwie ordentlich, ich sag mal, auszusuchen in dem Shop und allem drum. Heutzutage frage ich mich, hat das überhaupt damals eine Relevanz gespielt? Habe ich da überhaupt irgendwas gemerkt? Und jetzt habe ich mir aber auch mal moderne Hardware angesehen und habe festgestellt, ach du Kacke, Grafikkarten, die haben inzwischen eigene Stromanschlüsse und sind so groß wie, ich sag mal, ein Mainboard gefühlt. Also das ist alles so ein bisschen explodiert. Inzwischen habe ich davon Abstand genommen, weil das ist mir einfach viel zu kompliziert geworden. Du musst ja wirklich jede Woche irgendwie Toms Hardware Blog lesen, um überhaupt noch mal irgendwo klarzukommen, um zu wissen, was irgendwie so ein bisschen up to date ist. Also ich weiß es nicht mehr, aber ja, hatte ich auch mal. Aber warst du auch so ein Typ mit Wasserkühlung oder warst du immer noch mit Lüftern unterwegs?",
      "start": 30900,
      "end": 79004,
      "confidence": 0.9251041,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Also mein Neffe hat jetzt eine Wasserkühlung. Keine Ahnung, ob er das wirklich braucht. Ich bezweifle es mal, aber er wollte das unbedingt. Ich glaube, zu meiner Zeit hat es einfach keine Wasserkühlung gegeben, zumindest nicht im leistbaren Rahmen. Also wir hatten ganz klassische Kühler, die sich gedreht haben und die dann auch irgendwann Lärm gemacht haben. Aber meine eigentliche Frage ist ja, ich habe gerade jetzt kürzlich wieder mal auf den Nvidia Aktienkurs geschaut und so in den letzten fünf Jahren hat der ja eine Steigerung gehabt von %. Ist das der Grund, dass jetzt alle spielen, dass Nvidia so reich geworden ist?",
      "start": 79132,
      "end": 109530,
      "confidence": 0.93088144,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Die Beziehung musst du mir jetzt mal sagen. Also die machen ja Grafikkarten und wenn die Firma, die Grafikkarten macht, mehr wert ist, dann spielen alle.",
      "start": 109650,
      "end": 119640,
      "confidence": 0.93605846,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Ja, das ist jetzt meine Frage an dich.",
      "start": 119760,
      "end": 121272,
      "confidence": 0.98818374,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Du bist ja der Clé, er ist eher Fomo. So nach dem sollte ich vielleicht jetzt spielen.",
      "start": 121296,
      "end": 126184,
      "confidence": 0.84852296,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Und machst du es?",
      "start": 126312,
      "end": 127400,
      "confidence": 0.83718,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Ich würde gern, aber ich weiß ganz genau, wenn ich mir eine Konsole kaufen würde, eine Grafikkarte kaufen würde oder ähnliches, dann würde ich da so viel Zeit reinsetzen. Besonders wenn jetzt Civilization wurde gerade, glaube ich, neu released. Aber Die Frage ist ja, Nvidia Grafikkarten, geht es da um Spiele, geht es da um GPU Berechnungen, geht es um AI? Ich habe dieses Buzzword Bingo schon gesagt, um was geht es da?",
      "start": 127440,
      "end": 146830,
      "confidence": 0.8940323,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Ich wollte schon fast sagen, lebst du unterm Stein, wenn du jetzt mit deinen spielen um die Ecke kommst und nicht von AI sprichst, aber du hast dich noch mal gerettet, Andi. Also es ist ja gerade der große Hype um das ganze AI Game. Und da habe ich mir eigentlich mal gedacht, wir haben überhaupt noch nie irgendwie eine Episode zu GPU gehabt oder zur Programmierung, aber Grafikprozessoren. Und nachdem wir beide ja jetzt wenig in dem ganzen Bereich zu Hause sind, habe ich mir überlegt, OK, wer könnte uns da weiterhelfen und wer ist denn ein absoluter Spezialist in diesem Bereich? Und ich habe mich mal zurück, Carina, die kann mich erinnern, an der Uni vor, schätze mal so 20 Jahren oder so, haben wir teilweise auch so Öffentlichkeitsarbeitsevents gehabt für Jugendliche und so, dass die die Uni kennenlernen. Und da hat es jemanden gegeben, der damals vor 20 Jahren schon an GPUs herumgeschraubt hat und sich überlegt hat, wie kann man auf GPUs programmieren. Das war lang vor der Cuda Zeit. Und dann habe ich mir gedacht, eigentlich brauchen wir genau diese Person, weil die kann uns da weiterhelfen. Und es freut mich sehr, dass diese Person heute zu uns in das Podcast Studio gefunden hat, weil der Peter hat nicht nur vor 20 Jahren an dem Ganzen herumgearbeitet, sondern er arbeitet immer noch und hat jetzt 20 Jahre mehr Erfahrung in dem ganzen GPU Bereich und kann uns daher sicher perfekt weiterhelfen. Und damit willkommen, Peter.",
      "start": 146870,
      "end": 223536,
      "confidence": 0.9257301,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Ja, vielen Dank. Ich hilfe euch da hoffentlich und gerne weiter. Und ja, ich habe schon vermutlich länger mit GPUs programmiert und da General Purpose GPU Programming, wie wir es damals genannt haben, gemacht, als es empfehlenswert ist vielleicht.",
      "start": 223608,
      "end": 238624,
      "confidence": 0.9112528,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Ich ziehe meinen Hut vor jedem, der sich länger als fünf oder sechs Jahre mit einem Thema beschäftigt. Und wenn ich höre, dass jemand sich 20 Jahre mit GPU Programmierung beschäftigt, sage ich, OK, wow. Du bist inzwischen Professor in der Forschungsgruppe für verteilte und parallele Systeme an der Universität im schönen Innsbruck. Du hast deine Forschungsinteressen im Bereich GPU Computing, parallele Laufzeitsysteme und Compiler für HPC. Das ist glaube ich, High Performance Computing.",
      "start": 238672,
      "end": 265154,
      "confidence": 0.91901624,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Ja, genau.",
      "start": 265202,
      "end": 265778,
      "confidence": 0.99773,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Du unterrichtest advanced c GPU computing und Performance Oriented Computing. Du bist Mitgründer der PHC GmbH, die sich unter anderem mit der Portierung von Spielen beschäftigt, also ziemlich viel GPU Programmierung. Du machst Consulting im Bereich Optimierung von Algorithmen und warst an einem EU Projekt zur Medikamentenforschung beteiligt, wo ziemlich viel auch GPU Cluster genutzt wurden, zumindest für diverse Berechnungen. Wolfgang hat es gerade angeteasert, das ganze GPU Game machst du schon seit über 20 Jahren, bevor es CUDA gab. Was CUDA überhaupt ist, klären wir gleich noch. Und du schreibst oder hast ein paar Libraries in dem Bereich Parallel Computing, unter anderem eine high Level C API, die es ermöglicht, GPU Compute Cluster anzusprechen und nicht nur einzelne GPUs, die sich Celerity nennt. Und was wir im Vorgespräch noch herausgefunden haben, du bist Reddit Nerd mit knapp über Posts.",
      "start": 265874,
      "end": 331356,
      "confidence": 0.9065668,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Das ist auch richtig. Vielleicht hätte ich es nicht erwähnen sollen.",
      "start": 331548,
      "end": 333868,
      "confidence": 0.8216809,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Ich bin ja froh, dass da irgendwas normales in der Auflistung kommt, weil davor, das habe ich alles eigentlich nicht verstand. Es ist so ganz, ganz weit weg eigentlich, dieser ganze C hardwarenahe Programmierbereich. Also ich bin wirklich froh, dass du da bist, aber wenigstens bist du Reddit User. Das ist high level, da kann ich noch mithalten. Zwar nicht mit den Posts, aber zumindest mit ein paar Posts.",
      "start": 333964,
      "end": 355240,
      "confidence": 0.9430393,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Ich bin auch nicht sicher, ob es erstrebenswert ist, unbedingt mitzuhalten.",
      "start": 355400,
      "end": 358360,
      "confidence": 0.94596547,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Naja, es zeigt auf jeden Fall, dass du auch in der Community sehr stark involviert bist, abseits von den Libraries, die natürlich auch zur Verfügung stehen. Aber gehen wir mal gleich in das ganze Thema rein. Wie ich schon erwähnt habe, der ganze Bereich ist für mich relativ neu und man hört da ja super viele Schlagwörter. Also CUDA ist ja nur eines und von CUDA spricht irgendwie jede Person, wenn man über gpu Programmierung spricht. Aber es gibt natürlich auch ganz allgemein das verteilte Rechnen, parallele Rechnen, High Performance Computing ist auch noch so ein Schlagwort. Jetzt CUDA ist Nvidia, aber es gibt ja auch dann noch AMD irgendwie so, die irgendwo mitspielen, am Rande zumindest, die immer auch wieder behaupten, sie sind schneller als Nvidia. Also gibt es da auch Frameworks dafür. Dann habe ich so aus meiner Studienzeit auch noch so im Kopf openmp, OpenCL, wenn es darum geht, irgendwie verteilt etwas zu programmieren und schneller zu machen. Also ist schon lange her bei mir, aber scheinbar auch immer noch ein Thema. Vielleicht kannst du uns einfach mal so einen Rundumschlag geben, was es denn so gibt am Markt, was diese Begriffe bedeuten, worüber wir heute sprechen und worüber wir nicht sprechen und was jetzt wirklich die gpu Programmierung betrifft.",
      "start": 358440,
      "end": 426564,
      "confidence": 0.9295463,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Ja, sehr gerne. Also grundsätzlich, du hast ganz am Anfang angesprochen, verteiltes und paralleles Rechnen. Es gibt da natürlich eine große Überschneidung. Man kann grundsätzlich sagen, dass bei parallelen Rechnen meint man meistens, dass man den gleichen Algorithmus ausführt auf irgendeiner parallelen Architektur. Also sei das jetzt eine GPU oder sei es eine CPU mit mehreren Cores oder was ähnliches. Und bei distributed oder verteilten Berechnungen spricht man meistens von so was wie heutzutage Cloud Computing, wo man wirklich Tasks einfach asynchron irgendwo anders berechnen lässt. Und worum es, wenn wir jetzt von GPUs im speziellen reden, heute wirklich geht, sind mehr Algorithmen, die man einzeln verteilt auf einem parallelen Hardware System wie einem GPU. Dafür gibt es eben sehr, sehr viele Libraries und APIs und das bekannteste davon ist sicher CUDA.",
      "start": 426692,
      "end": 474618,
      "confidence": 0.9070309,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Das heißt aber, wenn ich jetzt irgendwie so ein Hardware Cluster habe mit Shared Memory, ist das dann distributed oder ist das parallel Programming?",
      "start": 474714,
      "end": 481914,
      "confidence": 0.8103283,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Das ist eine sehr spezifische Frage und eine sehr interessante auch vielleicht eine, die ein bisschen heutzutage out of date ist, weil niemand mehr Cluster mit Shared Memory baut.",
      "start": 482042,
      "end": 490430,
      "confidence": 0.9488897,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Du merkst, wie alt ich bin, im.",
      "start": 491330,
      "end": 494922,
      "confidence": 0.93257284,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Vergleich zu mir natürlich gleich. Aber ja, es gab früher diese großen Cluster mit Shared Memory, wo dann schon vorher 10 Jahren TB an RAM haben konnte und so. Es war natürlich sehr spannend. Die waren eigentlich auch immer parallel Systems. Also alles, was an einer Location steht, vielleicht im Endeffekt in einem Rechenzentrum, das wäre dann vielleicht eben wirklich high Performance Computing, was du vorher auch erwähnt hast. Aber es fällt unter diesen Parallel Programming Teil eher als distributed. Also natürlich ist der Speicher dann auch irgendwo distributed in so einem Cluster, aber wirklich von distributed parallelism redet man eigentlich erst dann, wenn es, wie soll man sagen, im geografischen Raum verteilt ist, bis zu einem gewissen Grad und nicht nur lokal.",
      "start": 494946,
      "end": 537170,
      "confidence": 0.90591407,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Und wenn wir von GPU sprechen, dann sind wir eigentlich immer im Parallel Programming, wenn ich die richtig verstanden habe.",
      "start": 597250,
      "end": 602402,
      "confidence": 0.91875,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Ja, man kann natürlich heutzutage GPUs verwenden in der Cloud, aber da ist Programmieren der GPUs deswegen kein Cloud Programmieren, sondern immer noch parallel Programming.",
      "start": 602466,
      "end": 611106,
      "confidence": 0.9287968,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Wenn ich jetzt mehrere GPUs habe in mehreren Servern, ist das dann parallel Distributed Computing?",
      "start": 611218,
      "end": 617222,
      "confidence": 0.95442265,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Technisch korrekt müsste man sagen, das wäre dann Distributed Memory Parallel Computing. Aber Distributed Computing in dem Sinne würde man es wahrscheinlich nicht nennen, weil das eben wirklich sich meistens auf sowas wie Cloud Computing bezieht oder sonst irgendwas, wo es weiter im Raum verteilt ist. Also wenn du jetzt in deinem Computer acht GPUs hast, haben die zwar separate Speicherbereiche, aber sie sind deswegen nicht distributed im normalen Sprachgebrauch, sagen wir mal.",
      "start": 617286,
      "end": 641526,
      "confidence": 0.9167052,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Aber ist das Aufsplitten eines Algorithmus bzw. Der Daten eines, was man da berechnet, macht man das anders, wenn man jetzt parallele Programmierung bzw. Distributed computing macht? Ne, ist doch eigentlich dieselbe Art von Datenaufteilung, oder? Ich meine, du hast einen Teilbereich, auf dem gerechnet wird und der wird halt nur anders verteilt. Entweder übers Netzwerk an eine andere computing Einheit irgendwo oder halt auf einer GPU an anderen, an eine andere Prozessor Unit.",
      "start": 641598,
      "end": 672906,
      "confidence": 0.8791587,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Oder aus einer sehr high level Perspektive ist das natürlich irgendwo wahr. Also algorithmisch betrachtet, ja, man würde es so aufteilen, aber in der Praxis trifft es nicht ganz zu, weil der große Unterschied ist eigentlich die Latenz. Und aufgrund dieser Unterschiede in der Latenz gibt es dann ganz unterschiedliche Strategien. Und es gibt einfach Algorithmen, die für eine dieser Vorgehensweisen geeignet sind und welche, die für eine andere geeignet sind. Also im Distributed Computing hat man Latenzen, die zumindest in, sagen wir mal, minimal zumindest Millisekunden gemessen werden. Meistens einige Millisekunden, sagen wir mal, parallel computing Mikrosekunden oder in dem Bereich. Also wir haben dann Faktor 1000 in der Latenz und der ändert einfach komplett, was für Algorithmen man wo ausführen kann.",
      "start": 672938,
      "end": 716122,
      "confidence": 0.9239172,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Und wenn wir von Latenz sprechen, sprechen wir wirklich, okay, ich schiebe jetzt Daten übers Netzwerk und da muss jemand was entgegennehmen und so. Der ganze Hack Mac, der da halt dazu kommt.",
      "start": 716226,
      "end": 723594,
      "confidence": 0.8763,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Genau, genau.",
      "start": 723642,
      "end": 724370,
      "confidence": 0.955005,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Ist ja auch der Speicherzugriff, oder? Wenn jetzt plötzlich irgendwie, also die verschiedenen Prozesse können ja nicht so einfach auf denselben Speicherbereich zugreifen, wenn sie verteilt irgendwo in der Welt herum verteilt sind. Eben, ja.",
      "start": 724490,
      "end": 737554,
      "confidence": 0.9045974,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Also sobald wir distributed Memory haben, dann ist eigentlich Speicherzugriff ja auch wirklich Versenden von Daten. Also das ist dann mehr oder weniger die gleiche Latenz, beziehungsweise potenziell sogar mehr.",
      "start": 737642,
      "end": 748994,
      "confidence": 0.942906,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Jetzt, wenn wir ins Parallel Programming einsteigen. Und ich habe schon ein paar Schlagwörter erwähnt, kannst du uns die mal aufdröseln, was es da so gibt und was dann auch die gpu Programmierung betrifft?",
      "start": 749082,
      "end": 761100,
      "confidence": 0.8977041,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Ja, also du hast einige Dinge erwähnt, wie gesagt, CUDA, sehr weit verbreitet von Nvidia für ihre GPUs entwickelt, fürs programmieren ihrer GPUs und inzwischen verwenden sie das als Überbegriff für so viele Technologien, dass wir gar nicht auf alle eingehen können. Aber es ist halt das Softwarepaket, das Nvidia zur Verfügung stellt, was du auch erwähnt hast, was man vielleicht kurz erwähnen sollte ist, OpenMP hat jetzt a priori nichts mit GPUs zu tun, gibt es schon länger als GPU Computing, aber es ist ja ein Interface, um leichter, sagen wir mal, Algorithmen parallelisieren zu können. Früher nur auf CPUs, inzwischen auch auf GPUs. Und das ist ein standardisiertes Interface, was von verschiedenen Compilern implementiert wird. Es gibt dann von diversen Herstellern ihre Konkurrenzprodukte zu CUDA, von AMD wäre das RockM heutzutage und von Intel gibt es Level Zero und es gibt auch noch weitere Dinge von AMD. Also da kann man jetzt genau auf einen Begriff deuten, aber es gäbe auch noch HIP. Und bei Intel gibt es eigentlich kein higher Level Interface, aber sie unterstützen das offene Format SICKL von Kronos und das ist wieder weiterer Begriff, also sollte vielleicht auch darauf eingehen. Vielleicht kennen manche OpenGL Grafik Library für Grafikprogrammierung, das ist auch von der Kronos Gruppe, das ist so Industriekonsortium, die versuchen interessante Standards zu setzen, die dann von verschiedenen Hardwareherstellern implementiert werden können. Und der für GPU Computer von der neue heißt Zykl und der ältere wäre OpenCL.",
      "start": 761180,
      "end": 847036,
      "confidence": 0.9015995,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Und wenn ich jetzt openmp z.B. verwende, um GPUs anzusprechen, dann greift OpenMP wieder darunter auf Cuda zu oder wie funktioniert das?",
      "start": 847148,
      "end": 856220,
      "confidence": 0.88998455,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Das hängt dann davon ab, wie man es kompiliert und was genau für einen Compiler man verwendet und was der dahinter macht. Aber der wird dann potenziell CUDA verwenden oder zumindest das sogenannte PTX Format generieren für die eigentlichen Programme, die am GPU laufen. Das ist intermediate Format für GPU Programme von Nvidia und das gleiche würde generieren für alle anderen unterstützten Hardware architekturen.",
      "start": 856340,
      "end": 881144,
      "confidence": 0.93147045,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Jetzt hast du erwähnt Interface, OpenMP stellt so ein Interface zur Verfügung. Wie kann man sich das vorstellen? Ist jetzt ein bisschen schwierig natürlich, ohne da irgendwie Code zu zeigen, aber Interface ist für mich einfach so Funktionskopf. Wie funktioniert das in OpenMP oder auch.",
      "start": 881192,
      "end": 896362,
      "confidence": 0.8855151,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "In CUdA z.B. ja, da unterscheiden sich die Technologien jetzt doch ein bisschen. Also in OpenMP im Speziellen funktioniert es so, dass man mehr oder weniger Annotationen an seinen Code dran schreibt. Also das kann man sich vorstellen so ähnlich wie Kommentare, nur dass der Compiler sie halt interpretieren kann bis zu einem gewissen Grad. Also z.b. wenn man irgendeine Schleife hätte in seinem Programm, dann schreibt man bei OpenMP einfach im einfachsten Fall über die Schleife drüber pragma openmp parallel und dann weiß OpenMP, dass diese Schleife parallel sein soll und parallelisiert sie.",
      "start": 896386,
      "end": 926510,
      "confidence": 0.92643714,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Das heißt, ich muss gar nicht genau spezifizieren, wie. Das macht im Idealfall die Library für mich, dass dann jeder Run von dieser Schleife in irgendeiner Form auf einem anderen CPU Core oder so gerechnet wird.",
      "start": 926550,
      "end": 938382,
      "confidence": 0.91871834,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Das ist die Grundidee von OpenLB. Und für, sagen wir es mal, Programm, wo du in jeder Iteration deiner Schleife genug Arbeit machst und wo du es nur auf CPUs verteilen willst, kann das auch in der Praxis sehr gut funktionieren. Es wird natürlich dann bei schwierigeren Situationen meistens schwieriger, aber das ist die gute Idee.",
      "start": 938486,
      "end": 954424,
      "confidence": 0.9121961,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Jetzt sind wir bekannt für die Bullshit Bingo Karte, oder in dem Fall ist es weniger Bullshit, aber für die Bingo Karte würde ich mal sagen. Opencl haben wir als Begriff noch offen. Wo kann man den einordnen?",
      "start": 954472,
      "end": 964824,
      "confidence": 0.9204776,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Ja, OpenCL ist auch ein Standard von Kronos, also von diesem Industriekonsortium und schon älter, also es gibt fast so lang wie Cuda. Ich würde sagen, es ist jetzt nicht mehr so weit verbreitet und auch nicht so erfolgreich, weil es nie so richtig von allen Hardwareherstellern gut unterstützt worden ist. Wie gesagt, der neuere Standard von dem gleichen Industriekonsortium wäre eben dieses SICK.",
      "start": 964872,
      "end": 988066,
      "confidence": 0.9002689,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Ich finde es schön, weil wenn ich nach OpenCL google, dann kommt als zweites Suchergebnis, bei mir ist OpenCL immer noch relevant, eine Frage auf Reddit und das hast du ja gerade mehr oder weniger bestätigt. Die weitere Frage, die ich habe.",
      "start": 988178,
      "end": 1002130,
      "confidence": 0.95314074,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Und schon wieder neuer Post, den Beta machen kann, relevanter.",
      "start": 1002130,
      "end": 1005890,
      "confidence": 0.868202,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Ja, ich leite den gerne weiter für deinen und ersten Antwortpost. Jetzt haben wir hier gerade ziemlich viele Buzzwords gedroppt und wenn ich danach google, wenn ich nach OpenMP google, finde ich auch Open MPI. Ist das die größte Confusion, die man haben kann in der Search Engine Optimization Welt? Open MPI und OpenMP ist nämlich, glaube ich, nicht das gleiche. Das eine wird beschrieben als openmp API Specification for parallel programming und das andere wird beschrieben als Open Source High Performance Computing.",
      "start": 1006390,
      "end": 1039246,
      "confidence": 0.89324194,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Ja, das ist eine sehr interessante Sache, die du da gefunden hast. Eine, über die sich mein Kollege Philipp immer sehr ärgert, der diese Sachen unterrichten muss direkt. Es ist so, MPI ist ein Standard, um Distributed Memory Cluster zu programmieren und hat nichts mit OpenMP zu tun, natürlich a priori. Openmpi ist eine Implementierung von diesem Standard und hat bis auf einen Charakter den gleichen Namen wie OpenMP, aber ansonsten nichts damit zu tun. Aber nicht gar nichts, was eigentlich besser wäre, sondern sind trotzdem beide für etwas relativ ähnliches, aber grundverschiedenes gebaut. Also ja, etwas verwirrend.",
      "start": 1039358,
      "end": 1077032,
      "confidence": 0.95075357,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Ja, ich klassifiziere das unter naming is hard oder ich verschwende einfach keinen weiteren Gedanken auf Naming, aber.",
      "start": 1077096,
      "end": 1084628,
      "confidence": 0.9027661,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Oder es war absichtlich, um da die Klicks oder die Besucher abzugrasen.",
      "start": 1084684,
      "end": 1089076,
      "confidence": 0.9464033,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Beide dieser Technologien sind so alt, dass ich sagen würde, sind so sehr auf SEO gegangen, das hat es damals noch nicht gegeben. Weiß eher nicht.",
      "start": 1089108,
      "end": 1096480,
      "confidence": 0.8935885,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Ich nehme an, alle hatten nur Gutes im Sinne, deswegen unterstellen wir da nichts Böses. Meine Frage ist jetzt aber, das bedeutet immer, wenn ich etwas auf meiner Grafikkarte laufen lassen möchte, auf der GPU, muss ich eins dieser Frameworks oder APIs verwenden. Also kurzum, und das wäre dann die Folgefrage, jedes Spiel, was ich irgendwie habe, hat das CUDA oder openmp oder. Klar, OpenGL hattest du gerade schon genannt. Ich weiß gar nicht, ob OpenGL und. Ne, OpenGL war der Nachfolger von Directd oder sowas, gab es ja auch noch mal. Naja, meine Frage ist eigentlich, brauche ich die unbedingt, oder. Also hat jedes Spiel irgendwie eine dieser Libraries integriert?",
      "start": 1096860,
      "end": 1137230,
      "confidence": 0.91152674,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Nein, also es gibt sehr, sehr wenig Spiele in der Geschichte von Spielen, die irgendeins dieser Libraries integriert haben, weil das alles GPU Compute Libraries sind und nicht Libraries für Grafik. Also natürlich kommen GPUs aus der Grafikschiene, aber es ist dann eben, hat sich herausgestellt, dass man auch andere Berechnungen ganz gut drauf machen kann. Und dadurch sind dann diese ganzen Libraries und Technologien, von denen wir jetzt gesprochen haben, entstanden. Spiele verwenden grundsätzlich hauptsächlich Rendering APIs, aber.",
      "start": 1137660,
      "end": 1163742,
      "confidence": 0.89490306,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Ich meine so die Berechnung von Raytracing und Co. Kann man doch eigentlich auch relativ einfach, und das ist jetzt hier in Anführungszeichen mit relativ. Also für mich ist auf der GPU gar nichts, einfach weil ich damit noch nie gearbeitet habe. Aber so Raytracing ist doch auch nur klassische Berechnung. Ich schieße strahlen durch den Raum und gucke, treffe ich irgendwas und wann treffe ich es und so.",
      "start": 1163766,
      "end": 1185118,
      "confidence": 0.92724824,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Du könntest es mit diesen APIs implementieren, das wäre dann aber sehr langsam im Vergleich, weil GPUs haben spezielle Hardwareeinheiten, um so etwas wie Raytracing durch eine klassische Grafik mit Rasterisation zu beschleunigen. Und diese spezielle Hardware könntest du nicht verwenden mit diesen generischen Compute APIs, von denen wir jetzt bisher gesprochen haben. Dafür bräuchte man sowas wie, es gibt eigentlich nur zwei Möglichkeiten, entweder DirectX oder Vulkan, was ein weiterer Kronos Standard ist, aber in dem Fall für GPU Grafik Programmierung.",
      "start": 1185254,
      "end": 1213762,
      "confidence": 0.87727755,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Jetzt muss ich nur noch mal, weil Andi da OpenGL eingeworfen hat, also OpenGL ist schon noch die offene Variante und hat mit DirectD wenig zu tun, oder?",
      "start": 1213826,
      "end": 1221494,
      "confidence": 0.9204811,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Oder habe ich falsch im Kopf? Das ist richtig.",
      "start": 1221562,
      "end": 1223518,
      "confidence": 0.81469667,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Also bin ich schon noch mit meinem Open Source Gedanken im richtigen Universum.",
      "start": 1223694,
      "end": 1227934,
      "confidence": 0.9115238,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Die Relation zwischen OpenGL und Vulkan ist auch so, dass OpenGL eigentlich mehr oder weniger bis zum gewissen Grad von Vulcan abgelöst wurde. Nicht zu 100, %, weil sehr viel näher an der Hardware und bis zu einem gewissen Grad komplexer ist. Aber heutzutage, wenn man high End Grafikprodukt entwickelt, dann verwendet man entweder Walken oder Direct d oder Metal, wenn man auf Apple programmiert. Habe ich noch nie verwendet, aber das.",
      "start": 1227982,
      "end": 1252162,
      "confidence": 0.8876568,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Ist wie gesagt, hartes Wortgame. Wenn wir gerade haben wir OpenMP, OpenMPI gesagt und jetzt gerade haben wir über OpenGL und OpenCL gesprochen. Also ich weiß nicht, so langsam könnte das auch Absicht sein, aber kannst du.",
      "start": 1252186,
      "end": 1266610,
      "confidence": 0.93929297,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Mal erklären, jetzt hast du schon gesagt, es ist aus der Gaming Welt gekommen, wann ist es entstanden und warum hat man überhaupt dann auf GPUs gesetzt? Also es gibt die CPU und die kann ja auch schnell rechnen und das meiste funktioniert ja auf der CPU. Also warum gab es überhaupt die große Änderung, dass man da auf GPU plötzlich gegangen ist? Weil es ist ja auch eine ganz andere Architektur.",
      "start": 1266650,
      "end": 1290678,
      "confidence": 0.9461567,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Ja, also ich würde sagen, wie du schon ganz am Anfang mal kurz erwähnt hast, vor inzwischen ungefähr 20 Jahren haben eigentlich in erster Linie Forscher mal festgestellt, dass diese Grafikkarten, dass jetzt zum ersten Mal damals beliebige Berechnungen in sogenannten Pixel Shadern machen können. Also man ist draufgekommen, d Rendering, man will immer interessantere Eigenschaften von D Objekten darstellen dann im Endeffekt. Und um Programmierern da zu erlauben, das besonders flexibel zu machen, hat es ihm dann die Möglichkeit gegeben, diesen Prozess zu programmieren, mit am Anfang extrem kurzen Programmen, die halt maximal, sagen wir so was wie 20 Hardware Instruktionen haben dürfen oder so.",
      "start": 1290774,
      "end": 1331048,
      "confidence": 0.88497216,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Kannst du mal erklären, was Shader grundsätzlich ist? Weil für mich kommt ja von Schatten, oder? Das Wort.",
      "start": 1331104,
      "end": 1339048,
      "confidence": 0.91197777,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Ja, also wenn du dir vorstellst, du willst irgendein Objekt darstellen in D Rendering, dann hat das eine Oberfläche und du musst irgendwie beschreiben, wie diese Oberfläche im Endeffekt dargestellt wird. Ganz einfach gesprochen, was für Farbe kriegt das Pixel ganz am Ende, das auf dieser Oberfläche sich befindet. Und eben um dieses Pixel einzufärben in einer flexiblen Art und Weise, hat man sogenannte Shader erfunden, was eben diese kurzen Programme sind, die beschreiben, wie das Pixel eingefärbt werden soll, auf Basis von so Inputs wie einer Textur z.B. natürlich, aber so was wie, aus welcher Richtung kommt das Licht her und wie soll das weiterverarbeitet werden?",
      "start": 1339224,
      "end": 1376342,
      "confidence": 0.90022,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Und das Programm wird dann wirklich für jeden einzelnen Pixel einmal aufgerufen. Also wenn ich da so eine hd Auflösung habe, ich weiß nicht, wie viele Millionen Pixel das dann da sind, dann wird das kleine Programm x Millionen mal aufgerufen, um ein Bild zu generieren.",
      "start": 1376446,
      "end": 1390880,
      "confidence": 0.92103,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Ja, genau so ist es auch, aber eigentlich nur, wenn dein Programm extrem optimiert ist, weil es ist so, dass du das nicht nur für jedes Pixel aufrufen musst, was du im Endeffekt siehst, sondern auch für alle, die verdeckt sind. Also aus der Perspektive wird es sogar noch sehr viel öfter aufgerufen im Normalfall, aber ja, und das ist auch genau der Punkt. Deshalb, weil sie dafür ausgelegt waren, solche Berechnungen auf so vielen Pixeln durchzuführen, eignen sich GPUs eben irgendwie von der Hardware heraus inhärent gut, extrem datenparallele Berechnungen durchzuführen, wie z.b. auf diesen Pixeln.",
      "start": 1390960,
      "end": 1422866,
      "confidence": 0.919446,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Und wie viel Berechnungen können da dann durchgeführt werden oder wie viel Pixel können parallel berechnet werden?",
      "start": 1422978,
      "end": 1428530,
      "confidence": 0.91619116,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Das ist eine etwas kompliziertere Frage, weil um sie wirklich korrekt zu beantworten, müssen wir jetzt sagen, wie viel Pixel werden parallel in der Hardware gleichzeitig berechnet, was von sehr vielen Faktoren abhängt. Man startet beim GPU grundsätzlich aus der User Perspektive, also Programmierer meine User Perspektive, alle Pixel gleichzeitig. Also vom Programmiermodell her geht man davon aus, dass alle diese Berechnungen gleichzeitig laufen. Wirklich in der Hardware läuft dann gewisser Bruchteil dieser Berechnungen wirklich parallel, aber die Hardware kann extrem schnell zwischen den verschiedenen Berechnungen hin und herschalten und man kann das eigentlich von außen nicht beeinflussen.",
      "start": 1428650,
      "end": 1467138,
      "confidence": 0.908719,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Und in welcher Größenordnung bewegt sich das ganze? Also klassischer, ich weiß nicht, kann man es vergleichen, CPU kann nur eine Sache parallel rechnen oder ich habe halt sechs Cores, können sechs Sachen parallel berechnet werden?",
      "start": 1467234,
      "end": 1478886,
      "confidence": 0.92575026,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Ja, also von modernen high End GPU bewegt sich das im Bereich, sagen wir mal hunderte bis tausende Pixel, die wirklich parallel gleichzeitig laufen.",
      "start": 1478958,
      "end": 1489050,
      "confidence": 0.9380725,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Das bedeutet, so eine Grafikkarte hat dann auch so eine Art Scheduler, weil du hast gerade gesagt, okay, man schmeißt jetzt einfach alle Millionen Pixel irgendwie rein und klar, das Ding hat irgendwie nur eine worker Kapazität, nenne ich das jetzt mal ganz simpel. Und die Grafikkarte bzw. Die GPU vielleicht sogar, das weiß ich jetzt gerade nicht, ob das die GPU wirklich ist oder ob das jetzt irgendwie ein anderer Chip ist, der hat dann so eine Art, sag mal Scheduler wie bei der CPU eigentlich.",
      "start": 1489390,
      "end": 1512530,
      "confidence": 0.9147382,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Ja, genau. Also jede Recheneinheit, es ist ja auch so, dass man sagen kann, bei der GPU, sie hat sozusagen mehrere Cores, nur jeder dieser Cores kann dann noch einmal sehr viel parallel berechnen in so einer Art vektorisierten Vorgehensweise. So ähnlich wie auch ein CPU Core, nur noch viel paralleler. Und jeder dieser Cores hat eigentlich eine Hardware Scheduling Einheit, die aktiv die wirklichen Pixel oder auch Berechnungen, je nachdem was man gerade darauf macht, auf diese Hardware scheduled.",
      "start": 1512610,
      "end": 1539220,
      "confidence": 0.9312552,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Dann wäre jetzt meine naive warum verwendet man überhaupt noch CPUs? Wenn GPUs viel schneller sind, könnte man ja nur mehr GPUs verwenden.",
      "start": 1539300,
      "end": 1546164,
      "confidence": 0.8645596,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Sehr gute Frage. Und es läuft eben aufs Gleiche raus, dass die GPUs dafür entwickelt wurden, eine Sache extrem gut zu können, nämlich diese Pixel einfärben, original betrachtet. Und was man dafür z.B. braucht, ist extrem hoher paralleler Durchsatz von Berechnungen. Was man dafür in Bezug auf die Hardwarearchitektur benötigt, ist sehr hohe Speicherbandbreite z.B. was man dafür nicht unbedingt braucht, ist z.B. sehr niedrige Latenz bei Zugriffen. Was man auch nicht braucht, ist, dass man ganz leicht in z.B. nebeneinander liegenden Pixeln verschiedene Pfade durchs Programm wählen kann. Also dass z.B. in einem Pixel irgendein if true wird und im anderen false. Das kann ab und zu mal passieren, aber normalerweise laufen die alle sehr konvergent durchs Programm durch. Und deswegen sind GPUs sehr gut, wenn man diesen extrem hohen Grad an Parallelismus mit relativ einfachen Zugriffsmustern hat, relativ einfachen Algorithmen. Aber sie werden potenziell extrem langsam im Vergleich zu CPUs, wenn man komplexeres Zugriff Muster hat oder ein Algorithmus, wo man nicht vorhersehen kann, in welche Richtung der als nächstes geht, also wie das Programm sich verhält.",
      "start": 1546292,
      "end": 1615588,
      "confidence": 0.9092634,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Aber heißt es dann, dass ich kein if programmieren darf in dem Sinne?",
      "start": 1615684,
      "end": 1619536,
      "confidence": 0.88405,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Du darfst ein if programmieren, aber wenn dein if dann wirklich, sagen wir mal, in einem Schachbrettmuster in jedem Pixel anders sich verhält, dann kannst du auf dem GPU halt potenziell plötzlich nur mehr zweiunddreißig der Performance haben, die du sonst gehabt hättest. Und am CPU ist es eh egal.",
      "start": 1619668,
      "end": 1636552,
      "confidence": 0.9304916,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Das liegt dann am Caching, oder woran liegt das? Oder dass die möglichen Ergebnisse wirklich so komplett unterschiedlich sind oder die möglichen Berechnungssteps? Oder woran liegt das?",
      "start": 1636696,
      "end": 1644808,
      "confidence": 0.94715184,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Das liegt primär daran, dass die Programmierung von GPUs gaukelt dir eigentlich mehr oder weniger vor, dass du diese ganz tausenden an Cores jetzt ansprichst, aber in Wirklichkeit sind es eigentlich keine Cores, sondern nur einzelne Lanes in einer Vektoreinheit, wie man sie am CPU hätte. Und die müssen eigentlich alle das gleiche machen, weil was anderes kann die Hardware nicht. Also sobald du dann im Programm in eine Situation reinlaufen würdest, wo diese zwei und dreiig oder 64 oder was auch immer Einheiten in dieser großen Vektoreinheit was verschiedenes machen, läuft das Programm nicht mehr effizient, weil es muss ja dann entweder hintereinander in der Zeit durchführen oder sonst sich irgendwas überlegen. Der Scheduler am GPU bedeutet das jetzt.",
      "start": 1644864,
      "end": 1687934,
      "confidence": 0.8929378,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Praktisch gesprochen, wenn ich jetzt einen komplexen Algorithmus habe, der ziemlich viele verschiedene Pfade hat, dass dieser dann, und innerhalb der ziemlich verschiedenen Pfade werden immer andere Berechnungsteile ausgeführt, wirklich andere Operationen, dass dieser dann wohlmöglich nicht so performant abläuft, weil der halt, wie du sagtest, schachbrett mustertechnisch, je nachdem welcher Pfad da gerade angesprochen wird, halt komplett anders verlaufen kann.",
      "start": 1687982,
      "end": 1714864,
      "confidence": 0.9135488,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Ja, also wenn du wirklich einen Algorithmus hast, der sehr viel verschiedene Pfade erstens hat und das ist wichtig, auch nimmt, weil es hängt schon davon ab, was passiert wirklich zur Laufzeit dann, ja, dann wird er vermutlich nicht besonders gut performen. GPU, natürlich kannst du da verschieden vorgehen, um das vielleicht zu optimieren. Also z.b. wenn wir es wieder von Pixel sprechen oder eben auch von den Threads, die da im Endeffekt am GPU laufen. Wenn die, die nebeneinander ausgeführt werden, den gleichen Pfad durchs Programm wählen, dann können sie wieder effizient laufen. Also wenn du irgendwie die Möglichkeit hast, die anders anzuordnen, dann könnte ich vielleicht doch bessere Performance und GPU erzielen, aber das ist dann absolut nicht mehr trivial. Auf jeden Fall.",
      "start": 1714952,
      "end": 1755542,
      "confidence": 0.8843187,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Du hast zuerst erwähnt, dass Speicherbandbreite hoch ist, aber die Speicherlatenz nicht niedrig oder auch hoch in dem Fall, also negativ hoch. Wie funktioniert das? Weil grundsätzlich muss das ja schon schnell sein, da wird ja auch viel herumgeschaufelt wahrscheinlich. Also warum ist der Latenz dann unwichtig?",
      "start": 1755606,
      "end": 1774566,
      "confidence": 0.9339245,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Genau, könnte diese Frage vermutlich nur jemand beantworten, der wirklich in der Hardware drin ist, was es nicht mein Bereich ist, aber grundsätzlich einfach so, dass man eben speicher Hardware im Endeffekt optimieren kann, auch den Speichercontroller auf Durchsatz oder auf Latenz. Natürlich ist beides wichtig, aber wie alles im Engineering gibt es dann Trade off und GPUs gehen mehr in die Richtung Trade off, mehr Bandbreite, höhere Latenz und CPUs gehen mehr in die Richtung Trade off, weniger Bandbreite, dafür niedrigere Latenz und das im ganzen Speichercontroller und auch im Cache und dem Speicher selbst.",
      "start": 1774678,
      "end": 1806654,
      "confidence": 0.899592,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Aber GPU ist schon noch mal schneller als jetzt, keine Ahnung, RAM Zugriff oder so. Also da liegen dann schon noch mal welten dazwischen, oder?",
      "start": 1806822,
      "end": 1815056,
      "confidence": 0.9477756,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Da muss ich jetzt ein bisschen ausholen. Gerne. Also CPUs und GPUs haben beide Cache bzw. Auch mehrere Levels an Cache. GPUs und CPUs haben auch beide RAM. Also wenn wir jetzt den RAM am GPU den VRAM sozusagen auf der einen Seite haben und auch den klassischen Hauptspeicher auf der CPU Seite. Und grundsätzlich normalerweise in einem normalen PC System ist es so, dass der CPU signifikant mehr RAM zur Verfügung hat, aber weniger Bandbreite zu diesem RAM und dass der CPU pro Thread, den er ausführt, signifikant mehr Cash zur Verfügung hat. Der GPU hat gesamt viel mehr Cash, das ist richtig, aber er führt ja auch gleichzeitig sehr, sehr viel mehr Threads aus. Das heißt, jeder Thread, der am GPU läuft, hat eigentlich Zugriff auf weniger Cash.",
      "start": 1815128,
      "end": 1862186,
      "confidence": 0.88927877,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Und was ich mich noch erinnern kann, so aus alten Tagen, was es auch immer geheißen hat, dass sie auf der GPU nicht springen kann. Also das ist auch sehr tödlich, wenn ich irgendwo im Speicher herumspringe. Stimmt das noch?",
      "start": 1862378,
      "end": 1875804,
      "confidence": 0.91083825,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Das hat früher sehr gestimmt, also da war es richtig tödlich und inzwischen stimmt es eigentlich auch immer noch. Also wenn du wirklich die maximale Bandbreite erzielen willst am GPU von Speicherzugriffen, dann brauchst du sehr spezifisch designte Speicherzugriffe, die optimal den Speichercontroller ausnutzen. Aber die Auflagen sozusagen, um diese hohe Bandbreite zu erzielen ans Programm, sind weniger kompliziert oder streng heutzutage, als wir jetzt noch vor 10 Jahren oder sowas waren. Also man hat da als Programmierer hat man es etwas leichter, gute Performance aus dem Speichercontroller zu holen am GPU heute als vor 10 Jahren, sagen wir mal.",
      "start": 1875972,
      "end": 1915878,
      "confidence": 0.9017975,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Jetzt hört man immer, dass CPUs immer schneller, schneller, schneller wurden. Und da stelle ich mir natürlich gerade die Frage, wenn wir jetzt kein AI Modell trainieren wollen, was ist denn eigentlich mal ein guter Use Case für eine GPU? Und wenn ich jetzt keine Grafikengine ändern möchte, sondern wenn wir einen klassischen Algorithmus darauf laufen lassen, was würdest du sagen ist der Stereotypenalgorithmus, den man einer GPU geben würde?",
      "start": 1915934,
      "end": 1936742,
      "confidence": 0.92311287,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Ja, also der Stereotypenalgorithmus würde ich sagen, der trifft jetzt nicht mehr zu, weil du schon gesagt hast, du willst keine AI drauf laufen lassen. Und der Stereotypenalgorithmus wäre natürlich Matrix Multiplikation und das was die Leute heutzutage AI nennen, ist auch Matrix Multiplikation. Also der läuft natürlich gut drauf. Ansonsten auch viele Algorithmen, die jetzt so in der Simulation verwendet werden, in der klassischen wissenschaftlichen, physikalischen Simulation z.B. oder chemischen Simulation, die sogenannte Stencil algorithmen sind. Also eigentlich Algorithmen, wo man auf gewisse, den zukünftigen Zustand an einen gewissen Punkt ausrechnen, auf Basis von drumherum liegenden Punkten oder sowas. Also Dinge mit vorhersehbaren Speicherzugriffen und Berechnungen mehr oder weniger.",
      "start": 1936886,
      "end": 1980394,
      "confidence": 0.8914257,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Also das klingt aber alles nach irgendwie so räumlichen Konzepten immer. Auch wenn ich jetzt irgendwas wissenschaftliches vorher berechnen will, da ist immer irgendwie eine Matrix oder d Raum, d Raum. Also es ist schon irgendwie. Kann man immer wieder auf dieses Grafikproblem zurück mappen oder gibt es auch andere Bereiche, die man gut machen könnte?",
      "start": 1980522,
      "end": 1999728,
      "confidence": 0.93765426,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Also man kann natürlich auch, wie man z.b. jetzt an diesen large language models sieht, man kann ja auch einen Satz im Endeffekt in der Matrix mappen, wenn man sich genug anstrengt. Aber ja, man muss seine Probleme grundsätzlich in d d oder d, sagen wir mal Speichergefüge einbetten können irgendwie. Ansonsten wird die Performance sehr viel schlechter. Also auch so was wie wenn das Problem ist da von Baumstruktur arbeitet oder sowas, dann willst du im Endeffekt trotzdem irgendwie diese Baumstruktur einbetten können in den eindimensionalen Speicher z.B. und dann halbwegs effizient darauf zugreifen können. Und je weniger direkt, sagen wir mal, sich ein Problem in diese klassischen D d Muster einordnen lässt, umso schwieriger wird es, ein effizientes GPU Programm für das Problem zu schreiben.",
      "start": 1999874,
      "end": 2045890,
      "confidence": 0.90919125,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Ich stelle mir gerade die kann man nicht jedes Problem auf ein räumliches Problem rummappen?",
      "start": 2045970,
      "end": 2050434,
      "confidence": 0.962198,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Also wenn wir jetzt gerade vom Speicherzugriff sprechen, dann ist die Antwort jedes Problem ist immer eine schwierige Frage. Sagen wir jedes Problem, was du auf dein CPU ausrechnen kannst. Ja, weil natürlich im Endeffekt ist dein Speicher auch nur Sequenz von durchnummerierten Bytes. Also es ist ja d Datenstruktur. Aber die Sprünge sozusagen werden dann halt so komplex, dass es irgendwann sich nicht mehr effizient auf den GPU übertragen lassen würde. Da ist immer die Unterscheidung zwischen was ist möglich und was ist in irgendeiner Weise sinnvoll.",
      "start": 2050482,
      "end": 2075542,
      "confidence": 0.9047431,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Naja, nehmen wir jetzt einfach mal das da gibt es ja dieses Traveling Salesman Problem. Kann man jetzt dieses.",
      "start": 2075606,
      "end": 2082708,
      "confidence": 0.92219687,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Ich sag mal, Andi, wenn du so gescheit um die Ecke kommst mit so Beispielen, kannst du das jetzt erklären auch noch?",
      "start": 2082804,
      "end": 2089360,
      "confidence": 0.8878541,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Das ist glaube ich, was ist der optimalste Weg, alle Punkte zu besuchen? Ist das richtig? Ein kombinatorisches Optimierungsproblem? Du hast keine Ahnung, irgendwie 15 Städte in Deutschland. Was ist der optimalste Weg, alle Städte zu besuchen? Das ist glaube ich der Trail. Das ist glaube ich das Problem, richtig?",
      "start": 2089740,
      "end": 2106680,
      "confidence": 0.8964324,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Hätte jetzt so spontan gesagt. Klingt richtig.",
      "start": 2107060,
      "end": 2109680,
      "confidence": 0.8941129,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "So und das funktioniert zwar vielleicht mit 15 Städten, ne? Was ist die kürzeste Route? Genau, ich glaube, was die kürzeste Route von. Wenn du alle Punkte berechnen möchtest. Und ich glaube bei 15 Städten gibt es schon, ich habe gerade hier Wikipedia sogar auf eins, zwei, drei, 43 Milliarden Möglichkeiten so und dann geht das natürlich mit 16 Städten ziemlich hoch, alles gut. So und das ist natürlich ein relativ schwieriges Problem für eine CPU. Und meine Frage ist jetzt, wenn wir von jedem Problem sprechen, könnte man das jetzt nicht irgendwie auch auf Matrix, auf eine Matrix Kalkulation ummünzen, nennen wir es mal GPU laufen lassen?",
      "start": 2110100,
      "end": 2145730,
      "confidence": 0.92546815,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Ja, also grundsätzlich würde ich damit sagen, das ist nicht nur ein schwieriges Problem für CPU, das ist einfach ein schwieriges Problem als solches. Das sagt seine Komplexitätskategorie sozusagen komplett unabhängig von jeder Hardware aus. Das ist eines der interessanten Dinge von diesem Problem. Und aus der gpu Sicht jetzt insbesondere ist die Frage, kann man das Problem parallelisieren oder noch präziser, kann man den besten Algorithmus parallelisieren, mit dem man das Problem berechnen kann? Weil es ist manchmal der Fall, ja man könnte einen parallelen Algorithmus finden, z.B. in dem Fall könnte man den parallelen Algorithmus finden, man probiert alle Möglichkeiten, die es gibt, parallel aus und rechnet und schaut, welche am besten funktioniert. Das lässt sich sehr leicht parallelisieren, dauert bis zum Hitzetod des Universums, zu viele Städte macht, also das wird nichts bringen, dass es sehr effizient parallel läuft, sondern es wird halt nur etwas kürzer laufen lassen, weil das Problem ist halt, das Problem wächst mit einem nicht linearen Faktor und die Faktor an GPUs, die du oder GPU korst, die du drauf werfen kannst, ist immer linear. Also das bringt eigentlich nichts im Endeffekt, du musst irgendwie einen effizienteren oder smarteren Algorithmus oder in dem Fall Heuristik finden. Und das Problem mit smarteren Heuristiken ist dann, dass die meistens zu mehr Branching in deinem Code führen und deswegen dann nicht besonders gut für ein GPU geeignet sind.",
      "start": 2145810,
      "end": 2221768,
      "confidence": 0.9075525,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Da ich nicht so smart bin, um den Algorithmus zu optimieren, habe ich mir eigentlich gedacht, ich schmeiße Hardware drauf und da man jetzt wie gesagt die CPU relativ schnell ausmaxen kann damit, habe ich gedacht, OK, GPUs klingt interessant, schmeiß ich einfach mal GPUs drauf. Also das ist so meine, da komme ich auch erstmal ein Stück weit, wie weit weiß ich dann jetzt auch nicht.",
      "start": 2221904,
      "end": 2240380,
      "confidence": 0.93381387,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Das ist das Problem mit der Komplexitätsklasse von so Algorithmen, dass du dann, ja, du kannst, du kannst zehnmal so viel GPUs draufschmeissen, dann kannst du vielleicht eine Stadt dazu tun oder wahrscheinlich auch nicht, wenn du schon zu viele hast, weil die Größe vom Problem halt viel schneller wächst, als die Anzahl GPUs, die du drauf werfen kannst.",
      "start": 2240480,
      "end": 2257172,
      "confidence": 0.8952685,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Ja, was ist das nun mal für eine Komplexitätsklasse? Ist das NP vollständig? Da verlässt sich mein Studium schon wieder. Das ist jetzt nicht so die Problemklasse, in der ich mich in der Industrie normalerweise mit beschäftige.",
      "start": 2257236,
      "end": 2270026,
      "confidence": 0.9076989,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Ist es NP complete? Kann sein, oder?",
      "start": 2270108,
      "end": 2272590,
      "confidence": 0.90081,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Ja, bin jetzt relativ sicher. Ist auch nicht mein Hauptthema natürlich, weil wir beschäftigen uns mehr mit Dingen, die man berechnen kann auf GPUs und GPU Clustern. Sinnvoll, aber ja, NP schwer ist es.",
      "start": 2272710,
      "end": 2283210,
      "confidence": 0.89292264,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Wobei da gibt es auch nochmal einen Unterschied zwischen Complete und Hard, je nachdem, wie man dann Subklassen bilden kann. Egal, geht in eine ganz andere Richtung. Meine Frage wäre eher praktischere Frage, bei OpenMP hast du schon erwähnt, da kannst du einfach Annotationen machen und dann wird deine Schleife automatisch im Idealfall irgendwie super parallelisiert, auf mehrere Cores aufgeteilt und es funktioniert. Jetzt klingt das ganze ja, ich muss das in irgendeinen Raum mappen für GPU, sie muss mir da Sachen überlegen. Das klingt für mich wesentlich komplizierter, damit ich da irgendwie etwas auf der GPU parallelisieren kann. Bin ich da richtig oder gibt es da auch Möglichkeiten, wenn ihr einen Algorithmus habt mit ein paar Annotationen schon das ganze zu parallelisieren auf einer GPU?",
      "start": 2284310,
      "end": 2326908,
      "confidence": 0.9067286,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Also es gibt grundsätzlich eben die Möglichkeit, OpenMP sogenanntes Offloading für Accelerators zu verwenden, wo die Idee wäre, dass es genau das gleiche macht, aber du schreibst halt zwei Wörter mehr hin oder so und dann kriegst du ein Programm auf der GPU. Das kann in speziellen Fällen gut funktionieren, aber eher selten. Grundsätzlich würde ich sagen, wenn du in deinem Programm z.B. zwei verschachtelte Schleifen hast, die irgendwas ausführen, was parallel ausgeführt werden kann, dann hast du ja mehr oder weniger schon einen zweidimensionalen Raum, nämlich den Iterationsraum von diese zwei schleifen, indem du deine Berechnung machst und das wäre dann der Raum, den du auf dem GPU mappst. Also es klingt vielleicht im ersten Moment etwas komplexer, als es eigentlich ist, weil in der Praxis läuft es doch darauf hinaus, parallele Schleifen sozusagen zu finden oder Schleifennester.",
      "start": 2327004,
      "end": 2373730,
      "confidence": 0.91220707,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Das heißt, die Matrixmultiplikation ist ja auch genau sowas mit zwei Schleifen, oder? Wenn ich das richtig im Kopf habe.",
      "start": 2373810,
      "end": 2380608,
      "confidence": 0.939768,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Ja, drei. Aber du würdest wahrscheinlich parallelisieren über die äußerste oder über die äußeren zwei.",
      "start": 2380624,
      "end": 2385184,
      "confidence": 0.9011613,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Hast du das gerade Schleifennester genannt?",
      "start": 2385272,
      "end": 2387440,
      "confidence": 0.91688335,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Ja, ich denke, das ist der deutsche Begriff, weil ich sehr selten in Deutsch über diese Dinge spreche, aber ja, was ist auf Englisch?",
      "start": 2387520,
      "end": 2393680,
      "confidence": 0.9278329,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Nested loop sehr wahrscheinlich, oder?",
      "start": 2393760,
      "end": 2395584,
      "confidence": 0.986902,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Ah, okay.",
      "start": 2395672,
      "end": 2396576,
      "confidence": 0.727935,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Was ist das sonst auf Deutsch? Schleifen?",
      "start": 2396688,
      "end": 2398820,
      "confidence": 0.8296557,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Keine Ahnung, ich habe den deutschen Begriff noch nie gehört und noch nie genutzt, aber ich finde ihn fast eigentlich ganz cool. Schleifen Nest.",
      "start": 2399160,
      "end": 2404712,
      "confidence": 0.9454325,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Ich weiß nicht, ob das stimmt. Wie gesagt, in Deutsch über diese Dinge sprechen ist sowieso schwierig. Ich kann mich noch erinnern, da gibt.",
      "start": 2404816,
      "end": 2410792,
      "confidence": 0.9332467,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Es kein Adjektiv, oder bei der ersten.",
      "start": 2410816,
      "end": 2414024,
      "confidence": 0.92373,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Vorlesung, die ich gehört habe zum Thema Grafikprogrammierung, die war damals noch von einem Professor, der alles auf Deutsch erklärt hat, hat er von der Parkettierung gesprochen und es hat für mich sehr lange gebraucht, bis ich verstanden habe, dass es um Tessellation geht, aber ja.",
      "start": 2414152,
      "end": 2426020,
      "confidence": 0.9323574,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Aber heißt das dann im Umkehrschluss, dass jetzt alle Algorithmen, die jetzt nicht im ein, zwei dreidimensionalen Raum stattfinden, schlechte Use Cases für GPUs sind?",
      "start": 2427040,
      "end": 2438606,
      "confidence": 0.8869044,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Nein, das kann man so überhaupt nicht sagen. Also in der Physik z.b. gibt es viele Probleme, die halt in irgendeinem siebendimensionalen Raum oder sonst wo berechnet werden, eigentlich von der Semantik her, wo das Problem passiert, aber im Endeffekt sich relativ effizient auf d oder d oder dreidimensionale Datenstrukturen mappen lassen. Und das ist meistens auch schon passiert von den Physikern, damit sie überhaupt in einem Programm sinnvoll damit umgehen können, unabhängig jetzt von GPU Programmierung oder nicht. Also man kann diese Dimensionalität sozusagen von der Berechnung nicht unbedingt direkt auf das Problem und die konkrete Dimensionalität von dem Problem ummünzen.",
      "start": 2438678,
      "end": 2474342,
      "confidence": 0.9179811,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Gibt es denn irgendwie so eine Daumenregel, ab welchem Workload es überhaupt Sinn macht, sich mit einer GPU zu beschäftigen? Denn ich hatte ja gerade gesagt, CPUs werden immer schneller und so weiter und wenn ich jetzt 1000 Datensätze hab, die jage ich vielleicht auch relativ so schnell durch durch meine CPU.",
      "start": 2474406,
      "end": 2489028,
      "confidence": 0.9187994,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Ja, es gibt da denke ich zwei Dinge, die man beachten sollte grundsätzlich einerseits in den Grad an Parallelismus und andererseits die Menge an Berechnungen pro Speichermenge, die man durchführt. In Bezug auf den Grad an Parallelismus, wenn man nicht, sagen wir mal mindestens tausende oder besser zehntausende unabhängige parallele Berechnungen hat, dann rentiert es sich nicht, die wirklich auf dem GPU zu portieren. Und andererseits bezüglich Datenmenge, insbesondere wenn man im Moment schon ein Programm hat, das halt am CPU läuft und man hat seine ganzen Daten im CPU, dann müsste man diese ganzen Daten ja erst einmal auf den GPU bringen, um dort irgendeine Berechnung zu machen. Und diese Übertragung ist nicht besonders schnell, also zumindest im Vergleich zu normalen Speicherzugriffen und so weiter. Und das bedeutet, man muss zumindest ordentliche Menge an Berechnungen machen, damit sich das rentiert. Also wenn etwas auf dem CPU in sagen wir mal Millisekunden oder Sekunden durchläuft, dann rentiert es sich meistens nicht, das auszulagern.",
      "start": 2489124,
      "end": 2545600,
      "confidence": 0.9212983,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Vor kurzem hatten wir eine Episode, da haben wir über ein wissenschaftliches Paper gesprochen, das nannte sich Scalability, but at what costs and costs stand for configuration that outperforms a single thread? Da ging es also um den Overhead, der gemacht werden muss, um eine Berechnung auf mehreren Threads auszuführen und ab wie viel Threads dann die Berechnung einen Single thread outperformt. Also kurzum, was ist der kalkulatorische Overhead? Und jetzt hatten wir gerade von dem Grad des Parallelismus oder der Parallelisierung gesprochen. Gibt es sowas auch? Also misst du sowas auch, ab wann es sich das überhaupt lohnt, die Berechnung aufzusplitten? Weil im Endeffekt, wenn du die Berechnung parallel durchführst, das Ergebnis muss ja am Ende schon noch irgendwie wieder zusammen merchen in der Regel.",
      "start": 2545680,
      "end": 2592832,
      "confidence": 0.9027299,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Ja, das hängt jetzt natürlich erst einmal davon ab, was macht der Algorithmus eigentlich? Also wenn wir jetzt wieder von dieser physikalischen Simulation sprechen, das Ergebnis eigentlich auch bis zu gewissen Grad paralleler Datensatz, weil er z.b. den Zustand von jeder Zelle im Raum oder sowas beschreibt. Aber grundsätzlich ist zusammen merchen von Ergebnissen kein großes Problem, weil das kann der GPU sehr schnell machen. Das Problem ist, mehr große Datensätze zum GPU zu transportieren oder wieder zurück zum CPU zu transportieren. Also das wäre der größere Unterschied. Und diese grundsätzliche Frage, was ist der Overhead oder wie groß ist der Overhead im Vergleich zum besten sequenziellen Algorithmus, das geht ein bisschen zurück auf das, was ich früher gesagt habe, nämlich das, was sich nicht nur dafür interessiert, wie gut kann man das jetzt parallelisieren, sondern wie gut kann man den besten sequenziellen Algorithmus parallelisieren. Wenn man den Algorithmus viel schlechter machen muss, um dann gut parallelisieren zu können, dann kann es sein, dass sich das nicht mehr rentiert.",
      "start": 2592896,
      "end": 2643670,
      "confidence": 0.9244988,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Ach, also ich meine, viele Leute, die haben einen Hammer und versuchen eine Schraube reinzuballern. Funktioniert auch, ist halt nur nicht ganz so geil.",
      "start": 2643830,
      "end": 2651062,
      "confidence": 0.91096336,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Ja, das gab es am Anfang, wo gpu Programmierung ganz neu war, hat man ganz gut Paper publizieren können, wo man einfach irgendein Algorithmus paralysiert hat, wenn er nicht state of the artist und dann halt sagt, schau, jetzt läuft es hundertmal so schnell wie ein CPU, das ist doch super toll. Da hat niemand so genau nachgefragt. Inzwischen, zumindest in der, sagen wir mal, Research Community, ist da etwas die Leute wieder etwas kritischer.",
      "start": 2651126,
      "end": 2669942,
      "confidence": 0.89834344,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Es war auch zu meinen Zeiten in der Datenbank Forschungsgruppe, wir haben uns auch ein GPU Cluster oder halt so einen Server, GPU Server angeschafft, haben uns gedacht, da kann man sicher mit Datenbanken auch was cooles machen, war aber doch schwieriger, als man sich so denkt. Aber jetzt kommen wir mal zum ganz klassischen Workload, also so neuronale Netze. Kannst du mal erklären, warum es eigentlich gut passt, neuronale Netze einfach zu berechnen auf der GPU, beziehungsweise vielleicht bevor wir in dieses Thema einsteigen, kannst du mal, weil jetzt haben wir so viel über Matrixmultiplikation gerechnet und das ist vielleicht, was man sich noch grundsätzlich vorstellen kann, kannst du mal so ganz schnell skizzieren, wie sowas dann abläuft, so eine Matrixmultiplikation, was es da für Teile gibt, wenn ich das ganze auf der GPU parallelisiere?",
      "start": 2670006,
      "end": 2713658,
      "confidence": 0.9401815,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Die einfachste Methode zur Parallelisierung wäre natürlich, dass du sozusagen über die aus die Elemente im Output parallelisierst. Also du musst einen Wert für jeden Wert in der Output Matrix berechnen und für jeden dieser Output Werte würdest du dann einen separaten Thread oder sowas starten am GPU.",
      "start": 2713834,
      "end": 2731580,
      "confidence": 0.93842334,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Das heißt, ein Pixel wäre im Prinzip ein Wert in dieser, im Output, in der Resultatmatrix. Vielleicht Andy, kannst du mal die Matrixmultiplikation erklären? Was eine Matrixmultiplikation ist, wie gesagt, mit.",
      "start": 2731660,
      "end": 2743484,
      "confidence": 0.90788645,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Solchen theoretischen Mitteln beschäftige ich mich in der Praxis in der Regel nicht. Ich habe das, vielleicht mal kurzer Schwank aus meiner Jugend, ich hatte Statistik eins und Statistik zwei in meinem Bachelorstudiengang und ich glaube Statistik eins habe ich dann, da kam nämlich 11 Matrix Multiplikation vor, ich glaube, da bin ich mit einer 3,7 durchgerutscht und da habe ich dann mit bestandenes bestanden abgehakt. Also da kannst du mich jagen, aber ich las lieber sein.",
      "start": 2743492,
      "end": 2769704,
      "confidence": 0.93048376,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Also ich hab zur Vorbereitung ehrlich gesagt auch noch mal nachschauen müssen, wenigstens bist du ehrlich. Ja eben. Also wenn ich es richtig im Kopf habe, multipliziert man immer die Zeile mit der Spalte, bildet da dann die Summe und das ist dann der Wert in der finalen Result Matrix.",
      "start": 2769792,
      "end": 2786198,
      "confidence": 0.9264292,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Ja, das ist richtig, Danke, gut vorbereitet. Aber wenn man sich das so vorstellt, wie du es gerade erklärt hast, dann sieht man ja auch irgendwie, dass das relativ parallelisierbar ist, weil das Resultat in einem Wert der Ausgabematrix hängt nicht vom Resultat an irgendeiner anderen Stelle ab.",
      "start": 2786374,
      "end": 2805206,
      "confidence": 0.905121,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Und das heißt, ich würde dann meine zwei Matrizen, also die multipliziert werden, komplett in den Speicher legen. Das ist eine d Matrize oder mal zwei halt, also zwei Matrizen und die lege ich einfach in Speicher und ein kleines Programm weiß dann, welche Elemente miteinander multipliziert werden müssen und addiert werden müssen.",
      "start": 2805278,
      "end": 2826530,
      "confidence": 0.9007524,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Genau, du hast mehr oder weniger ein kleines Programm pro Ausgabeelement, das berechnet genau die Berechnung, die du gerade beschrieben hast, wo es die Elemente der Zeilen mit den Spalten multipliziert.",
      "start": 2826610,
      "end": 2835894,
      "confidence": 0.92620325,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Und der Speicher wird read only zu allen Berechnungen geshared oder wird der kopiert?",
      "start": 2836002,
      "end": 2840670,
      "confidence": 0.92185354,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Ja, der Speicher wäre grundsätzlich mal einfach im GPU RAM abgelegt, aber da kommen wir dann auch zum Problem, wenn man es so implementieren würde, dann wäre es ziemlich gut parallel und wird potenziell auch schon schneller laufen als auf dem CPU jetzt. Aber du liest halt sehr häufig die gleichen Elemente aus dem Speicher, die du dann wieder verwendest und da wird es dann komplizierter. Also da kommt es dann zu so Dingen wie Blocking der Berechnung und zum effizienten Verwenden von Cache, dadurch, dass man auf diese Blöcke in einer besseren Reihenfolge zugreift. Also das wäre dann, wie man optimierte Matrix Matrix Multiplikation implementieren würde für GPUs. Muss man natürlich nicht, weil dafür gibt es Libraries von den Herstellern, die das mit sehr hoher Effizienz machen.",
      "start": 2840830,
      "end": 2882956,
      "confidence": 0.88722026,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Und wenn ich mir das jetzt noch mal vorstelle, muss es Programm, das da abläuft pro Zelle im Resultat. Das Programm sollte ja gleich sein, aber das Programm muss ja dann irgendwie Parameter bekommen, auf wo es gerade operiert. Also sind es dann irgendwie so klassische Parameter und jeder Pixel bekommt dann die Location und weiß dann durch, keine Ahnung, weiß automatisch welche Zeile, welche Spalte und holt sich dann die Daten einfach aus dem Speicher.",
      "start": 2883068,
      "end": 2912154,
      "confidence": 0.9168228,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Also die ganz konkrete Art, wie das Programm diese Information gibt, hängt von der jeweiligen API ab. Aber grundsätzlich in jeder API entspricht das Ausführen von so einem sogenannten Kernel Programm am GPU ein Aufruf, dem man d, d oder d Range gibt, in der er ausgeführt werden soll. Also du sagst jetzt z.b. du willst dieses gpu Programm ausführen auf einer 10 mal 10 range und das kriegt dann als Parameter entweder in ein Register oder in einer magischen Variable oder sonst irgendwie den x Index und den y Index in deinem Raum, den du abdecken willst, rein. Und auf Basis von diesen Indizes kannst du natürlich dein Speicherzugriff machen.",
      "start": 2912282,
      "end": 2951200,
      "confidence": 0.9186919,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Aber ich kann nur einen Kernel definieren. Also ich kann jetzt nicht sagen, ich habe tausend verschiedene Programme, sondern ich habe einen Kernel und der wird dann mit anderen Parametern jeweils auf meinen Pixeln oder Zellen in dem Fall aufgerufen.",
      "start": 2951280,
      "end": 2962800,
      "confidence": 0.90561277,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Du kannst natürlich viele Kernels haben, aber nur ein Kernel wird parallelisiert, zumindest auf einem Teil von GPU. Früher hätte ich sagen können, auf dem ganzen GPU läuft immer nur ein Kernel. Inzwischen ist es nicht mehr so. Also es kann moderner GPU auf verschiedenen Teilen verschiedene Kernels zu einem Zeitpunkt ausführen, aber alle müssen auf jeden Fall genug Parallelismus bieten, dass sie sinnvoll die Hardware verwenden können.",
      "start": 2962880,
      "end": 2984686,
      "confidence": 0.9201519,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Okay, jetzt haben wir die Matrix Multiplikation, was ja so das einfachste ist, was es eigentlich gibt. Dann gehen wir mal zu irgendwas, was eigentlich grundsätzlich schon niemand mehr versteht, neurale Netze oder niemand, aber wenige Leute. Warum sind die gut geeignet für GPUs oder warum sind GPUs gut geeignet für neuronale Netze?",
      "start": 2984838,
      "end": 3002094,
      "confidence": 0.9313445,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Besonders, ja, ich bin jetzt auch nicht Experte für neuronale Netze, sagen wir mal so, aber ich weiß grundsätzlich, wie die Programme mit GPUs arbeiten. Und der Grund ist im Endeffekt, dass die meisten Berechnungen, die da passieren, Matrix Multiplikation sind. Also deswegen eignen sich die GPUs gut. Sie eignen sich gut für Matrixmultiplikation, eignen sie sich auch gut dafür von der Hardware her. Insbesondere sehr wichtig, vor allem im Ausführen jetzt von so Sprachmodelle oder sowas, ist Speicherdurchsatz, weil die auf extrem viel Speicher zugreifen müssen, relativ wenig Berechnungen drauf machen. Und auch da sind die GPUs natürlich mit ihrem Durchsatz optimierten Speicher relativ gut dabei. Also da kann man halt TB pro S Speicherbandbreite haben, die man danach braucht.",
      "start": 3002142,
      "end": 3045428,
      "confidence": 0.8943138,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Ich finde es wirklich, wirklich, wirklich faszinierend, denn wenn man mal aus der Perspektive aus dem Internet spricht, aus der Webwelt, dann gibt es da Leute, die schrauben in PHP ein Kontaktformular in WordPress und wir unterhalten uns jetzt gerade über den Overhead, dass man ein paar Zahlen aus einer Spalte und aus einer Zeile öfters liest. Das erinnert mich so irgendwie immer an so Diskussionen, man hat jetzt irgendein Programm in C, da kennt ihr sehr wahrscheinlich diesen mehr oder weniger Trick, dass man, wenn man struct definiert, dass man dann die struct fields, dass die Reihenfolge da eine gewisse Anordnung haben muss, um halt das Memory Padding vermeiden. Also hat man String und Int und allem drum und dran und dann je nachdem, wie man das ordert. Und bisher habe ich in meiner Karriere sehr, sehr, sehr oft gesagt, also wenn wir uns mit diesem Problem beschäftigen müssen, dann haben wir ganz andere Probleme. Und jetzt mache ich einen Podcast darüber, okay, ja, diese Zahl wird ein paar mal öfter gelesen und dieses paar mal ist dann sehr wahrscheinlich sechs oder 7 Millionen mal, stelle ich. Aber ich finde es faszinierend, auf welche Art von, ich sag mal, Optimierung Leute kommen müssen, bzw. Wie ganz genau sich einzelne Algorithmen wirklich angesehen werden müssen. Das bringt mich irgendwie halt zu der Frage, wie viele Leute gibt es eigentlich, die gpu Programmierung, ich sag mal in Anführungszeichen, wirklich auf dem Kasten haben, weil wenn ich dir zuhöre, es gibt ja super viele Anti patterns und Fallstricke, dass dann vielleicht sogar später die Komplexität eines gpu Algorithmus alles andere irgendwie in den Schatten stellt. Dann ist man ja nur noch damit beschäftigt, den ganzen Kram da laufen zu lassen, anstatt wirklich mal zum Ergebnis zu kommen.",
      "start": 3045524,
      "end": 3148484,
      "confidence": 0.92850846,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Ja, also das ist eigentlich ein guter Einwand und sehr wichtige Fragestellung bei der ganzen gpu Programmierung. Wie kann man es einfacher gestalten? Grundsätzlich würde ich aber mal sagen, man muss jetzt nicht jeden Algorithmus so im Detail optimieren, wie Matrix Multiplikation optimiert wurde. Bzw. Matrix Multiplikation ist ja auch schon sehr gut optimiert von den Hardwareherstellern und es gibt auch eine Reihe von anderen Algorithmen, den so Standard Libraries wie z.B. den ganzen CUDA Libraries bereits implementiert sind. Und wenn man dann sein Problem oder auch nur Teilproblem von seinem Problem, was sehr hohen Performance einfluss hat, auf einen dieser existierenden Algorithmen runterbrechen kann, was häufig der Fall ist, dann kann man vom GPU profitieren, ohne sich mit diesen Details zu sehr auseinandersetzen zu müssen. Diese Detailoptimierung denke ich natürlich schon eher was für Experten und auch wie du richtig angemerkt hast, erhöht es natürlich dann den Maintenance Aufwand enorm. Insbesondere auch deswegen, weil solche Detailoptimierungen gerade besonders anfällig dafür sein, dass sie mit neuerer Hardware wieder nicht mehr funktionieren bzw. Pessimisations sind statt Optimisations. Also wenn sich an der Hardware zu viel ändert, dann ist eine gewisse Blockgröße z.B. plötzlich eher negativ, weil es immer so in den Cache reinpasst oder sowas.",
      "start": 3148592,
      "end": 3223718,
      "confidence": 0.90942496,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Wie ist das denn, wenn man jetzt auf einer GPU programmiert mit der Heterogenität der Grafikkarten selbst? Also ich meine, Grafikkarten entwickeln sich ja auch weiter, da gibt es vielleicht auch jetzt andere Chip Architekturen mit anderen Instruktionen und Auf einmal hat man da, ich sag mal, einen Cluster mit wirklich verschiedenen Grafikkarten. Man versucht da seinen Algorithmus laufen zu lassen und der eine ist vielleicht ein bisschen langsamer, weil er die Instruktionen irgendwie nicht kann oder virtualisiert betreiben muss oder ähnliches. Ist das in der Praxis ein Problem oder sagst du, ne, inzwischen gibt es ein Standard Instruktion Set, was hier GPU kann und das ist eigentlich völlig egal, gib mir einfach irgendeine andere Grafikkarte. Oder sagst du, ja, ab dem Jahr 2015 kamen nur noch Grafikkarten mit diesem Instruktionssatz auf den Markt. Also ich denke halt gerade auch an Cloud Hardware, die ich dann einfach mieten kann. Ich nehme einfach irgendwelche GPU Cluster bei Amazon, weil ich jetzt gerade keinen top 500 Computer im Keller von meiner Uni stehen habe. Also wie ist das da mit der Hardware?",
      "start": 3223814,
      "end": 3286780,
      "confidence": 0.91909724,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Ja, also ich denke, die ganze Frage, das ist der große Bereich, in dem die Frage diskutiert wird in der Forschung, nennt sich Performance Portabilität. Und die Performance Portabilität auf GPUs, gerade zwischen verschiedenen Herstellern, ist nicht unbedingt besonders gut. Aber ich würde trotzdem sagen, die meisten Optimierungen und insbesondere eigentlich der komplexeste Teil bei einem größeren Programm, nämlich das Mapping vom Original Algorithmus zu irgendwas, was grundsätzlich auf GPUs funktioniert, dieser Teil der Arbeit ist unabhängig davon, was für spezielle gpu Architektur jetzt wir gerade ansprechen wollen, die Detailoptimierungen. Je mehr man ins Detail geht, umso hardware spezifischer wird man. Und da muss man sich dann irgendwann überlegen, wie sehr man das für sein spezielles Problem machen will, weil vielleicht die letzten 5 % Performance rausholen auf einer Hardware, macht es potenziell auf andere Hardware sogar langsamer oder auch auf zukünftiger Hardware vom gleichen Hersteller. Und das macht man eben nur für sowas wie Matrix Multiplikation, wo man sich dann halt weltweit ein paar gw Sport, wenn es 5 % effizienter ist, aber.",
      "start": 3286860,
      "end": 3347872,
      "confidence": 0.9032506,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "In der Praxis verwenden dann Leute irgendwie Cuda oder verwenden die dann sowieso Abstraktionen. Und du hast ja auch Simsical und Celerity, das ist richtig ausspricht. Verwendet man dann sowas, was komplett alles oder alles, aber viel abstrahiert, oder ist schon durchaus noch üblich, dass man runtergeht auf eine tiefere Ebene und Cuda direkt anspricht?",
      "start": 3347896,
      "end": 3369430,
      "confidence": 0.91131616,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Also ich würde sogar sagen, Celerity steht auf so einer hohen Ebene, dass es jetzt wirklich der klassische Anwendungsprogrammierer direkt verwenden würde. Und wenn wir jetzt natürlich von dieser Anwendung sprechen, die im Moment sicher den Großteil aller GPUs weltweit verwendet, nämlich die ganzen ML Anwendungen, dann verwenden die meisten Leute im Endeffekt tensorflow, was Python Interface ist und dich natürlich von diesen ganzen Dingen, die wir jetzt besprochen haben, relativ abschirmt. Also du gibst dann mehr oder weniger an, was du willst, das passiert mehr, als was wirklich passiert auf den jeweiligen GPUs.",
      "start": 3369510,
      "end": 3406398,
      "confidence": 0.89966947,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Und kannst du kurz erklären, was Celerity macht und Simsical, nachdem wir da den Autor quasi von diesen Bibliotheken oder zumindest Co Autor am Mikrofon sitzen haben?",
      "start": 3406494,
      "end": 3417054,
      "confidence": 0.95094854,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Ja, ich versuche mich da jetzt kurz zu halten, aber Simsical ist hauptsächlich eben für Programmierer gebaut, die GPU Programme schreiben wollen, aber das gpu Programm auch sinnvoll testen wollen und auch während Development schnelle Feedback Cycles haben wollen. Weil ein Problem von diesen ganzen GPU Interfaces ist, dass wenn wir jetzt, die müssen das Programm ja nicht nur für CPU generieren, sondern auch speziell für GPU und es dauert meistens relativ lang und wenn man es programmiert, dann will man Sekunden, idealerweise Feedback Cycle haben und nicht Minuten, weil dadurch wird man sehr viel unproduktiver, meiner Erfahrung nach. Und das ist eines der Dinge, für die SimSicl entwickelt wurde. Also die Idee von Simsicl ist, man implementiert Sickl, aber ohne GPU Support. Was jetzt natürlich super seltsam klingt, weil es ist der ganze Sinn von Sickl, dass man damit seine GPUs programmieren kann. Aber die Idee ist, man führt es einfach auf sein CPU aus, kriegt dann sehr schnelles Feedback und hat sehr viel besseren Support dafür, seine Programme debuggen zu können.",
      "start": 3417142,
      "end": 3472706,
      "confidence": 0.89931387,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Und ZYCL ist eine Abstraktionsebene, habe ich das richtig verstanden?",
      "start": 3472778,
      "end": 3475874,
      "confidence": 0.848886,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Genau eines dieser Interfaces, die wir am Anfang besprochen haben, nämlich der neue Kronos Standard für gpu Programmierung.",
      "start": 3475922,
      "end": 3481620,
      "confidence": 0.88073945,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Aber wie darf ich mir das vorstellen? Ist das dann ein gpu Simulator?",
      "start": 3481700,
      "end": 3485240,
      "confidence": 0.84864306,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Nein, nicht voll, weil also wirklich den GPU auf der Hardware Ebene zu simulieren, wird ja viel zu lange dauern, sondern die Idee ist mehr, es simuliert die Ausführung vom Programm auf der Ebene vom Standard, wie der vorschreibt, dass das Programm ausgeführt werden sollte. Es hat aber auch so Features für Testing, wie z.B. dass es simulieren kann GPUs mit verschiedenem Grad an Vektorparallelismus oder sowas, damit dann de Programm ausgeführt wird in verschiedenen Reihenfolgen der Threads zueinander und so weiter, die auf Probleme aufmerksam machen können, weil du irgendeinen Fehler in der Parallelisierung hast oder sowas.",
      "start": 3486060,
      "end": 3521882,
      "confidence": 0.8933923,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Jetzt höre ich diese Podcast Episode und denke mir, ich verstehe nur Spanisch, ich mag Fremdsprachen, ich möchte Spanisch lernen. Was gibst du mir an die Hand, damit ich meinen ersten Algorithmus auf meiner lokalen GPU auf meinem Apple MacBook laufen lassen kann? Also was würdest du mir empfehlen? Wo fange ich an?",
      "start": 3522026,
      "end": 3538814,
      "confidence": 0.9240064,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Das ist eine sehr schwierige Frage für mich, weil ich keine Ahnung habe, was wirklich alles auf Apple im Speziellen funktioniert, weil Apple natürlich immer sehr speziell sein muss.",
      "start": 3538902,
      "end": 3546910,
      "confidence": 0.9477907,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Apple hat irgendwas, du darfst ja nicht so ernst nehmen mit seiner nischen Hardware, die niemand hat. Also gehen wir mal von einer sinnvollen Hardware aus, die man sich da in der Cloud so mietet oder so mit CUDA oder keine Ahnung was läuft.",
      "start": 3546990,
      "end": 3559490,
      "confidence": 0.91016865,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Dann nimm mal ein IBM SyncPad, was ich hier noch rumfliegen habe. Das hat bestimmt auch irgendwie eine Grafik.",
      "start": 3559830,
      "end": 3564302,
      "confidence": 0.8416842,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Die haben keine GPUs, glaube ich zumindest.",
      "start": 3564366,
      "end": 3566180,
      "confidence": 0.9142714,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Meinst oder von mir aus auch irgendeine AWS GPU Kiste. Also ich möchte, ich habe jetzt ein Stück Code, von mir aus auch, und jetzt gehe ich echt weit weg, in JavaScript, Python, oder was weiß ich nicht. Vielleicht nicht in C. Vielleicht nicht in C, vielleicht noch nicht gerade in Rust, aber von mir aus auch in Rust, ist mir auch egal. Was gibst du mir in der Hand, dass ich das jetzt mal testen kann und dass ich so einen kleinen Wow Effekt habe, so innerhalb von drei, 4 Stunden ein bisschen rumprobieren und dann ich möchte mal den Wow Effekt haben. Geil, ich habe jetzt eine Berechnung der GPU.",
      "start": 3566260,
      "end": 3598624,
      "confidence": 0.9077952,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Ja, also wenn du jetzt dein Python Programm hast, dann gibt es so Dinge wie Number, die dir erlauben, GPUs aus sehr relativ high level Python Perspektive zu verwenden und damit kannst du relativ schnell diesen Wow Effekt haben. Also wir haben dieses Jahr gefördertes Bootcamp gehabt mit mehreren Firmen, die eben genau mit solchen Codes zu uns gekommen sind, mit ihrem beiden Prototyp oder sonst irgendwas und die halt sich gefragt haben, wie kann man das schneller machen? Und da kann man schon innerhalb, sagen wir mal, idealerweise weniger Stunden oder vielleicht weniger Tage wirklich so ein Production Code, zumindest irgendein Teil davon parallelisieren am GPU. Also das wäre eine Möglichkeit. Number wenn man jetzt Python Code im speziellen hätte, wenn man klassischer mehr mit C oder sowas unterwegs ist, dann würde man vermutlich für den Anfang doch zu Nvidia gehen wollen, weil die haben sehr gutes Lernmaterial, die haben da auch viel rein investiert und sehr gute Tools zum debuggen und so weiter, was man jetzt bei anderen Hardwareherstellern, bei anderen APIs häufig vermisst. Also für mehr so klassisches GPU programmieren will man wahrscheinlich doch zumindest für den Anfang zu CUDA gehen und später dann vielleicht, wenn man sie ein Produkt haben will, so etwas, was auf mehr als nur einem Hardwarehersteller funktioniert.",
      "start": 3598752,
      "end": 3670644,
      "confidence": 0.90888846,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Und wenn ich SQL lernen will, oder gibt es da sinnvolle Dokumentation oder wie kann ich damit losstarten?",
      "start": 3670772,
      "end": 3677130,
      "confidence": 0.90055114,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Ja, also für SICKL gibt es inzwischen sehr viel sinnvollere Dokumentation als noch vor, sagen wir mal einiger Zeit. Es gibt die SICKL Academy, das wird gesponsert unter anderem von Intel und da haben auch sogar wir unseren ganz kleinen Teil beigetragen. Das heißt, an der Uni Sickl Academy findet man einfach, wenn man es sucht und die hat mehrere. Das geht eigentlich ziemlich vom Anfang von GPU Programmierung los, halt anhand von SICK.",
      "start": 3677210,
      "end": 3698314,
      "confidence": 0.87340057,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Wir verlinken natürlich das ganze auch von Nvidia, aber auch die Cyclical Academy natürlich in den Shownotes. Jetzt muss ich dir aber trotzdem noch mal fragen, Celerity oder wie spricht man es richtig? Celerity. Okay, was macht das ganze? Ist das auch hilfreich?",
      "start": 3698442,
      "end": 3714850,
      "confidence": 0.85354114,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Okay, also greifen wieder die Story von vorher auf. Du hast jetzt angefangen GPUs zu programmieren und nach zwei Tagen denkst du, das ist das beste, seid geschnitten Brot, wir müssen damit weitermachen. Du willst jetzt nicht nur einen GPU verwenden, weil du denkst, wenn du mit einem GPU schon so viel schneller bist, wie schnell bist du dann mit 10 oder mit 100 oder mit 1000 GPUs? Und da würde jetzt Celerity ins Spiel kommen. Also die Idee von Celerity ist, dass du dich nicht damit auseinandersetzen musst. Es ist eh schon schwierig genug, haben wir uns gedacht, GPUs zu programmieren. Du musst dich nicht auch noch damit auseinandersetzen, wie verteilst du jetzt dein Programm auf mehrere GPUs, sondern du schreibst so, als hättest du einen GPU wie Zickl. Und Celerity verteilt dann dein Programm hoffentlich nahezu optimal auf GPU Cluster. Das wäre die Idee.",
      "start": 3714930,
      "end": 3762392,
      "confidence": 0.9128675,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Ich hoffe, der Andi wird es verwenden, wenn er mal ein Problem hat, was er auf mehrere GPUs über einen Cluster hinweg optimieren kann.",
      "start": 3762456,
      "end": 3769768,
      "confidence": 0.91501206,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Ja, das habe ich täglich und ich denke mir jeden Abend, genau dieses Problem habe ich. Aber ich hatte einfach nur noch keine Zeit, mir meine eigene Library zu schreiben. Meine Frage ist ja, ich habe gerade schon diese Box angesprochen, Grafikkarten und GPUs als Commodity für den End Consumer und nicht nur für die großen Leute, die da Chips im großen Stil kaufen, wie Musk und Co. Wo geht es hin in den nächsten Jahren mit dem GPU computing? Wird das alles Massenware? Berechnen wir bald nichts mehr auf der CPU? Was sagt deine Glas Google Peter?",
      "start": 3769904,
      "end": 3802616,
      "confidence": 0.9178007,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Predictions are difficult, particularly about the future, aber grundsätzlich, GPU Computing bleibt uns sicher erhalten. Für den AI Hype im Speziellen wird es sehr spannend, weil da gibt es natürlich extrem viele Interessenten, die spezialisiertere Hardware als GPUs spezifisch für diese Anwendungen bauen. Und ich denke vor allem für die Inference, also den Teil, wenn man mal ein Modell trainiert hat und dann versucht auszuführen, wo im Moment die meisten gpu Stunden reingebraten werden, weil immer wenn man irgendjemand auf ChatGPT geht, nachher braucht es ordentlich GPUs. Ich denke, vor allem für diesen Teil wird sich wahrscheinlich eher spezialisiertere Hardware etablieren, außer es ändert sich groß was am algorithmischen Fundament dieser ganzen AI Dinge. Für mehr den Research Teil, das Trainieren und so weiter, denke ich, bleiben auch da weiterhin wahrscheinlich GPUs sehr, sehr relevant, weil sie einfach ein bisschen flexibler sind als diese hochspezialisierte Hardware. Und für andere Berechnungen, von denen es geht, haben, so Simulationen und so weiter, denke ich auch, dass GPU Compute weiterhin sehr relevant bleiben wird. Ich denke nicht unbedingt, dass es sich. Inzwischen sind GPUs schon sehr viel flexibler als sie vor 15 Jahren waren. Ich denke nicht, dass sich GPUs noch sehr stark weiter zu noch flexiblerer Programmierung hin entwickeln werden. Einfach aus dem Grund, weil man dann irgendwann die Vorteile im Hardware Design verliert durch diese etwas einfachere Hardware, die erlauben, höhere Performance zu erzielen für eben diese speziellen Anwendungen als auf dem CPU. Also irgendwo bleibt diese Trennung dann doch, denke ich, erhalten.",
      "start": 3802728,
      "end": 3900894,
      "confidence": 0.8951708,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Aber ich meine, die Spezialisierung von Chips, die geht ja schon seit längerem voran. Also ich meine, Google hat ja schon vor einigen Jahren diese TPUs announced tensor processing units. Und ich glaube, Apple baut auch eigene Chips und also jeder große Hyperscaler. Ich glaube, Amazon hat jetzt gerade auch auf den letzten Reinvent im November, Dezember eigene Chips vorgestellt. Und wenn wir da an Spezialisierung denken, heißt das dann, mal ganz plakativ gesprochen jetzt und von sehr generalisiert, dass man diese Chips, dass sie wirklich ganz knallhart auf Matrizenoperationen, ich sag mal, optimiert sind. Nehmen wir das mal als Beispiel, aber dafür jetzt keine Grafikengine mehr rendern können.",
      "start": 3901022,
      "end": 3944576,
      "confidence": 0.9075574,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Ja, oberflächlich sagen wir mal gesprochen, aber eigentlich korrekt ist es so. Also die sind halt noch spezialisierter GPUs schon relativ spezialisiert, aber ist ja noch sehr viel spezialisierter auf die Bedürfnisse von eben diesen ML Workloads.",
      "start": 3944648,
      "end": 3957152,
      "confidence": 0.91159785,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Verstehe. Da muss ich ja in Zukunft wirklich aufpassen, wenn ich GPUs kaufe, wie wenn ich Schneeketten für meine Reifen kaufe. Da muss ich nämlich auch immer ganz, muss ich immer dreimal nachgucken, passen die hier, passen die hier nicht.",
      "start": 3957216,
      "end": 3968208,
      "confidence": 0.918747,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Ja, aber Andi, das ist ihr habt keinen Schnee in Duisburg und keine Berge. Du brauchst genauso wenig Schneeketten, wie du irgendwie spezielles GPU Teil brauchst für deine Workloads.",
      "start": 3968344,
      "end": 3978748,
      "confidence": 0.87063485,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Also es gilt wie immer im Haben ist besser als brauchen. Was ist, wenn ich ganz plötzlich in einer Situation eine Matrizenoperation auf einer GPU wird mich jetzt weiterbringen. Ich sage es dir, der neue Thermomix wurde gerade vorgestellt, der wird bestimmt auch Matrizenpokalkulation drin haben.",
      "start": 3978844,
      "end": 3997638,
      "confidence": 0.92224413,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Der ist sicher auch AI Optimist und schlag mich tot.",
      "start": 3997694,
      "end": 4002050,
      "confidence": 0.903613,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Ich war noch nicht auf der Landingpage, aber bestimmt. Peter, vielen lieben Dank, dass du uns wenigstens einen kleinen Einblick in die gpu Programmierung bieten konntest. Wir hatten schon im Vorgespräch kurz darüber gesprochen, dass es natürlich auch in einer Stunde sehr, sehr schwierig ist, dieses ganze Thema zu besprechen. Denn das, was du lehrst, das geht über 40 Stunden, 50 Stunden, was hattest du gesagt?",
      "start": 4002350,
      "end": 4024608,
      "confidence": 0.9003827,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Ja, hängt vom speziellen Fach ab, aber ja, in dem Bereich. Also ein Semester lang, jede Woche 3 Stunden oder sowas.",
      "start": 4024704,
      "end": 4031648,
      "confidence": 0.9313038,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Genau. Und dann mit Slides und ich glaube, du hattest auch gesagt, nur die Einführung dauert irgendwie zwei bis 4 Stunden mit etlichen Slides. Also deswegen können wir natürlich. Ich bin mir gar nicht sicher, ob wir schon an der Oberfläche kratzen oder nur das Thema mal ganz kurz gemalt haben. Aber ich habe dir auf jeden Fall zu danken. Ziemlich viele Begriffe sind hier durch den Podcast geflogen, die mir zuvor noch nie was gesagt haben. Und es ist auch ein bisschen peinlich, dass ich mich geäußert habe, dass ich nicht aus dem Stegreif die Matrizen berechnung erklären konnte. Aber nur gut, das stempel ich unter dem Bereich ab. Man muss nicht alles wissen, man muss nur wissen, wo man nachschlägt. Die ganzen Buzzwords und unglaublich komplizierten Wörter, die wir genannt haben, die finden natürlich alle auch in den Shownotes. Und alle Links zu CUDA, OpenGL, Open CL, den Nvidia Self Pace Trainings der Zykl Akademie, aber auch Links zu Simzycle und Celerity. Wie ist das? Wie spreche ich das richtig aus? Celerity findet ihr natürlich auch alle in den Shownotes, falls ihr da mal ein bisschen rumspielen wollt. Und ja, innerhalb von vier bis 8 Stunden kriegt er bestimmt irgendwo einen kleinen Algorithmus auf einer GPU zum Fliegen. Und vielleicht hat CUDA ja auch ein Beispiel Algorithmus, den einfach mal deployen und vielleicht könnte man auch einen Wettbewerb machen. So der erste, der weiß ich nicht, irgendwas JavaScript technisches auf irgendeiner GPU laufen lässt und bei uns in der Community vorstellt, der kriegt irgendwie eine Engineering Chaos Taste oder so. Das fände ich mal ganz interessant als kleinen Abend Hackathon. Peter, hast du noch irgendetwas, was du unseren Hörerinnen und Hörern mitgeben möchtest zum Thema GPUs, was du schon die ganze h sagen wolltest?",
      "start": 4031744,
      "end": 4138590,
      "confidence": 0.90809804,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Vielleicht, wenn man sich die Zeit nimmt, kann es ganz interessant sein und wenn man Puzzles mag, besonders.",
      "start": 4138670,
      "end": 4144690,
      "confidence": 0.92215335,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Okay, also du motivierst alle. Scheint ein leichter Einstieg zu sein. Superleicht, aber ist auch eine gute Zusammenfassung, aber deckt sich mit meinem Bild von der ganzen Welt, muss ich zugeben.",
      "start": 4145830,
      "end": 4158730,
      "confidence": 0.8876726,
      "speaker": "A",
      "channel": null
    },
    {
      "text": "Das war's von uns. Wenn ihr Feedback zu der Episode habt, wisst ihr, wo ihr dies abladen könnt. In unserer Diskussion auf Social Media oder schreibt uns eine e Mail. Auch wenn ihr Feedback an Peter habt oder mit ihm in Kontakt treten wollt, dann auf der einen Seite googelt ihn natürlich, auf der anderen Seite könnt ihr das Feedback natürlich auch gerne an uns senden und wir leiten es liebend gern weiter. Das war's von uns. Vielen Dank, Peter und wir sagen tschüss, bis zum nächsten Mal.",
      "start": 4159070,
      "end": 4186198,
      "confidence": 0.9459393,
      "speaker": "B",
      "channel": null
    },
    {
      "text": "Tschüss.",
      "start": 4186254,
      "end": 4186710,
      "confidence": 0.90998,
      "speaker": "C",
      "channel": null
    },
    {
      "text": "Ciao.",
      "start": 4186790,
      "end": 4186950,
      "confidence": 0.47049,
      "speaker": "A",
      "channel": null
    }
  ],
  "confidence": 0.91140807,
  "audio_duration": 4128,
  "webhook_status_code": null,
  "webhook_auth": false,
  "summary": null,
  "auto_highlights_result": null,
  "content_safety_labels": null,
  "chapters": null,
  "sentiment_analysis_results": null,
  "entities": null
}