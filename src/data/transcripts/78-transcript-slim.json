{
    "language_code": "de",
    "audio_url": "https://audio1.redcircle.com/episodes/a14d93e5-1858-4744-8878-c911c0a07c47/stream.mp3",
    "punctuate": true,
    "format_text": true,
    "dual_channel": false,
    "webhook_url": null,
    "webhook_auth_header_name": null,
    "webhook_auth_header_value": null,
    "audio_start_from": null,
    "audio_end_at": null,
    "word_boost": [],
    "boost_param": null,
    "filter_profanity": false,
    "redact_pii": false,
    "redact_pii_audio": false,
    "redact_pii_policies": null,
    "redact_pii_sub": null,
    "speaker_labels": true,
    "speakers_expected": 2,
    "content_safety": false,
    "content_safety_confidence": null,
    "iab_categories": false,
    "custom_spelling": null,
    "disfluencies": false,
    "sentiment_analysis": false,
    "auto_chapters": false,
    "entity_detection": false,
    "summarization": false,
    "summary_model": null,
    "summary_type": null,
    "auto_highlights": false,
    "language_detection": false,
    "speech_threshold": null,
    "id": "62seq5q09p-e823-4794-a408-b812375619eb",
    "status": "completed",
    "error": null,
    "utterances": [
        {
            "text": "Würde ich sagen, nur weil man ein Monolith hat, sind nicht alle Probleme gelöst.",
            "start": 2741,
            "end": 6243,
            "confidence": 0.7861428571428571,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Ich denke, dass ziemlich viele Unternehmen gemerkt haben, dass sie die realen Vorteile entweder nicht brauchen oder die Organisation nicht so umgestellt bekommen, beziehungsweise das technische Alignment, was zur Nutzung der Vorteile von Microservices wirklich notwendig ist, umgesetzt bekommen.",
            "start": 7624,
            "end": 23592,
            "confidence": 0.8867179487179487,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Also ich glaube, das war auch so ein Trend, der da mitgeschwommen ist mit dieser ganzen Microservice-Ecke und den man oft vergisst. Also es geht gar nicht nur um diese Microservices, sondern auch was sich so rundherum entwickelt hat.",
            "start": 24907,
            "end": 34657,
            "confidence": 0.7868205128205128,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Hi, schön, dass du bei einer neuen Episode vom Engineering Kiosk dabei bist. Wir sprechen heute über das Religionsthema Microservices und Monolithen. Seit ca. 9 Jahren wird diese Sau durchs Dorf getrieben. Und irgendwie haben wir das Gefühl, dass es immer mehr und mehr Leute gibt, die sagen, die meisten Firmen sollten doch zurück zu Monolithen wechseln. Deswegen sprechen wir mal ein wenig über die letzten 9 Jahre und schauen uns an, welche Probleme Microservice eigentlich lösen sollte, was die wahren Vorteile dieser Architektur sind, warum die meisten Firmen diese gar nicht vollumfänglich nutzen, wie Firmenumstrukturierungen das ganze gegen die Wand fahren lassen können und warum die ganze Kubernetes und Cloud-Native-Welle gegebenenfalls den Trend befeuert hat. Viel Spaß und los geht's! Die Tage war ich auf unserer Webseite und bin über die vorherigen Podcast-Episoden mal ein bisschen drüber gescrollt. Und dann dachte ich mir, wir müssen mal ein bisschen Stereotypen-Denken anbringen. Wir können kein Software-Engineering-Podcast sein, ohne das Thema anzusprechen, Microservices und Monoliden.",
            "start": 37780,
            "end": 101320,
            "confidence": 0.7722208588957056,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Jetzt hast du wahrscheinlich 80% unserer Hörerschaft verloren. Bravo, Andi.",
            "start": 101540,
            "end": 105704,
            "confidence": 0.5094000000000001,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Und jetzt mal eine kleine Story von Behind the Scenes. Wolfgang und ich chatten im Slack immer so ein bisschen rum. Okay, was machen wir denn als nächstes Thema? Und wer bereitet das vor? Und haben wir dann schon mal irgendwie ein paar Ideen, die dampfen wir dann immer in so einen Google-Doc. Bis sich dann irgendeiner von uns mal erbarmt, sich da mal wirklich eine Stunde hinzusetzen und das Thema dann mal wirklich vorzubereiten, weil bei manchen Themen müssen wir auch hier und da den einen oder anderen Fakt nochmal nachschlagen. Auf jeden Fall kam ich dann auf diese grandiose Idee, mal über das Thema Microservices und Monolithen zu sprechen, denn kein Software-Engineering-Podcast sollte dieses Thema nicht erwähnen. Und da kam O-Ton, der Satz, da musst du mich aus einem tiefen Motivationsloch holen bei dem Thema. Wolfgang, warum bist du so down bei diesem Thema?",
            "start": 106024,
            "end": 148094,
            "confidence": 0.7571712328767122,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Ich glaube, ich hatte einfach schon viel zu viele Diskussionen über dieses Thema. Und das ist so ein Religionskrieg, so ähnlich wie Wim gegen Imax. Und da gibt's eigentlich keine Gewinner. Und das sind nur haarstreibende, lange Diskussionen, die man da führt.",
            "start": 148460,
            "end": 162330,
            "confidence": 0.8437142857142857,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Bist du bei diesem Religionskrieg Atheist? Oder hast du einfach ganz klar eine Seite?",
            "start": 162350,
            "end": 167053,
            "confidence": 0.7055000000000001,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Ich bin ja vielleicht mehr der Agnostiker, dass es noch ungeklärt ist, was die richtige Seite davon ist.",
            "start": 167073,
            "end": 172917,
            "confidence": 0.8322222222222223,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Das bedeutet also auch, du bist nicht gegen beide Seiten. Du bist der Kollege, der sich bei.",
            "start": 172937,
            "end": 177400,
            "confidence": 0.8478235294117646,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Verändernehmern... Ja, irgendwie muss man es ja machen. Also, da führt ja kein Weg daran vorbei.",
            "start": 177420,
            "end": 182023,
            "confidence": 0.676375,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Okay, dann versuchen wir dich mal hier heute hier hoch zu hypen und dich entweder zu bekehren oder dir so eine Meinung wie die typischen Consultants aus dem Mund zu locken. It depends.",
            "start": 182083,
            "end": 192391,
            "confidence": 0.732181818181818,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Ja, dann hype mal los.",
            "start": 192411,
            "end": 193352,
            "confidence": 0.8039999999999999,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Die erste Frage, die ich mir bei dem ganzen Thema gestellt habe zur Vorbereitung dieser Episode, wann kam dieses Thema eigentlich auf? Also ich habe auch so 2007, 2008 mit dem Programmieren, mit der professionellen Programmierung angefangen. Also da dann wirklich damit Geld verdient. Und da war dieses Microservices-Thema noch nicht auf unserem Tisch. Dann habe ich mal ein bisschen recherchiert. Und wo fängt man eigentlich an zu recherchieren, wenn man wissen möchte, wann ein Thema hochkam? Richtig, Google Trends. Die ganze Sache kam Mitte der 2010er Jahre, also 2014, 2015, 2016. Da gibt es auch so einen knallharten Ausschlag bei Microservices, bei Google Trends. Und da geht dann so ähnlich wie so ein Aktienindex, so wie der Nasdaq vor Corona, ging dann auch immer so schön hoch.",
            "start": 193772,
            "end": 234022,
            "confidence": 0.7930546875,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Ja, ich hatte das erste Mal Kontakt, lustigerweise in einem Interview, also wirklich, wo ich interviewt wurde für eine Stelle. Und ich komme ja aus der Datenbankwelt, da gibt es sowieso nur Monolithen und so Zeug. Und dann war so eine Frage, ob ich mich bei Microservices mit Docker auskenne. Und da hatte ich wirklich zum ersten Mal eigentlich davon gehört. Also das war so zu Beginn 2015er Jahre oder sowas in der Richtung. Und mit Docker hatte ich schon so ein bisschen gearbeitet, aber Microservices und Docker, Da habe ich dann gemerkt, oh, da scheint es irgendwo einen Trend zu geben, der gerade so auf Computerbild-CEO-Niveau herumschwirrt.",
            "start": 234282,
            "end": 270042,
            "confidence": 0.7985092592592591,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Computerbild, Megathema. Wir schreiben das Jahr 2023. Und ich habe ja jahrelang, oder mache es ja immer noch, Meetups organisiert. Und bei Meetups, immer wenn du uns...",
            "start": 270082,
            "end": 280749,
            "confidence": 0.7667777777777778,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Moment, du machst es wieder. Du hattest eine lange, lange, lange Pause.",
            "start": 280809,
            "end": 284111,
            "confidence": 0.7963333333333332,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Jeder braucht mal seine Pause. Also für alle, die es noch nicht wussten, das Web Engineering Düsseldorf Meetup gibt es jeder jeden Monat.",
            "start": 284591,
            "end": 290752,
            "confidence": 0.8047391304347825,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Ich hoffe mit Prosecco, oder? Klassisch in Düsseldorf.",
            "start": 290992,
            "end": 293813,
            "confidence": 0.752,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Darf ich mir als Duisburger nicht erlauben. Wie dem auch sei, Computerbild. Bei Meetups habe ich immer so ein Sprichwort und zwar, wenn du ein Computerbild-Thema hast, ist die Hütte voll. Und ein Computerbild-Thema ist ein Thema, was jeder schon mal gehört hat, aber was nicht wirklich klar ist, wie man das macht. Das war zum Beispiel mal responsive Webdesign oder Scrum und agiles Projektmanagement. Jeder macht das irgendwie, aber keiner hat wirklich so den heiligen Gral, wie man das macht. Man könnte auch sagen, auch ein Computerbild-Thema ist, wenn das Thema in der Computerbild einen Artikel hat. Und bei der Recherche zum Monolithen habe ich einen Artikel der, Achtung, computerwoche.de gefunden. Vor- und Nachteile für Unternehmen, wenn man auf die Microservice-Architektur setzt.",
            "start": 293853,
            "end": 337729,
            "confidence": 0.8381869918699187,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Von 2013. 23.",
            "start": 337769,
            "end": 339279,
            "confidence": 0.6333333333333333,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Der ist im April diesen Jahres rausgekommen, also ein bisschen mehr als zwei Monate alt. Für mich ist das der offizielle Beweis, dass Microservices jetzt ein Computerbild-Thema ist.",
            "start": 339289,
            "end": 351273,
            "confidence": 0.85375,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Das heißt eigentlich, deine Vorbereitung besteht daraus, dass du Computerbild liest für diesen Podcast. Sehe ich das richtig?",
            "start": 351313,
            "end": 357515,
            "confidence": 0.7406666666666666,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Computerwoche. ist, soviel ich weiß, nicht vom Axel Springer Verlag, deswegen vielleicht ...",
            "start": 357535,
            "end": 362646,
            "confidence": 0.8331538461538461,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Klingt nach wesentlich qualitativeren Journalismus, klar.",
            "start": 362656,
            "end": 366437,
            "confidence": 0.7381666666666665,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Aber ich find das lustig, weil in meiner Bubble, in meiner Internet-Bubble, hab ich eher das Gefühl, die Monolithen kommen wieder zurück. Und nicht die Microservices werden weitergepusht. Die Computerwoche sagt, hey, liebe Unternehmen, hey, liebe C-Level-Management, die ihr Computerwoche lest, schaut euch doch mal Microservices an im Jahr 2023, also acht, neun Jahre nachdem die Bubble, also wir zum Beispiel, davon gehört haben, Aber wenn ich jetzt ganzen Leuten, den Software Consultants und so weiter mal zuhöre oder so Leuten wie Kelsey Hightower, auch ein sehr sehr erfolgreicher Developer Advocate von Google, von Google Cloud und war auch mal sehr laut um Kubernetes, da habe ich so ein bisschen das Gefühl, die pendeln jetzt gerade wieder zurück. Wo wir früher in dem einen Extrem waren, alles waren Monolithen. wurde dann die Microservice-Sau durchs Dorf getrieben und alle sind auf den Microservice-Zug aufgesprungen. Danach haben wir so ein bisschen die Probleme und die Herausforderungen erkannt und jetzt advokaten doch schon wieder eine ganze Menge Leute für, sollten wir die Microservice-Schiene nicht links liegen lassen und wieder zu Monolithen gehen, weil das für viele Unternehmen ausreichend ist.",
            "start": 366497,
            "end": 425797,
            "confidence": 0.820381720430108,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Und nur DHH hat es schon immer gewusst. David Heinemeier Hansen, der CTO von Basecamp und hate.com, der war ja immer schon ein extremer Befürworter für Monolithen und der hat gerade kürzlich in meinem Blogartikel online gestellt, wo eine Meldung von Amazon kommentiert, und zwar von Prime Video von Amazon, die ihre Serverless-Architektur bzw. Microsoft-Service-Architektur gekillt haben und zurück sind zu einem Monolithen und 90% der Kosten eingespart haben auf EWS. Also ein Prime-Video-Service von Amazon hat 90% der Kosten eingespart, dadurch sie weg sind von Serverless. Also eindeutiger Trend zurück zu Monolithen, ja. Glaubst du, hat es irgendeinen Grund, warum die Leute jetzt zurückgehen Richtung Monolith? Ich hätte eine Theorie, aber ich will mal zuerst die Theorie des Profis hören. Du machst ja dieses ganze DevOps-Zeug und das ist ja dein Kram eigentlich. Und dein Thema heute?",
            "start": 426437,
            "end": 484000,
            "confidence": 0.8205217391304346,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Also eigentlich müsste ich ja voll für Microservices sein, weil Microservices braucht ja auch mehr Infrastruktur beziehungsweise mehr Power, Achtung, im Betrieb, ja im Ops, deswegen das ist ja eigentlich Jobsichern für mich.",
            "start": 484040,
            "end": 497099,
            "confidence": 0.8486666666666668,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Macht ja dein Leben dann auch komplizierter.",
            "start": 497780,
            "end": 499361,
            "confidence": 0.6648571428571428,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Naja, einen Job zu haben, finde ich erstmal ganz gut. Das macht das ja dann nicht kompliziert. Wenn alles so monolithen ist, dann kann das ja jeder.",
            "start": 499381,
            "end": 504663,
            "confidence": 0.7172592592592593,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Ja, wobei der Monolith muss ja auch deployed werden. Aber du hast natürlich recht, wenn ich 1000 Services deployen muss, das ist mehr Aufwand, als wenn ich nur zwei Services deployen muss.",
            "start": 504683,
            "end": 513366,
            "confidence": 0.75196875,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Das ist zumindest einer der Nachteile, die oft in Verbindung mit Microservices genannt werden. Ob das dann jetzt wirklich so Realität ist oder nicht, besprechen wir gleich noch. Aber zurück zu der Frage, warum die ganzen Leute wieder zu einem Monolithen pendeln. Ich denke, dass ziemlich viele Unternehmen gemerkt haben, dass sie die realen Vorteile entweder nicht brauchen oder, und jetzt kommt das eigentlich Schwierige, die Organisation nicht so umgestellt bekommen, beziehungsweise das technische Alignment, was zur Nutzung der Vorteile von Microservices wirklich notwendig ist, umgesetzt bekommen. Und damit meine ich, der Key-Vorteil von Microservices, meiner Meinung nach, die Schaffung von wirklich unabhängigen Teams, damit die unabhängigen Teams sich schnell bewegen können.",
            "start": 513587,
            "end": 554288,
            "confidence": 0.8420267857142855,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Interessanter Ansatz, dann bleiben wir gleich mal bei den Vorteilen. Vielleicht kannst du mal erklären, du hast es ja noch miterlebt von der alten monolithischen Welt hin zu den Microservices. Wie hast du den Trend denn wahrgenommen? Warum war das so in und was wollte man da eigentlich für ein Problem lösen?",
            "start": 554828,
            "end": 570799,
            "confidence": 0.7974423076923075,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Naja, so um die Zeit 2014, 2013, 2015, 2016 und so weiter, da kamen natürlich immer mehr Leute online, mehr und mehr Leute haben schnelleres Internet bekommen und jeder hatte irgendwie Zugriff auf dieses World Wide Web und besonders auch wir Deutschen haben dann endlich mal ordentliches Datenvolumen zu bezahlbaren Preisen bekommen. Punkt ist aber, dass es auch natürlich aus der Internetwelt immer einfacher wurde, weltweite Plattformen zu bauen. Viele Leute denken, wenn ich eine Plattform baue, dann wollen alle Leute meine Plattform und dadurch muss ich natürlich hohe Skalierbarkeit und Flexibilität haben. Das wird ja auch immer als einer der Vorteile von Microservices geültigt. Ich denke, dass diese ganze Trendwende schon dazu geführt hat, genauso wie ein Punkt der Entwickler-Performance. Wie viel Code kannst du aus deinem Team eigentlich so raussqueezen? Weil die Zeit, wo Microservices hochkamen, kam auch so ein bisschen die Agilität hoch, das agile Manifest. Vielleicht kennst du das noch, so Storypoints und Kanban und Scrum. Extreme Programming war ja noch davor, aber da war ja immer so der heilige Gral, unabhängige Entwicklerteams und unabhängige Bereitstellungen zu erreichen, dass jedes Entwicklungsteam eigenes Service entwickeln, testen und bereitstellen kann, damit wirklich Teams autonom arbeiten können. Ich habe sehr, sehr selten eine Firma gesehen, die das wirklich geschafft hat, also zumindest vom Ende, von der Datenbank bis hin zum Frontend. Dann kam natürlich auch noch in dieser ganzen Zeit mehr und mehr Programmiersprachen auf. Also es war ja früher war ja immer alles PHP. Alles was im Web war, war PHP. Und irgendwann kam Ruby und da gab es halt noch so die ein oder andere Firma, die hat so Perl gemacht. Ich glaube Booking.com, es läuft immer noch auf Perl. Aber irgendwann kamen halt die coolen Kids. Die mit dem Gopher. Go. Oder die mit der Krabbe. Rust. Und so weiter. Und irgendwann hat Python Django auch nochmal gemerkt, hey, ich kann auch nicht nur Data Science, sondern ich kann jetzt hier auch Web. Und irgendwann kam halt Node.js und JavaScript konnte auch auf einem Server genutzt werden. Also, da ging es darum, viele Leute wollten mal weg von dem, was sie schon jahrelang machten, zu mal was Neuem. Also, die technologische Vielfalt war dann auch so ein Punkt, meines Erachtens nach. Und wenn du dir mal die Aktienkurse von Amazon und Google Cloud und so weiter ansiehst, dann fallen die irgendwie auch in diesem Zeitpunkt, da gehen die Aktienkurse auch alle durch die Decke, weil jeder sagt irgendwie Cloud und weg vom Data Center und so weiter und so fort. Und wenn du schon mal in Monolithen in die Cloud migriert hast, dann kennst du den Begriff Lift and Shift. Und jeder der das schon mal gemacht hat, da geht grad so ein bisschen Gänsehaut über die Arme, weil das ist alles andere als spaßig. Aber so die ganzen Punkte, die fallen so alle in diese Zeit finde ich. Die Einfachheit weltweite Plattformen zu bauen, das bedeutet unabhängige Skalierbarkeit und Flexibilität. Agile Entwicklerteams, unabhängige Entwicklerteams, technologische Vielfalt, Ausfallsicherheit und Robustheit mit Cloud und DevOps und was es da nicht noch alles gibt. Ist natürlich alles ein bisschen weit hergeholt, diese These, aber ich hab das Gefühl, es gibt nicht den einen Grund, sondern all das fällt so in einen Eimer.",
            "start": 570979,
            "end": 736928,
            "confidence": 0.7979650735294121,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Aber warum sollten Microservices alle diese Probleme lösen? Ich kann ja trotzdem an Monolithen in die Cloud deployen, bin dann skalierbar, habe die Flexibilität, indem ich einfach den mehrfach auf verschiedenen Servern hochboote. Ich habe dann die Ausfallsicherheit und Robustheit. Also wo liegt da der Vorteil dann?",
            "start": 737328,
            "end": 755077,
            "confidence": 0.8015106382978722,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Bleiben wir einfach mal bei der Skalierbarkeit und bei den Monolithen. Jetzt mal angenommen, du hast ein Monolith, das ist eine Executable. Das sind so 20, 30, 40, 80, 100.000 Lines of Code in einer Java Executable. Wenn du die hochbootest, dann braucht die erstmal 40 GB RAM. Natürlich kannst du den skalieren. Da brauchst du in der Cloud aber auch immer nur Maschinen mit 40 GB RAM. Wenn ich davon jetzt aber den Payment-Service rausnehme und er macht wirklich nur die Payment-Zahlungen, dann braucht er 2 GB RAM. Das bedeutet, ich kann 20 Services vom Payment-Dienstleister starten zu deutlich geringeren Kosten, wenn ich jetzt nicht den 100%igen Monolith skalieren muss. Also wenn du das in eine Cloud-Hardware umrechnest, das ist ja dann schon ein einzelner Punkt. Offen gesprochen heißt das natürlich nicht, dass der Payment-Service dann besser läuft oder ähnliches. Also der Monolith kann trotzdem stabiler sein. Ein weiterer Grund, der mir gerade einfällt, ist vielleicht auch einfach nur, dass die ganzen Software-Entwicklerinnen und Entwickler vielleicht auch einfach nur mal was Neues machen wollten. Die waren es satt, immer an dieser Legacy-Software zu arbeiten und haben gedacht, da kommt was Neues, da kann ich mal wieder meinen Spieltrieb rausholen und experimentieren.",
            "start": 755237,
            "end": 815115,
            "confidence": 0.7342524752475247,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Ich hatte dazu mal 2015, glaube ich, war das, auch die Möglichkeit, einen ziemlich interessanten Talk zu sehen von Chad Fowler. Ich finde es immer noch einen sehr interessanten Talk. Haben wir ihn gerade kürzlich jetzt wieder mal angeschaut. Und zwar war das damals der CTO von Wunderlist. Können sich vielleicht manche noch erinnern, diese To-Do-List, die mal extrem geboomt hat und dann von Microsoft aufgekauft wurde schlussendlich. Und der hatte eigentlich einen extremen Ansatz, genau das, was du jetzt alles erklärt hast mit Microservices, aber der ist fast noch einen Schritt weitergegangen. Der hat Wunderlist dann komplett auch neu gebaut mit dem Team und dem seine Herangehensweise war, man kann einfach jede Programmiersprache verwenden, die man will, solange es, glaube ich, zwei Developer gibt in der Firma, die die Programmiersprache verwenden. Du brauchst nicht nachfragen. Du kannst dein Microservice entwickeln in deiner Programmiersprache deiner Wahl. Solange es so klein ist, dass man es auch jederzeit in einer anderen Programmiersprache wieder neu programmieren kann und wegwerfen kann. Also er wollte, dass man Software programmiert, um sie wegzuwerfen, mit dem Ziel wegzuwerfen. Und er wollte auch keine Upgrades oder große Updates. Sein Ziel war, das alles so klein zu halten, dass man es ganz einfach immer neu programmieren kann und auch gar nicht diese Probleme hat mit den ganzen Updatepfaden und Upgrades von den Frameworks. Und um das zu unterstützen, hat er das natürlich alles automatisieren müssen. Das heißt, Deployment automatisieren, die ganze Infrastruktur automatisiert. Also die Automatisierung, meiner Meinung nach, war auch ein großer Punkt, der dort hineingespielt hat, weil man hat dann erst begonnen, durch diese Microservices sehr viel zu automatisieren. Weil früher der klassische Ops-Ansatz war, ich habe meine Monolithen, ich habe mein Best Script, das wird manuell irgendwie deployed. Und sobald man in die Microservices-Ecke geht, musst du die ganzen Sachen automatisieren, damit dein Deployment überhaupt noch skaliert. Weil wenn du 70 Microservices zum Beispiel hast, dann musst du das automatisieren und kannst es gar nicht mehr manuell machen. Also ich glaube, das war auch so ein Trend, der da mitgeschwommen ist mit dieser ganzen Microservices-Ecke und den man oft vergisst. Also es geht gar nicht nur um diese Microservices, sondern auch was sich so rundherum entwickelt hat, meiner Meinung nach.",
            "start": 815335,
            "end": 940828,
            "confidence": 0.8076951871657763,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Also hat er die Microservices eigentlich als Tool genutzt, um seine Infrastruktur zu, ich sag mal, modernisieren, oder? Beziehungsweise deutlich zu automatisieren und somit über Zeit die Kosten der Firma zu drücken. Also er hat das eigentlich zum Tool ausgerufen, die Effizienz zu steigern.",
            "start": 941148,
            "end": 958339,
            "confidence": 0.8284999999999999,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Ja, es war natürlich nicht sein direktes Ziel. Sein direktes Ziel war eben, die Programmiersprachen zu haben, produktive Leute, die alle die Programmiersprache verwenden können, die sie gern programmieren. und dadurch produktiver zu werden. Aber du musst dann natürlich auch viel automatisieren, damit du das ermöglichst. Und ich glaube, bei Microservices war das natürlich immer eine Grundvoraussetzung, weil wenn du Microservices verwenden willst, um deine Teams produktiver zu machen und selbstständiger, dann brauchst du dieses ganze Tooling rundherum. Und einerseits war das natürlich ein großer Schritt in die Richtung, diese Tools zu entwickeln, die Infrastruktur zu automatisieren. Aber meiner Meinung nach auch am Ende mehr oder weniger der Gnickbruch, warum das teilweise so schlecht funktioniert hat, weil das Tooling und die ganze Automatisierung ein extremer Aufwand ist, Monitoring und alles, was dazugehört, wenn du so eine Microservice-Architektur überhaupt aufbaust.",
            "start": 958879,
            "end": 1008882,
            "confidence": 0.7999928057553952,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Wenn man sich mal im Internet umschaut und nach Nachteilen von Microservices googelt oder Chat-GPT fragt oder wo auch immer ihr eure Informationen heutzutage herbekommt, dann wird immer der Aufwand oder der höhere Aufwand für Infrastruktur und Betrieb erwähnt, weil es ist leider Fakt, dass Microservice eine deutlich effizientere Infrastruktur und auch Standards erfordert, weil primär viele Microservices betrieben werden müssen.",
            "start": 1009169,
            "end": 1032226,
            "confidence": 0.834967213114754,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Was ist denn eigentlich für dich ein Microservice, wenn wir gerade dabei sind? Wo fängt denn bei dir ein Microservice an und wo hört es auf? Wir sprechen ständig jetzt über Microservices, aber was ist eigentlich ein Microservice für dich? Ich habe mir das im Vorfeld auch überlegt und meiner Meinung nach ist es sehr unklar, was ein Microservice eigentlich ist.",
            "start": 1032445,
            "end": 1047601,
            "confidence": 0.7321639344262295,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Um Microservices zu erklären, muss ich erst mal mein Verständnis von Monolithen erklären.",
            "start": 1048261,
            "end": 1052926,
            "confidence": 0.824923076923077,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Okay, dann darfst du zuerst Monolithen erklären.",
            "start": 1052986,
            "end": 1055128,
            "confidence": 0.7112857142857143,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Für mich ist halt Monolith einfach nur eine Anwendung, die als ein einzig großer zusammenhängender Block entwickelt wird und auch bereitgestellt wird. Das kann von mir aus auch eine einzelne executable sein, ein ausführbarer Prozess. Den schmeiße ich auf einen Server oder von mir auch über die Wand zum Betriebsteam, zum Ops-Team oder wo auch immer. Dann sage ich hier executable start buff Und dann läuft das. Oder halt mit nem Apache 2 Server oder Nginx und FPM mit PHP oder oder oder. Punkt ist aber ne ganze Menge Source Code, mehrere Verantwortlichkeiten, ne Datenbank Connection da drin und der händelt einfach alles von meiner Applikation. Hab ich jetzt so ne Webseite wie Spotify.com, dann wär das einfach ne Million Zeilen an Code, alles in einem Repository, alles in einer Executable, sei es Java oder in 1000 PHP-Files, wenn's PHP ist oder Alles relativ, wenn ich jetzt sage dichte Kopplung, dann meine ich jetzt gar nicht eine schlechte Software Architektur selbst, sondern es hängt halt alles schon zusammen. Das geht alles über ein paar Controller.",
            "start": 1055494,
            "end": 1111084,
            "confidence": 0.8110000000000004,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Etc. etc. Okay, und Microservices im Gegenzug?",
            "start": 1111124,
            "end": 1114225,
            "confidence": 0.6764285714285714,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Ein Microservice, darunter verstehe ich eigentlich, dass eigenständige Dienste in eigene Anwendungen aufgeteilt werden, damit diese unabhängig voneinander entwickelt, bereitgestellt und auch skaliert werden können.",
            "start": 1114265,
            "end": 1125168,
            "confidence": 0.8373199999999998,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Also ganz viele Monolithen.",
            "start": 1125208,
            "end": 1126448,
            "confidence": 0.84925,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Eigentlich ja, doch diese ganz vielen Monolithen, wir nennen sie jetzt hier Microservices einfach mal, haben natürlich einen deutlich kleineren Scope.",
            "start": 1127347,
            "end": 1134753,
            "confidence": 0.7814761904761905,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Und wie definierst du den Scope oder welchen Scope meinst du jetzt? Den Funktionsscope?",
            "start": 1134813,
            "end": 1139356,
            "confidence": 0.6384285714285715,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Ja, den Domänenscope, den Funktionsscope. Bei Spotify wäre das dann zum Beispiel ein Suchservice.",
            "start": 1139397,
            "end": 1144420,
            "confidence": 0.7362142857142856,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Und auf der Teamseite?",
            "start": 1144460,
            "end": 1145842,
            "confidence": 0.8490000000000001,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Von diesem Team der Scope und die Domäne ist dann wirklich Suche.",
            "start": 1145882,
            "end": 1148864,
            "confidence": 0.8534166666666666,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Und zwar nur ein Team.",
            "start": 1149284,
            "end": 1150485,
            "confidence": 0.6506000000000001,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Ja, im Optimalfall ein Team, was dann die volle Autonomie über die Suche hat. Je nachdem kann es natürlich hinten dran vielleicht noch ein paar mehr Teams sein. Vielleicht gibt es in der Suchdomäne noch ein spezielles Such-Storage-Backend oder ähnliches. Das weiß ich jetzt nicht. Das kommt dann sehr wahrscheinlich auf die Größe der Organisation, der Daten und so weiter an. Aber gehen wir einfach mal vom ganz normalen Fall aus. Du hast einen Such-Microservice und ein Team kümmert sich nur um die Features, Bugfixes, Weiterentwicklung, Betrieb von dem Such-Microservice. Und was viele Leute jetzt immer so unter Microservice verstehen, ist, dass der Such-Service dann über Netzwerkanfragen mit anderen APIs Daten austauscht. Das ist so die, ich würde mal sagen, globale Definition von Microservices, die so im Internet rumschwirrt. Ob ich damit jetzt 100 Prozent d'accord bin, dass Microservices immer ein Netzwerk Calls machen müssen, da kommen wir gleich noch zu.",
            "start": 1150525,
            "end": 1202341,
            "confidence": 0.7880662251655631,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Aber dieses Suchbeispiel, das war doch schon immer eigenständig. Die Suche hat meistens einen eigenen Stack gehabt, da wie irgendein Elasticsearch oder ähnliche Dinge. Das war doch schon immer eigenständig. Also wenn man auf der Ebene agiert, dann war das ein eigener Service, der Suchservice, aber kein Microservice. Also wo ist das Micro da drin?",
            "start": 1202381,
            "end": 1222438,
            "confidence": 0.8210909090909088,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Also ich hab noch etliche male suchen geschrieben wo ich nur SQL query gegen MySQL geschmissen hab und dann mit like prozent like nee mit like prozent suchbegriff und so weiter.",
            "start": 1222858,
            "end": 1233011,
            "confidence": 0.8151290322580645,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Also du hast nie performante suchen geschrieben wolltest du sagen.",
            "start": 1233051,
            "end": 1235735,
            "confidence": 0.5803,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Ich hab suchen geschrieben in einem nicht microservice environment.",
            "start": 1235775,
            "end": 1238338,
            "confidence": 0.8012222222222222,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Und was sind dann Nanoservices?",
            "start": 1238658,
            "end": 1240439,
            "confidence": 0.6224000000000001,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Ja, das ist auch noch mal so ein Begriff, der so durchs Internet schwirrt. Ich hab's mal ein bisschen versucht, ich hab noch nie mit Nanoservices gearbeitet, aber ich hab mal versucht, eine Definition rauszuziehen, und die sagen, der Unterschied zwischen Microservices und Nanoservices ist eigentlich nur die Größe und Granularität. Nanoservices sollen stark dezentralisiert sein und können sogar als Lambda Functions, also Serverless, implementiert werden. Also theoretisch kannst du dir dann eigentlich so als Eselsbrücke merken, jede Lambda-Funktion kann ein Nanoservice sein. Muss ich zugeben, finde ich ein bisschen übertrieben, aber gut, hey.",
            "start": 1240459,
            "end": 1273803,
            "confidence": 0.8027872340425534,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Also das, was der Chad Fowler mit Wunderlist damals eigentlich so gemacht hat, das wäre dann eher schon so auf Nanoservice-Ebene, dass das wirklich so kurz ist. Er hat es in der Präsentation schön gesagt, die Codezeile, das Programm darf so lang sein, wobei er gleichzeitig mit seinen Fingern gezeigt hat, wie lang diese Funktion sein darf, also Daumen und Zeigefinger weggestreckt voneinander, so lang darf das Programm sein. Also das geht dann mehr in die Nano-Service-Ecke und Serverless, so wie man heutzutage auch vielleicht schnell 100 Zeilen mal programmiert, das in den Lambda Function auslagert und dann dementsprechend aufruft.",
            "start": 1273823,
            "end": 1310132,
            "confidence": 0.8412700000000001,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Ich habe den Talk jetzt nicht gesehen, aber es hört sich so an. Und deswegen sage ich, irgendwo finde ich es halt ein bisschen übertrieben dann. Aber hey, es mag sehr wahrscheinlich auch valide Anwendungsfälle dafür geben.",
            "start": 1310652,
            "end": 1320856,
            "confidence": 0.7816756756756759,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Also was für mich eigentlich ausschlaggebend ist bei dieser Definition, ist weniger die Definition an sich oder irgendwie eine Länge oder den Funktionsscope. Für mich war eigentlich immer ausschlaggebend oder wichtig bei dieser Definition, dass es um ein Team geht, dass du die Teams unabhängig machst. Und wenn ein Team einen gewissen Scope hat, zum Beispiel die Suche oder vielleicht sogar nur ein Teilbereich der Suche, dann sollte dieser Service ausgelagert werden, damit das Team dementsprechend selbst deployen kann, selbst debuggen kann, also wie eine kleine Firma agieren kann, wie ein kleines Startup in der Firma und dementsprechend dann nur eine API zur Verfügung stellt. Das war für mich so eigentlich die Definition von der Größe von einem Microservice und das kann natürlich dann ganz unterschiedlich sein, je nach Team und je nach Funktionsaufwand.",
            "start": 1321177,
            "end": 1368731,
            "confidence": 0.841589552238806,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Aber das triggert für mich auch eine interessante Frage. Deiner Meinung nach löst die Microservice versus Monolith-Frage ein technisches oder ein organisatorisches Problem?",
            "start": 1368771,
            "end": 1377519,
            "confidence": 0.8249130434782608,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Also primär meiner Meinung nach ein organisatorisches, natürlich auch ein technisches, wenn du zum Beispiel zwei unterschiedliche Programmiersprachen verwenden willst, wenn dein Backend for Frontend PHP ist und dein echtes Backup Java, dann wirst du da zwei unterschiedliche Services haben, einmal in PHP und einmal in Java zum Beispiel, wie es ja oft der Fall ist. Also das ist dann mehr die technische Seite. Aber ich glaube, die organisatorische war damals eigentlich noch viel wichtiger, weil du hattest extrem große Teams, hunderte Leute, die an einem Source Code gearbeitet haben. Und da hat es natürlich überall geknirscht und geknatscht. Und das war dann extrem schwierig mit dem Deployment. Und wie bekommst du die 100 Leute unter einen Hut am Ende? Und darum hat meiner Meinung nach Microservices so ein Erfolg gehabt am Anfang und so ein Hype, weil das eben diese Erleichterung für die Teams bedeutet hat. wenn du die Strukturen ausschneidest, das ganze Deployment automatisierst, die Verantwortung von dem Ops-Team zurück in die Developer-Teams gibst. Also es war mehr so eine gesamte Bewegung, meiner Meinung nach, und weniger eine technische Änderung.",
            "start": 1377759,
            "end": 1440211,
            "confidence": 0.8095384615384618,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Da bin ich auch d'accord bei dir. Natürlich, wie du sagtest, die technischen Vorteile sind toll, aber ich bin mir nicht sicher, wie viele Firmen wirklich unabhängige Skalierung und Co. brauchen versus sie denken, sie bräuchten es.",
            "start": 1440251,
            "end": 1452815,
            "confidence": 0.8064864864864864,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Und was vielleicht auch noch dazugekommen ist, es war überhaupt technisch möglich zu dieser Zeit. Mit der ganzen Dockerisierung ist es erst langsam gekommen, dass ich überhaupt etwas in PHP deployen kann und in Java möglichst einfach, ohne dass ich jetzt meine eigenen Server und solche Dinge zur Verfügung habe. Also es war schon auch überhaupt die technische Lösung vorhanden, damit ich diese Aufsplittung in Services überhaupt durchführen kann.",
            "start": 1453075,
            "end": 1476753,
            "confidence": 0.8300724637681159,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Da sprichst du aber noch ein spannendes Thema an. Und ich habe mir die Frage gestellt, ist der Erfolg von Kubernetes direkt mit dem Hype um Microservices zu verbinden?",
            "start": 1477532,
            "end": 1487138,
            "confidence": 0.8190689655172415,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Das glaube ich überhaupt nicht, weil Kubernetes war ja viel, viel später als Microservices. Aber was ich natürlich schon unterschreiben würde ist, dass man heute sehr wohl eine serviceorientierte Architektur im Normalfall hat und vielleicht weniger Micro- oder Nano-Services. aber Services. Und wenn du mehrere Services hast, dann musst du die auch sinnvoll deployen, die ganze Automatisierung, die dahinter steckt. Und da sind wir dann wieder bei Kubernetes zu Hause. Wobei ich gerade neulich so ein nettes Bild gesehen habe, wo jemand so in einem Kontrollraum von einem Atomkraftwerk so im Vordergrund steht und sagt, das ist unser Kontrollraum von Kubernetes. So einfach ist es ein Pod zu deployen. Das hat mich sehr an die Realität erinnert.",
            "start": 1487158,
            "end": 1525783,
            "confidence": 0.7888119658119657,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Darf ich dich ganz kurz korrigieren? Das erste Release von Kubernetes war 2014 und die erste Kubernetes 1.0 war im Juli 2015.",
            "start": 1526243,
            "end": 1533936,
            "confidence": 0.7115909090909089,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Ja, aber realistisch, der Hype war viel, viel später. Die ersten Microservices waren wahrscheinlich auch 2000 oder so.",
            "start": 1533946,
            "end": 1541329,
            "confidence": 0.7430555555555556,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Sagte der Late Adopter Wolfgang.",
            "start": 1541369,
            "end": 1543010,
            "confidence": 0.7626,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Ich verwende immer noch kein Kubernetes. Nachdem ich mich in Atomkraftwerken und in Kontrollräumen schlecht auskenne, bleibe ich noch auf einfachen Infrastrukturen.",
            "start": 1543050,
            "end": 1550093,
            "confidence": 0.6960000000000002,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Okay, dann löse dich mal bitte von Kubernetes, sondern geh hin zu, ich würde schon sagen, fast Vorgängern. Apache Mesos und Co. Worum es da ging, eigentlich über das übergeordnete Thema Container-Scheduling. Würdest du sagen, dass dieses ganze Cloud-Native-Environment, die Container-Scheduler von den Hyperscalern und Co., dass der Erfolg schon so ein bisschen verwoben war mit Microservices? Das eine Thema hat bestimmt das andere befeuert oder so, aber würdest du sagen schon, dass es eine Relation zueinander hat?",
            "start": 1550694,
            "end": 1580087,
            "confidence": 0.8049487179487179,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Ja, ich glaube, die Automatisierung an sich ist, wie gesagt, ein wichtiger Punkt. Und die hat natürlich die gesamte Bewegung und die Entwicklung in dem Automatisierungsbereich stark befeuert. Also die ersten waren ja so, die dann ganz groß rausgekommen sind, waren ja eigentlich Netflix, die das komplett automatisiert haben. Vor allem dieses ganze Monitoring, weil das Debugging wird ja dann auch extrem schwierig, wenn du hunderte Services hast, Microservices. Und irgendwo gibt es ein kleines Problem. Du brauchst Rechry-Mechanismen, du musst dein Netzwerk viel besser monitoren. Plötzlich ist dein Netzwerk vielleicht ein Bottleneck. Also die Probleme verschieben sich ja extrem stark bei der Microservice-Architektur. Und Netflix hat begonnen, Dinge zu automatisieren. Und ich glaube, die normale Welt ist dann nachgezogen und hat halt dementsprechend auch Open Source-Produkte dann entwickelt, um eben diese ganze Automatisierung voranzutreiben. Und die Containerisierung ist ja eigentlich auch, ich weiß nicht, ob es ein Produkt ist oder was da wen enabled hat. Aber ich glaube grundsätzlich, dass das technisch überhaupt möglich ist. Das ist schon eine Grundvoraussetzung.",
            "start": 1580107,
            "end": 1638033,
            "confidence": 0.7869064327485382,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Neben Kubernetes gibt es ja immer noch Plattform-as-a-Service-Tools wie Cloud Foundry, OpenShift und OpenStack. All das hat zu folgendem Begriff geführt, den ich sehr schön fand. Agilisierung des Betriebs.",
            "start": 1638073,
            "end": 1651442,
            "confidence": 0.8601034482758622,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Ja, und ich glaube, das trifft es eigentlich ganz gut, weil wenn ich mich zurückerinnere, wie die Teams das so gesehen haben und was sie für eine Hoffnung hatten, dass sie wegkommen von diesen Ops-Leuten, von denen sie abhängig sind, dass das Ganze agiler wird, das Deployment und wie sie arbeiten, dass sie selbstständig sind, dass sie plötzlich auch Zugriff auf eine Datenbank bekommen, da vielleicht das Schema ändern können, ohne irgendwen von Obst zu fragen. Das war so richtig Lichtblick für die Teams. Und darum ist, glaube ich, die Agilisierung schon ein Begriff, der das eigentlich ganz gut zusammenfasst. Und da waren Microservices meiner Meinung nach auch super erfolgreich, weil die haben diese ganze Bewegung vorangetrieben und weitergebracht. Und auch wenn man heute sagt, okay, man will wieder weg von Microservices, wobei, da bin ich auch so gespalten, weil ich glaube, es gibt sehr viele Services. Und auch wenn man sagt, man geht zurück zu Monolithen und fasst vielleicht gewisse Services wieder zusammen. Ich glaube, die Service-Architektur bleibt. Und es gibt wenig größere Software-Stacks, meiner Meinung nach, wo es wirklich nur ein Service gibt, einen Monolithen, weil gewisse Teile sind ausgelagert, Payment zum Beispiel oder solche Dinge. Also, dass man mehrere Services hat, ist, glaube ich, schon noch der Alltag. Auch wenn man vielleicht keine Nano-Services natürlich jetzt mehr hat.",
            "start": 1651735,
            "end": 1722109,
            "confidence": 0.7999185520361993,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Das bringt mich wieder auf die nächste Frage. Sind Microservices denn immer einzelne Systeme oder können Microservices auch innerhalb eines Monolithen existieren?",
            "start": 1722129,
            "end": 1732235,
            "confidence": 0.8734999999999998,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Ja, ich glaube, das ist der nächste Punkt, was da in dieser Welle dann entstanden ist. Und man hat eigentlich daraus gelernt, okay, man will die Teams unabhängig haben. Und dann hat man sich überlegt, gibt es nicht eine Möglichkeit, dass man die Teams unabhängig hat? in einem Monolithen und damit die Produktivität der einzelnen Teams sicherstellt, aber trotzdem am Ende einen Monolithen deployed. Und ich glaube, die ganze CI-CD-Welle, die da eigentlich entstanden ist in die Automatisierung hinein, die hat eigentlich auch gezeigt, wenn wir das alles automatisieren, die Tests automatisieren, das Deployment automatisieren, einen super lokalen DevStack haben, den man schnell hochbooten kann. Dann enabelt man da auch die Teams durch Modularisierung im Source Code. Aber jeder arbeitet am selben Monolithen. Und ich glaube, in die Richtung ist dann auch stark gearbeitet worden. Weil dann fällt natürlich die ganze Komplexität weg von deinem Netzwerk, von den Problemen, was machst du, wenn ein Service nicht erreichbar ist? Sendest du ein Request nochmal, wenn gerade das Service down ist oder zu langsam? Oder was machst du dann? Also es ist eine extreme Komplexität im Hintergrund, wenn du ganz viele Services ansprechen musst. Und wenn man das in einem Monolithen hat, dann ist es natürlich wesentlich einfacher, weil da gibt es nur einen Source-Code-Block, den man deployed. Wenn du aber gleichzeitig die Flexibilität in die Teams bringst, dann hast du natürlich gewonnen. Also glaube ich sehr wohl, dass es heutzutage möglich ist und man hat gelernt, wie kann ich die Vorteile aus der Microservice-Welt übernehmen in den Monolithen. Und wenn man heutzutage die Monolithen-Entwicklung ansieht, ist die natürlich komplett unterschiedlich als wie vor zehn Jahren, wo man eben, ob Steam gehabt hat, manuell irgendwie Tests ausgeführt hat, falls man überhaupt Tests gehabt hat. vielleicht keine saubere Modularisierung im Source-Code hatte, alles war irgendwie zusammengestöpselt, im gleichen Fall womöglich. Also man hat da schon aus der Vergangenheit gelernt und das Beste aus beiden Welten vielleicht vereint, wenn man es so plakativ sagen will.",
            "start": 1732815,
            "end": 1843171,
            "confidence": 0.8160725075528704,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Aber meine Frage ist jetzt, hast du eigentlich in deinem langen Monolog gesagt, das müssen einzelne Systeme sein oder müssen nicht? Weil das ist nicht ganz klar für mich gewesen.",
            "start": 1843231,
            "end": 1849373,
            "confidence": 0.7445,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Nein, nein, es kann eine Monolith sein, solange es modularisiert ist.",
            "start": 1849658,
            "end": 1853039,
            "confidence": 0.6470909090909092,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Selten aber wahr, ich bin einer Meinung mit dir.",
            "start": 1853079,
            "end": 1856040,
            "confidence": 0.890888888888889,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Das sollten wir unbedingt ändern.",
            "start": 1856080,
            "end": 1858461,
            "confidence": 0.7634000000000001,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Microservices müssen nicht immer einzelne Systeme sein.",
            "start": 1858501,
            "end": 1862343,
            "confidence": 0.8648571428571429,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Naja, aber sie heißen dann nicht mehr Microservices, also üblicherweise spricht man dann nicht mehr von Microservices. sondern eher von Modulen oder man könnte natürlich auch verschiedene Services in einem Monolithen starten, aber das ist ja eher unüblich. Also man vereint es dann schon irgendwie über Libraries, Module und nennt es selten Microservices, würde ich mal sagen. Aber wenn du natürlich eine unterschiedliche Route hast in deinen Monolithen, dann hast du vielleicht auch ein anderes Subsystem, was ein anderes Team maintaint. Aber du würdest es wahrscheinlich nicht Microservice nennen, sondern irgendwie Submodul oder Modul oder so in der Richtung.",
            "start": 1862403,
            "end": 1899993,
            "confidence": 0.7733939393939393,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Meines Erachtens nach geht das alles runter auf die reine Software-Architektur. Wie baust du deine einzelnen Module auf? Welche Interfaces werden provided? Welche Verantwortlichkeit gibt es da? Und wie koppelst du die miteinander? Und so ein paar Guidelines aufzustellen, damit man in einer Firma oder in Software-Teams effizient miteinander arbeiten kann, finde ich immer ganz sinnvoll. Und besonders für Microservices habe ich da die Independent System Architecture Principles gefunden. Die werden von der Firma InnoQ bereitgestellt, verlinken wir auch in den Shownotes.",
            "start": 1900713,
            "end": 1927758,
            "confidence": 0.7878292682926826,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Ich bin sehr enttäuscht, dass du nicht mit einer DIN-Norm um die Ecke kommst, sondern mit irgendeinem amerikanischen Standard.",
            "start": 1927778,
            "end": 1932801,
            "confidence": 0.705421052631579,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Soviel ich weiß, ist InnoQ eine deutsche Firma. Die haben es halt nur noch nicht bei dem Konsortium für deutsche Industrienormen eingeführt oder vorgeschlagen.",
            "start": 1933161,
            "end": 1940385,
            "confidence": 0.773125,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Ich glaube fast, es gibt nicht die Namen für Microservices, bin ich mir fast sicher, aber vielleicht sind das die sinnvolleren Principles.",
            "start": 1941010,
            "end": 1947273,
            "confidence": 0.7159545454545455,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Auf jeden Fall umfassen die ISA-Prinzipien neun Prinzipien und das sind relativ High-Level-Prinzipien, die aber eine generelle Guidance geben, wie man Microservices entwickelt, damit eine Microservice-Architektur denn auch Sinn macht und all die Herausforderungen wie sowas wie Deployment-Monolithen und Co. vermeiden kann. Da gibt es zum Beispiel um die Trennung von Makro- und Mikroarchitektur. Und das Setzen von Regeln in Makroarchitektur. Wie zum Beispiel ein Microservice loggen sollte, wie die Authentifizierung abläuft. All die generellen Dinge sollten in der Makroarchitektur festgelegt sein. Wie das Ganze, wie der Authentifizierungsmechanismus dann aber implementiert wird oder das Logging implementiert wird, welche Library genutzt wird, das ist Teil der Mikroarchitektur. Und das obliegt dann dem jeweiligen Entwicklerteam. Das bedeutet, das Entwicklerteam hat eigentlich die Implementationshoheit, aber auf teamübergreifender Ebene definiert man die Makroarchitektur, damit man nämlich sowas wie zum Beispiel ein standardisiertes Deployment oder standardisierte Operations wie Monitoring gewährleisten kann.",
            "start": 1947313,
            "end": 2010677,
            "confidence": 0.8554315068493152,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Also das ist eine Definition, wie ich in meiner Firma gewisse Dinge organisiere, auf was für einer Ebene ich was definiere.",
            "start": 2011075,
            "end": 2018378,
            "confidence": 0.8403809523809523,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Genau, da geht es aber unter anderem auch zum Beispiel um Deployment. Zum Beispiel ein Prinzip sagt, jeder Microservice sollte eine unabhängige Continuous Delivery Pipeline sein, dass diese unabhängig releasable ist. Oder die Art und Weise, wie du ein Service konfigurierst oder monitorst oder darauf alertest, ist für alle gleich. Das bedeutet, du hast ein gewisses Set an Standards, die du erfüllen musst. Oder da geht es auch um Resilience, wie zum Beispiel, wie ein Microservice sich zu verhalten hat, wenn er einfach mal ungraceful gestoppt wird, also mit einem Sick Kill oder ähnliches.",
            "start": 2018418,
            "end": 2053214,
            "confidence": 0.8515106382978728,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Aber das gilt dann ja auch für jedes Service. Also wenn ich mal die Principles so durchlese, macht das ja für jedes Service Sinn und nicht nur für Microservices in dem Sinne. Wo wir wieder bei dem sind, ob nicht einfach die Microservice-Welt so in der Service-Welt langsam hinüberdriftet, was einfach kein cooler Hype-Begriff mehr ist.",
            "start": 2053467,
            "end": 2070846,
            "confidence": 0.816392857142857,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Ich würde sagen, die ISA-Prinzipien können auch ohne Probleme auf Monolithen angewandt werden, doch den realen Value kriegen sie erst in Microservices, wenn du die Vorteile der Standardisierung wirklich rausziehen kannst, wie zum Beispiel das einheitliche Deployment, das einheitliche Operation und so weiter. Umso mehr Microservices du hast, umso mehr Sinn machen diese ISA-Prinzipien dir, weil du mehr Value rauskriegst und weniger diskutieren musst.",
            "start": 2071246,
            "end": 2093458,
            "confidence": 0.78440625,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Aber das ist eben meine Argumentation. Ich glaube, dass heutzutage die Best Practices, um einen Monolithen zu deployen, zu entwickeln, auch vielleicht auf mehreren Teams, eigentlich aus dieser Microservice-Ecke kommen und mittlerweile aber einfach Best Practices ganz allgemein sind, egal ob es ein Microservice, ein Service, ein Monolith, wie du das auch immer nennst, du solltest eine CI, CD-Pipeline haben, du solltest eine unabhängige Möglichkeit für dein Team haben, das zu deployen und so weiter. Also diese ganzen Dinge, sind halt heute Best Practices, auch wenn sie vielleicht aus der Microservice-Ecke kommen. Und heute würde niemand mehr sagen, eine gute CI-CD-Pipeline, die von dem Team maintained wird und verwendet werden kann, ist nur im Microservice-Umfeld möglich, sondern es sollte meiner Meinung nach heute Best Practice sein, egal in was für einem Umfeld und egal in welcher Architektur du arbeitest.",
            "start": 2093799,
            "end": 2139935,
            "confidence": 0.7772230215827336,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Ja, ich find das schön, wie du als Freelancer immer in deiner schönen, heilen Welt da rumtunst. Und das, was du grad gesagt hast, damit verdienst du sehr wahrscheinlich auch einen Job, wenn du nämlich zu altbackenen Firmen gehst und denen sagst du immer, das ist jetzt Best Practice und das sollten wir jetzt tun. Und hier ist mein Angebot für den nächsten Teamworkshop. Aber die Realität sieht halt ein bisschen anders aus, weil all das, wovon du da redest, nämlich jeder sollte seine unabhängige ICD-Pipeline haben und so weiter und so fort, Tut mir leid, das ist alles nicht so einfach, wenn sich einfach mal drei Teams die Köpfe einschlagen, wie das nämlich hier alles auszusehen hat.",
            "start": 2140570,
            "end": 2169934,
            "confidence": 0.7694661016949156,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Ja, ich sage bewusst, es sollte so sein, aber ich spreche mir nur dagegen aus, dass ich jetzt sagen muss, ich muss eine Microservice-Architektur einführen. damit ich eine sinnvolle CI-CD-Pipeline aufbauen darf. Das eine schließt das andere ja nicht aus oder mit ein, sondern Best Practices und die kann ich dann in einer Microservice-Architektur fahren, diese Best Practices, aber auch mit einem Monolithen.",
            "start": 2170335,
            "end": 2194307,
            "confidence": 0.784301587301587,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Da bin ich ja voll bei dir. Doch ich sage auch, dass umso mehr Services du bauen möchtest, angenommen die Firma befindet sich jetzt gerade in der Strategie, wir bauen jetzt alles auf Microservices, dass das Investment, ein einheitliches Regelset dafür zu haben, du hast später einen höheren Benefit, wenn du mehr Services hast, weil dann die realen Vorteile erst durchkommen, anstatt wenn du das jetzt alles dir in die Köppe einschlägst für einen Service.",
            "start": 2194327,
            "end": 2216490,
            "confidence": 0.7523999999999998,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Ja, und ich glaube auch, dass es mehr Services heutzutage gibt im Standardfall. Also auch wenn der DHH behauptet, sie haben alles auf einem Monolithenlaufen, ich glaube trotzdem, dass die viele Monolithenlaufen haben, weil gewisse Services einfach sinnvollerweise ausgelagert werden. Und wenn wir wieder bei dem Suchbeispiel bleiben, wenn ich da ein Elasticsearch dahinter habe, da macht es einfach Sinn, dass das ein eigenständiges Service ist, weil das kann ich besser skalieren. Das hat andere Anforderungen und wenn es teilweise nur darum geht, dass in meinem Docker-Image gewisse Libraries verfügbar sein müssen, die ich für meinen anderen Service gar nicht brauche, dann deploye ich da vielleicht zwei unterschiedliche Docker-Container für das Ganze, weil es einfach das gesamte Handling vereinfacht am Ende.",
            "start": 2217155,
            "end": 2257923,
            "confidence": 0.7913388429752067,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Aber das, wo wir uns jetzt gerade so ein bisschen drüber zanken, ist ja genau einer der Hauptherausforderungen bei der Einführung beziehungsweise bei der erfolgreichen Nutzung von Microservices. Das ist die Definition von einheitlichen Strategien und Regelsets. Und da möchte ich dir kurz zwei Beispiele nennen, die ich super interessant fande. Und zwar die Firma Delivery Hero hat ein Reliability Manifesto rausgegeben, veröffentlicht auf ihrem Tech-Blog. Und da legen sie eigentlich ihr internes Regelset fest, wie auch ihre Services sich zu verhalten haben, beziehungsweise was ein Service alles bieten muss. Also nicht nur das Service selbst, sondern auch die surrounding infrastructure. Verlinken wir auch in den Shownotes. Super interessant, da geht es halt wirklich dabei um Architektur und technische Schulden, wie das delivered wird, die resilience bei Ausfall, aber auch wie man das kontinuierlich weiterentwickelt bis hin zu we track all incidents we learn from our mistakes und so.",
            "start": 2258580,
            "end": 2315255,
            "confidence": 0.8165436241610735,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Weiter super aber auch da denke mir wieder wenn du da jetzt keine ahnung ob der microservice es steht oder nicht wenn du das microservice den begriff durch monolith ersetzt dann ist dieses ganze dokument wahrscheinlich auch noch gültig und macht absolut sinn.",
            "start": 2315295,
            "end": 2328998,
            "confidence": 0.7712558139534884,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Wolfgang keiner widerspricht dir doch den ganzen aufwand für einen service zu betreiben und alle teams auf dieses alignment zu kriegen du hast dir fehlt ja der hebel.",
            "start": 2329058,
            "end": 2338320,
            "confidence": 0.8529285714285715,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Ja, aber das ist ja nicht in der Realität. Jetzt kann ich mal sagen, du lebst ja vielleicht in deiner heilen Welt, aber in der Realität gibt es schon ganz viele Services. Und meiner Meinung nach, wie gesagt, gibt es ganz wenig Plattformen, wo du wirklich einen Hardcore-Monolithen hast. Und sogar wenn du einen externen Payment-Provider anbindest, weil du hast ja selten dein eigenes Payment und deine eigene Kreditkarten-Abrechnung in-house, Das heißt, du bindest externe Services an. Das heißt, du agierst schon mit externen Services und hast vielleicht intern halt dann nur drei, vier Services und selten nur einen Monolithen. Aber auch da musst du sicherstellen, der muss erreichbar sein, der muss resilient sein. Was passiert, wenn ein Server abschmiert? Die ganzen Dinge hast du auch bei, sogar wenn du nur einen Monolithen hast und sogar da musst du viel Zeit investieren, weil wo ist der Unterschied? Wenn dein Monolith weg stirbt, auf deinem Server, dann muss der neu starten oder was auch immer machen, weil sonst ist dein Service down. Und darum gilt es auch bei den Monolithen.",
            "start": 2339111,
            "end": 2393311,
            "confidence": 0.7996089385474858,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Nicht ganz, weil der Unterschied ist meines Erachtens nach die Komplexität der Implementierung. Du hast ein Monolith und da vorne ist ein Loadbalancer. Der Monolith stirbt, somit sagt der Loadbalancer, ich habe keinen Backend-Service mehr, somit kann der Loadbalancer irgendeine Fehlerseite ausspielen. Hast du jetzt aber hinter dem Loadbalancer 4, 5, 6 Microservices, die gegenfalls hintereinander gechained sind mit asynchronen Requests und so weiter. Ist davon einer down, ist es doch deutlich komplexer, eine Logik in dem anderen Microservice zu implementieren, der den Fehlerfall handeln kann und dann gegebenenfalls einen Error nach vorne rausgibt, weil nur ein Zwanzigstel oder ein Zehntel deiner Infrastruktur down ist. All diese Komplexität muss ja implementiert werden und das ist eine ganz andere Komplexität, das ist eine ganz andere Diskussion, als wenn ich eine Errorseite auf dem Loadbalancer einfach ausspiele.",
            "start": 2393331,
            "end": 2438587,
            "confidence": 0.7991185185185187,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Ja, aber das wäre dasselbe, wenn du hast jetzt einen Monolithen, dein Shopsystem und wenn der Payment Provider down ist, dann geht dein ganzes Shopsystem nicht mehr. Also auch da musst du mit deinen Monolithen dementsprechend agieren und umgehen, wenn das Payment Service down ist. Also mein Argument ist, dass es heutzutage eigentlich fast keine Software mehr gibt, glaube ich mal zu wissen oder zu behaupten, die nicht auf andere Services angewiesen ist. Eine CDN, ein Payment Provider, die Infrastruktur darunter, eine Datenbank oder mehrere Datenbanken, externe Service, wo irgendwelche Wetterdatenabfrage, egal was, aber Das kann mir heute eigentlich niemand mehr erzählen, dass es einen Monolithen gibt, der in sich geschlossen ist und nichts tut außer Monolith zu sein und mit keinem externen Service spricht.",
            "start": 2438957,
            "end": 2484080,
            "confidence": 0.8209119999999995,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Wo du einen Punkt hast, ich glaube wir alle, die Leute in der Softwareindustrie, haben von dem Cloud-Native-Movement und den Microservices gelernt, wie fragil eigentlich das ganze Internet und unsere Programmierung eigentlich sein kann und reagieren darauf. Das stimmt schon. Und du hast auch einen Punkt, dass all diese Elemente mit der Standardisierung und Co., dass diese auch für Monolithen gelten. Ich denke aber auch, dass zum Beispiel um zehn Engineering Teams, a fünf Leute, an einem Monolithen produktiv zu kriegen, ist eine unglaublich hohe Herausforderung bezüglich der Architektur, wie du die Module schneidest, wie die miteinander interagieren Aber ich glaube, das ist.",
            "start": 2484120,
            "end": 2523238,
            "confidence": 0.8119708737864078,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Heutzutage auch wesentlich einfacher geworden als früher. Früher hattest du einfach weniger Möglichkeiten. Heute hast du sogar im Frontend mit Web Components und der ganzen Komponentenstruktur, die die Frameworks anbieten, eine Möglichkeit, gewisse Teile zu schneiden und dass mehrere Teams einfacher an etwas arbeiten. Früher war das einfach wesentlich komplexer und ich glaube, da haben sich auch Best Practices entwickelt, die das ermöglichen, im gleichen Source Code zu arbeiten, das lokal zu testen. Im Idealfall haben die anderen Teams auch ihre Teile super getestet. Das heißt, die Tests laufen automatisch durch in der CIDI Pipeline. Ich kann also weniger kaputt machen von anderen Teams. Ich bin durch die Frameworks oder die Architektur vielleicht auch flexibler, dass ich abgetrennter bin sozusagen oder über ein Modulsystem, wie man es dann auch immer löst. Aber ich kann selbstständig arbeiten, lokal testen, mach weniger kaputt. Es wird automatisch deployed. Und ich glaube, heutzutage ist es wesentlich einfacher, 50 Developer an einem Source Code arbeiten zu lassen, als wie vor zehn Jahren. Weil einfach das Tooling rundherum und die Frameworks wesentlich besser geworden sind. Und darum ist man, glaube ich, auch wieder weggegangen von den Microservices, weil man halt gemerkt hat, dass da auch andere Komplexität existiert. Hashtag Netzwerk unter anderem. und Resilience, weil das Problem natürlich auch irgendwo verschoben wird. Und jetzt probiert man, das halt wieder in einem Monolithen zusammenzufassen, ein bisschen zurückzugehen und das Tooling einfach auszunützen, weil das halt gewisse Sachen vereinfacht. Und wenn man aber trotzdem die Teams produktiv haltet und das sauber trennen kann, hat man im Gesamten natürlich mehr gewonnen. Aber es wird, glaube ich, so eine Mischarchitektur, die einen fetteren Monolithen hat, aber auch vereinzelt externe Services mit einbindet.",
            "start": 2523258,
            "end": 2624626,
            "confidence": 0.82354609929078,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Ich meine, was du gerade ansprichst, ist eine spannende Frage. Betrifft die Diskussion von Microservices und Monolithen nur Backendsysteme? Und du hattest ja schon Webcomponents und Templates und Slots und so weiter angesprochen. Was man halt jetzt in der aktuellen Entwicklung sieht, ist, dass durch Begriffe wie Headless Frontends oder sogar, da geht man jetzt sogar weiter in Microfrontends, dass sich diese ganze Microservice-Architektur nicht nur aufs Backend bezieht, sondern auch aufs Frontend, was natürlich dann mehr oder weniger Sinn macht, weil wir kennen alle diese Memes, wo man ein schönes Frontend hat, eine schöne UI und hinten dran ist so ein Friedhof und das deklariert so das Backend-System. Weil niemand benutzt heute Services, die einfach scheiße zu bedienen sind und somit kann es auch sehr gut sein, dass man halt 50 Entwickler nur fürs Frontend hat. Ich meine mal gelesen zu haben, dass die Spotify-App, die auch nur eine Web-App sein soll, aus mehreren solcher Microfrontends bestehen soll und dass jeder teil irgendwie die seitenleiste und so weiter und so fort dann von einem einzelnen team entwickelt und.",
            "start": 2624926,
            "end": 2682881,
            "confidence": 0.8098547486033522,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Deployed wird ja wie gesagt auch das ist mittlerweile ein standard best practices und ist über komponenten einfach sinnvoll lösbar und Das hat sich einfach geändert, dass du die Sachen schneiden kannst und die Teams unabhängig voneinander daran arbeiten können, sei es im Frontend oder im Backend. Und früher war das halt das große Versprechen mit Microservices wird sowas ermöglicht und heute oder gebrauchst du aber keine Microservices mehr dafür. Du brauchst vielleicht Services, aber dieses Micro fällt zumindest weg.",
            "start": 2682901,
            "end": 2709942,
            "confidence": 0.7792125000000001,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Meines Erachtens nach ist das aber all das, was du sagst, kein Garant dafür, dass die ganze Sache auch erfolgreich umgesetzt wird. Denn wir haben gerade über diese ISA-Prinzipien gesprochen, und dieselbe Firma hat einen schönen Blogbeitrag rausgebracht, warum Microservice scheitern. Weil, nur mal kurz zur Info, InnoQ ist eine Firma, die kümmern sich um Softwarearchitektur, um Technologieconsulting und so weiter. Das bedeutet, die sehen halt sehr viele Projekte. Und die haben mal eine schöne Auflistung gemacht, warum viele Microservice ... Projekte scheitern und einer der Hauptpunkte ist unter anderem die Organisation beziehungsweise die Unabhängigkeit von Teams beziehungsweise auch das Alignment zwischen den Teams hinzukriegen, denn Entscheidungen müssen getroffen und koordiniert werden. Teams müssen kontinuierlich miteinander sprechen. Teams selbst müssen auch eine Entscheidungsgewalt haben über ihre Services. Wir haben gerade über Makro- und Mikroarchitektur gesprochen. Manche Regeln sollten aber global getroffen werden und das kann mit hoher Wahrscheinlichkeit oder sollte nicht immer nur von einer zentralen Gruppe von Architekten gemacht werden. Also da gibt's von Haus aus schon ziemlich viel Friction.",
            "start": 2710570,
            "end": 2775381,
            "confidence": 0.8266666666666669,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Wo wir genau wieder bei dem organisatorischen Teil sind, dass es viel schwieriger ist, es organisatorisch zu regeln und du musst dich vielleicht auf ein gemeinsames Datenmodell einigen, aber komplett unabhängig davon, ob du da mit Microservices arbeitest, ob du mit Modulen arbeitest, wenn viele Leute miteinander arbeiten, dann musst du das organisatorisch hinbekommen. Und da ist eigentlich die große Challenge mit der Kommunikation, mit dem Alignment zwischen den Teams. Ob da jetzt eine API dazwischenhängt innerhalb von einem Monolithen oder einer HTTP API oder eine Datenbank mit einem ganz klassischen Modell in der Datenbank, die Probleme hast du immer. Und ich glaube, die gilt es zu lösen. Und dort entstehen auch die Best Practices, die helfen, diese Organisationschallenges zu lösen und alle Teams unter einen Hut zu bringen. Und da ist die Technik meiner Meinung nach komplett egal.",
            "start": 2775401,
            "end": 2825876,
            "confidence": 0.8338417266187049,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Ich bin nicht ganz d'accord, dass die Technik alles komplett egal ist.",
            "start": 2825896,
            "end": 2829278,
            "confidence": 0.8522500000000001,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Ja, natürlich. Du brauchst natürlich schon eine gewisse Technik, die das ermöglicht, dass deine Teams unabhängig sind. Aber ich glaube, viel größer ist die Challenge, die in deinen Teams besteht und mit dem Alignment und der Kommunikation, weil die Technik existiert, die dir das ermöglicht.",
            "start": 2829299,
            "end": 2844552,
            "confidence": 0.8085333333333335,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Das ist richtig, aber z.B. wenn du einen Monolithen hast, manche Probleme treten ja gar nicht auf, wie z.B. das gemeinsame Datenmodell. Mit dem gemeinsamen Datenmodell, das kann zwar anders genutzt werden, aber z.B. angenommen, du hast hintendran eine Datenbank und drei Microservices obendrauf. Was du dann hast, ist eigentlich das Problem, dass du das Datenbankschema nicht ändern kannst, ohne alle drei Services gleichzeitig upzudaten.",
            "start": 2845192,
            "end": 2868722,
            "confidence": 0.8399846153846154,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Ja, aber das Problem hast du in den Monolithen genauso, weil wenn du verschiedene Teams hast, dann fängt jedes Team an mit eigenen Tabellen oder mit irgendwelchen Views auf den Daten und keiner kennt sich mehr aus. Also wenn du dich auch da nicht auf ein Datenmodell einigst oder es sinnvoll im Source Code hast, dass du da die gleichen Entitäten verwendest und nicht wieder extra irgendwas aus der Datenbank rausholst, deine eigenen Modelle baust, was sehr wohl passieren kann, wenn du in einem Source Code arbeitest, was ja ein großes Problem ist. dann scheiterst du auch mit einem Monolithen daran. Und sogar vielleicht noch ordentlich.",
            "start": 2869242,
            "end": 2903748,
            "confidence": 0.7956037735849059,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Wir reden von zwei verschiedenen Dingen. Ich rede von Deployment-Monolithen, wo du drei Microservices hast und das Schemata der Datenbank wird geändert, dass du alle drei Microservices anpassen musst und automatisch gleichzeitig deployen kannst. Du redest von einem Monolithen, wo jeder einzelne Tabellen hat, was dann zu Dateninkonsistenz führen kann. Das sind für mich zwei Probleme. Denn ein Monolith, wo das Schemata geändert wird, wo ein Feld gelöscht wird, wird automatisch angepasst, weil du hast ja einen Monolith.",
            "start": 2903768,
            "end": 2930355,
            "confidence": 0.8614230769230767,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Wie machst du denn das in der Realität? Du musst ja die Datenbank updaten. Die Datenbank ist schon eigene Service von deiner Software. Du kannst nicht gleichzeitig die Datenbank deployen und deine Monolithen. Und wenn dein Monolith fünf...",
            "start": 2930375,
            "end": 2943242,
            "confidence": 0.7465000000000002,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Warum nicht?",
            "start": 2943262,
            "end": 2943843,
            "confidence": 0.892,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Und wenn dein Monolith fünfmal gestartet wird in der Cloud, dann hast du auch noch ein Problem. Wie machst du das? Dann müsstest du alle fünf gleichzeitig durchtreten, dann die Datenbank in der Zwischenzeit updaten und dann wieder alle gleich hochfahren. Sonst hast du ein Problem.",
            "start": 2943883,
            "end": 2957090,
            "confidence": 0.7545217391304349,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Jetzt komm mal raus aus seinen Kinderschuhen. Also jeder weiß ja wohl, dass man nicht einfach ein Feld von jetzt auf gleich löscht, sondern dass man da eine Migrationsphase drin hat, damit man Breaking Change hat, bis alle Services das haben.",
            "start": 2957110,
            "end": 2967802,
            "confidence": 0.7819268292682926,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Ja, aber dann hast du das selber mit drei Services.",
            "start": 2968242,
            "end": 2970164,
            "confidence": 0.6284,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Bei einem Monolith habe ich zwei Release-Cycles für die Migrationsfahrt, bei drei Microservices von drei unabhängigen Teams weiß ich nicht wann es ist, das kann ein Jahr dauern, wenn der eine Microservice das ganze Jahr nicht deployed wird. Bei Monolithen habe ich dafür immer zwei Deployment-Cycles. Einmal es wird angepasst und beim zweiten Mal wird's removed. Das ist ja der Vorteil von Monolithen in der Hinsicht, dass nämlich ein Team unter anderem auch Änderungen an anderen Teams machen kann durch ein Pull-Request. Die werden zwar dann in anderen Klassen gemacht und so weiter und so fort. Dennoch kann das alles in einem Service gemacht werden und somit kann ich Schemata-Änderungen in zwei Deployment-Cycles machen, wobei Microservice natürlich nicht.",
            "start": 2970805,
            "end": 3010378,
            "confidence": 0.8163983050847462,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Aber da sind wir wieder bei dem Thema, dass du dann Microservices oder Services falsch designt hast, weil du ja einen abgeschlossenen Scope haben solltest. Und daher solltest du eigentlich nicht drei Services haben, die auf die gleiche Datenbank zugreifen überhaupt.",
            "start": 3011090,
            "end": 3024836,
            "confidence": 0.8135365853658537,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Und da sind wir jetzt wieder d'accord bei den Herausforderungen. Denn bei einer schlechten Struktur, nämlich wie Microservices genutzt werden, hast du nämlich genau diese Probleme. Wenn nämlich drei Microservices eine Datenbank nimmt, dann hat man halt diesen Deployment Monolithen, weil dann haben die Teams, die die Microservices maintainen, auch keine komplette Autonomie über ihre Daten und Co. Das wiederum, jetzt angenommen jeder dieser Microservices hat jedoch seinen eigenen Datenstorage, hat dann eine andere Herausforderung zur Daten Inkonsistenz. Weil da können nämlich Daten auch auseinanderlaufen. Weil was ist, wenn jeder dieser Datenstorages selbst eine Entität kundemaintaint? Was ja sein kann. Da muss dann ganz stark aufgepasst werden, dass die Datenstände nicht auseinanderlaufen. Beziehungsweise, wer hat die Hoheit? Also ein Microservicesystem ordentlich zu schneiden, dass die Daten konsistent sind, Teams aber autonom unterwegs sind, ist unglaublich hart.",
            "start": 3025116,
            "end": 3083030,
            "confidence": 0.849080882352941,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Und ich glaube, genau das ist der Hauptgrund, warum der Monolith aktuell wieder in aller Munde ist und man vielleicht wieder weiter weg geht von den Microservices, weil diese Dinger einfach extrem kompliziert und komplex sind. Aber gleich wie früher, wie man zu Microservices hin wollte, wo man gesagt hat, Microservices sind nicht die Lösung für alles, Ich würde auch sagen, nur weil man ein Monolith hat, sind nicht alle Probleme gelöst, weil die Kommunikationsprobleme und die Datenmodellierungsprobleme gibt es meiner Meinung nach immer noch, aber vielleicht ist es einfacher, sie zu kontrollieren und in den Griff zu bekommen.",
            "start": 3083690,
            "end": 3115279,
            "confidence": 0.8262525252525255,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Eine Herausforderung bei Microservices, die ich schon öfters erlebt habe, wo die meisten Engineering Teams gar nichts für können, ist einfach, ich sag mal Firmenpolitik. Und zwar geht es um die Umstrukturierung innerhalb einer Firma. Wenn eine Firma wächst oder wenn harte Zeiten im finanziellen Bereich auf die Firma zukommen, dann ist es oft so, dass das C-Level Management oben ein paar Boxen verschiebt. Zwei Abteilungen werden zu einer gemacht, weil das effizienter klingt und so weiter und so fort. Und das C-Level ist natürlich so weit weg von den technischen Implementierungen. Die interessiert das in der Regel ja nicht, ob da Microservices oder Monolithen oder eine serviceorientierte Architektur ist oder Lambda oder oder oder, sondern die schieben Boxen, die schieben Menschen hin und her, um Effizienz zu erschaffen.",
            "start": 3115729,
            "end": 3160484,
            "confidence": 0.847790697674418,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Und zerstören da gleichzeitig unter Umständen ganz viel Effizienz.",
            "start": 3160524,
            "end": 3163506,
            "confidence": 0.7992222222222221,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Ja ganz genau und wir reden die ganze Zeit von Microservices und autonomen Teams und da kommt es dann natürlich auch ganz auf die Ownership drauf an. Mein Team ownt Service A und Service B oder ähnliches und dann werden Leute gemixt und so weiter und auf einmal bleiben da fünf Services über, die keinen Owner mehr haben, weil das Team wegrationalisiert wurde auf Basis von Effizienz und dann hast du da halt so 100 Container irgendwo in deiner Infrastruktur, die dingeln da so ein bisschen rum. Oder du hast auf einmal Teams, weil die unglücklich geschnitten wurden oder unglücklich umstrukturiert wurden, die auf einmal mit sechs Leuten acht Microservices maintainen. Was ja dann das andere Extrem ist.",
            "start": 3164211,
            "end": 3204503,
            "confidence": 0.801127118644068,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Ich meine, diese Möglichkeit ist eh noch die bessere, würde ich sagen, dass Teams zusammengefasst werden oder ein Team ganz viele Microservices wartet. Das ist ja die positivere Variante. Und in diesem Zusammenhang sollte man eigentlich unbedingt Conways Law ins Spiel bringen, haben vielleicht die einen oder anderen schon mal gehört, Gesetz von Conway, die genau diese Problematik beschreibt, dass Schnittstellen in IT-Teams oft so designt werden, wie die Teams gebildet werden. Wenn du jetzt im Nachhinein aber ein Team z.B. zerschneidest, dann hast du das Problem, dass die API nicht mehr die Teamstruktur widerspiegelt und womöglich die Ownership von einer API von einem Service in zwei Teams liegt. Und dann hast du ein Riesenproblem natürlich. Weil ursprünglich wolltest du ja, dass deine Teams möglichst unabhängig sind. Das heißt, die ownen eine API. Das wird so geschnitten. Und plötzlich gibt es zwei Teams, die für eine API verantwortlich sind. Und das müsstest du dann irgendwie trennen. Aber dann gibt es zwei Teams, die einen Monolithen quasi programmieren. Und du hast natürlich ein Riesenproblem. Und daher sind Umstrukturierungen so gefährlich für die internen technischen APIs und Schnittstellen, die existieren.",
            "start": 3205254,
            "end": 3274220,
            "confidence": 0.8187393617021275,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Als wir bei Trivago gearbeitet haben, ist Trivago ja auch sehr stark gewachsen und dann in der Corona-Pandemie vielleicht auch ein bisschen sehr stark wieder geschrumpft. Aber was ich mehrmals gesehen habe, wenn die Firma umstrukturiert wurde, von diesen Umstrukturierungen und dann von diesem Ownership-Shuffling, nenne ich das mal. Ich glaube, wir haben uns noch nie 100 Prozent von einer Umstrukturierung erholt, was dann die Neuallogierung der Ownership der Services und Komponenten Ich glaube, wir hatten immer irgendwelche Services, die dann so ein Catch-all-Team geerbt hat, weil so eine Umstrukturierung kann auf die Softwarearchitektur in Bezug zum Beispiel auf Converse Law einen unglaublichen Longtail haben.",
            "start": 3274920,
            "end": 3314269,
            "confidence": 0.8114761904761907,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Und wir haben das ja in Episode 62 schon besprochen, wo wir diskutiert haben, ob man besser Technologien konsolidieren soll oder einfach jede Programmiersprache oder Technologie verwenden kann, wie man denn so will. Das hat natürlich dann bei so einem Problem auch einen großen Einfluss, weil wenn du plötzlich eine Programmiersprache als Team erbst, die du gar nicht kannst, die du vielleicht noch nie programmiert hast in deinem Leben, dann hast du natürlich auch ein großes Problem. Und umso größer die Firma, umso mehr Umstrukturierungen es gibt, umso schwieriger wird es, diese ganzen Technologien, aber auch die ganzen APIs und Schnittstellen unter einen Hut zu bringen. Und da würde ich mal sagen, bist du vielleicht mit den Monolithen in der gleichen Programmiersprache auch besser dran, als wir mit Microservices. Wobei du natürlich genauso diese harten Cuts und Schnittstellen in der Software haben kannst, also in den Monolithen haben kannst. Aber ich glaube, bei der Microservice-Architektur ist es noch mal schwieriger, solche Umstrukturierungen zu handeln. Aber falls ihr gute Gegenbeispiele kennt, würde uns natürlich freuen, diese zu hören.",
            "start": 3314477,
            "end": 3373686,
            "confidence": 0.8092033898305087,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Wir haben jetzt natürlich ziemlich viel auf beiden Seiten rumgehackt.",
            "start": 3373986,
            "end": 3377149,
            "confidence": 0.6678,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Ja, für mich ist das schon dieses Grundsatzproblem, diese beiden Seiten. Für mich gibt es diese beiden Seiten nicht, sondern es sind einfach Entwicklungen. Man lernt daraus, erstellt wieder Best Practices, die den einen oder anderen Bereich helfen. Meiner Meinung nach gibt es auch nicht diese klare Trennung. Ich habe eine Microservice-Architektur oder nicht, weil heutzutage ist alles in Services eingeteilt und man geht vielleicht weg von dieser Hardcore-Nano-Service-Architektur, zumindest in manchen Bereichen, zurück zu eher monolithischen Herangehensweisen, aber aufgeteilt auf mehrere Services. Darum ist es für mich kein entweder oder oder ich mache die Seite oder die Seite oder die Architektur oder die Architektur. Das ist alles beweglich und wird ständig neu definiert und man muss sich einfach die perfekte Architektur rauspicken und sollte aber die Best Practices, die man so aus den letzten Jahrzehnten gelernt hat, einfach dementsprechend anwenden.",
            "start": 3377330,
            "end": 3429451,
            "confidence": 0.8362482269503545,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Ja gut, du kannst aber auch nicht immer ein Rewrite machen. Für mich ist das so wie Ja.",
            "start": 3429831,
            "end": 3434835,
            "confidence": 0.6535555555555557,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Genau das meine ich. Es ist alles in Bewegung, und es ist beweglich. Also, es gibt nicht X oder Y. Es ist immer irgendwas Flexibles dazwischen.",
            "start": 3434855,
            "end": 3442958,
            "confidence": 0.8068461538461539,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Da solltest du jetzt aber auch nicht in das andere Extrem pendeln, dass du sagst, ja, aber was ist, wenn der Rehort kommt, dann muss das doch flexibel anpassbar sein und so weiter, weil dann shippst du ja auch nie was, dann gehst du ja voll ins Over-Engineering. Also, löst halt schon deine aktuellen Probleme, denke ich, und nicht, ja, was wäre, wenn ... Ich hab da auf dem Flur gehört, dass dieses Team bald, bla, Das macht keinen Sinn. Ich denke einfach nur, es gibt nicht das eine oder andere. Ich denke einfach, beides ist gleich scheiße. Kennst du den Comedian Serdar Suomuncu zum Beispiel?",
            "start": 3443479,
            "end": 3469229,
            "confidence": 0.7695,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Nee.",
            "start": 3469329,
            "end": 3469729,
            "confidence": 0.563,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Serdar Suomuncu ist ein Deutsch-Türke, irgendwie sowas. Und der geht auf die Bühne, der sagt einfach, ich beleidige einfach alle. Ich hack nicht nur auf denen rum, sondern auch auf den anderen. Ich beleidige einfach alle und deswegen sage ich auch, beides ist gleich scheiße. Monolithen sind scheiße, Microservices sind scheiße. Weil irgendwann kommt jemand rum, macht eine Reh-Org, Und dann hast du auch die Probleme. Entweder hast du dann Monolithen, und dann wär eine Microservice-Architektur toll, weil die Teams dann autonomer wären. Oder du hast eine Microservice-Architektur, da kommt ein Re-Org, und dann wird das alles wieder so geschnitten, als hättest du gern Monolithen. Also, ich glaub, du hast immer die Probleme. Und ich glaub, das ist dann auch unser Job, das alles ein bisschen zu richten und vielleicht ein bisschen Awareness da reinzubringen, dass dieses Thema nicht entweder-oder, sondern dass das auch koexistent sein kann. Und dass die ganze Sache nicht so einfach ist, mit einem Kubernetes und einem Service Mesh mit Istio und alles auf GCP. Damit ist es halt auch nicht getan.",
            "start": 3469769,
            "end": 3524869,
            "confidence": 0.7647045454545456,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "So mit dem Positiven hast du es nicht, oder? Alles ist scheiße. Das am Ende hat eh schon positiver geklungen. Wie gesagt, ich glaube, du kannst sehr viel lernen aus dieser ganzen Entwicklung und kannst auch sehr viel rausholen und Probleme vermeiden. Und meiner Meinung nach kannst du sehr wohl strategisch denken und vielleicht, wenn du in einer größeren Firma bist und als CTO oder in Architekturverantwortung, dass du vielleicht zum Beispiel eben nicht diesen Jett-Fowler-Ansatz nimmst, dass jeder alles machen kann, wie es ihm gefällt, sondern wie wir es auch in Episode 62 besprochen haben, vielleicht dann doch gewisse Einschränkungen machst, wenn es um Technologien geht. Also es gibt sehr wohl Dinge, die man auch schon vorausplanen kann, kommt natürlich darauf an, in welcher Ebene man ist und was man zu verantworten hat. Aber ich glaube, ein Blick in die Zukunft kann schon helfen, auch wenn man nicht alles in die Zukunft ausrichten sollte natürlich. Aber wie gesagt, kommt auch darauf an, auf welcher Ebene du bist, wie groß die Firma ist, in welchem Stadium du dich befindest und dann solltest du dementsprechend sinnvolle Entscheidungen treffen und da ändert sich dann natürlich auch der Weitblick, würde ich mal sagen, wie weit du nach vorne blickst oder eben auch gar nicht als kleine Startup vielleicht.",
            "start": 3524889,
            "end": 3590824,
            "confidence": 0.8137255813953491,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Wolfgang, darf ich dir zum Ende dieser Episode noch etwas Feedback geben?",
            "start": 3591264,
            "end": 3595466,
            "confidence": 0.6609166666666667,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Ich bete darum.",
            "start": 3595506,
            "end": 3596646,
            "confidence": 0.6763333333333333,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Dafür, dass du in einem so tiefen Motivationsloch warst, hast du dafür aber sehr energetisch diskutiert. Also so tief kann das Motivationsloch ja auch nicht gewesen sein. Also das ist positives Feedback, weil entweder habe ich einen Weg gefunden, dich auf die Palme zu bringen, oder du bewirbst dich jetzt in Hollywood als Schauspieler, um einem Motivationstief vorzuspielen.",
            "start": 3596686,
            "end": 3617115,
            "confidence": 0.7830517241379311,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Na ja, Motivation heißt ja, dass man über was gerne diskutiert und nicht nur aus seinem Motivationsloch geholt wird, weil der andere einfach Sachen behauptet, wo man unbedingt dagegen was sagen muss. Das ist ja fast Notwehr.",
            "start": 3617635,
            "end": 3629461,
            "confidence": 0.8215405405405406,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Und wo zählst du jetzt diese Podcast Episode dazu?",
            "start": 3629501,
            "end": 3632162,
            "confidence": 0.6057777777777777,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Unter die Notwehr.",
            "start": 3632202,
            "end": 3632982,
            "confidence": 0.8756666666666666,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Liebe Hörerinnen und Hörer, wenn ihr auch was zu diesem Religionskrieg beizutragen habt, könnt ihr gerne in unserer Discord-Community joinen. Link findet ihr auf unserer Webseite und in den Shownotes. Ich denke, es gibt sehr viele Leute mit unterschiedlichen Meinungen zu dem Thema, was uns dann natürlich auch sehr freuen würde, wenn ihr uns von eurer Meinung teilhaben lässt, denn auch wir sind nicht perfekt.",
            "start": 3635617,
            "end": 3657102,
            "confidence": 0.8193999999999999,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Und falls ihr sonst irgendwie Geschichten oder auch Links zu dem Thema habt, freuen wir uns natürlich auch immer in der Community über die Links und den Knowledge Austausch, der dort stattfindet. Es ist immer wieder spannend, den einen oder anderen neuen Blog-Eintrag zu lesen.",
            "start": 3657702,
            "end": 3672252,
            "confidence": 0.7940444444444444,
            "channel": null,
            "speaker": "A"
        },
        {
            "text": "Das war's von uns. Alle Links wie immer in den Show Notes. Wir wünschen euch noch einen schönen Tag und bis bald.",
            "start": 3672272,
            "end": 3678557,
            "confidence": 0.7904545454545455,
            "channel": null,
            "speaker": "B"
        },
        {
            "text": "Tschüss! Ciao!",
            "start": 3679457,
            "end": 3680098,
            "confidence": 0.188,
            "channel": null,
            "speaker": "A"
        }
    ],
    "confidence": 0.8025143362502349,
    "audio_duration": 3685.0,
    "webhook_status_code": null,
    "webhook_auth": false,
    "summary": null,
    "auto_highlights_result": null,
    "content_safety_labels": null,
    "chapters": null,
    "sentiment_analysis_results": null,
    "entities": null
}